// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/debug.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdebug_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdebug_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fdebug_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_s2clientprotocol_2fdebug_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fdebug_2eproto;
namespace SC2APIProtocol {
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class DebugBox;
class DebugBoxDefaultTypeInternal;
extern DebugBoxDefaultTypeInternal _DebugBox_default_instance_;
class DebugCommand;
class DebugCommandDefaultTypeInternal;
extern DebugCommandDefaultTypeInternal _DebugCommand_default_instance_;
class DebugCreateUnit;
class DebugCreateUnitDefaultTypeInternal;
extern DebugCreateUnitDefaultTypeInternal _DebugCreateUnit_default_instance_;
class DebugDraw;
class DebugDrawDefaultTypeInternal;
extern DebugDrawDefaultTypeInternal _DebugDraw_default_instance_;
class DebugEndGame;
class DebugEndGameDefaultTypeInternal;
extern DebugEndGameDefaultTypeInternal _DebugEndGame_default_instance_;
class DebugKillUnit;
class DebugKillUnitDefaultTypeInternal;
extern DebugKillUnitDefaultTypeInternal _DebugKillUnit_default_instance_;
class DebugLine;
class DebugLineDefaultTypeInternal;
extern DebugLineDefaultTypeInternal _DebugLine_default_instance_;
class DebugSetScore;
class DebugSetScoreDefaultTypeInternal;
extern DebugSetScoreDefaultTypeInternal _DebugSetScore_default_instance_;
class DebugSetUnitValue;
class DebugSetUnitValueDefaultTypeInternal;
extern DebugSetUnitValueDefaultTypeInternal _DebugSetUnitValue_default_instance_;
class DebugSphere;
class DebugSphereDefaultTypeInternal;
extern DebugSphereDefaultTypeInternal _DebugSphere_default_instance_;
class DebugTestProcess;
class DebugTestProcessDefaultTypeInternal;
extern DebugTestProcessDefaultTypeInternal _DebugTestProcess_default_instance_;
class DebugText;
class DebugTextDefaultTypeInternal;
extern DebugTextDefaultTypeInternal _DebugText_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::SC2APIProtocol::Color* Arena::CreateMaybeMessage<::SC2APIProtocol::Color>(Arena*);
template<> ::SC2APIProtocol::DebugBox* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugBox>(Arena*);
template<> ::SC2APIProtocol::DebugCommand* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugCommand>(Arena*);
template<> ::SC2APIProtocol::DebugCreateUnit* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugCreateUnit>(Arena*);
template<> ::SC2APIProtocol::DebugDraw* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugDraw>(Arena*);
template<> ::SC2APIProtocol::DebugEndGame* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugEndGame>(Arena*);
template<> ::SC2APIProtocol::DebugKillUnit* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugKillUnit>(Arena*);
template<> ::SC2APIProtocol::DebugLine* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugLine>(Arena*);
template<> ::SC2APIProtocol::DebugSetScore* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugSetScore>(Arena*);
template<> ::SC2APIProtocol::DebugSetUnitValue* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugSetUnitValue>(Arena*);
template<> ::SC2APIProtocol::DebugSphere* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugSphere>(Arena*);
template<> ::SC2APIProtocol::DebugTestProcess* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugTestProcess>(Arena*);
template<> ::SC2APIProtocol::DebugText* Arena::CreateMaybeMessage<::SC2APIProtocol::DebugText>(Arena*);
template<> ::SC2APIProtocol::Line* Arena::CreateMaybeMessage<::SC2APIProtocol::Line>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SC2APIProtocol {

enum DebugTestProcess_Test : int {
  DebugTestProcess_Test_hang = 1,
  DebugTestProcess_Test_crash = 2,
  DebugTestProcess_Test_exit = 3
};
bool DebugTestProcess_Test_IsValid(int value);
constexpr DebugTestProcess_Test DebugTestProcess_Test_Test_MIN = DebugTestProcess_Test_hang;
constexpr DebugTestProcess_Test DebugTestProcess_Test_Test_MAX = DebugTestProcess_Test_exit;
constexpr int DebugTestProcess_Test_Test_ARRAYSIZE = DebugTestProcess_Test_Test_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugTestProcess_Test_descriptor();
template<typename T>
inline const std::string& DebugTestProcess_Test_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugTestProcess_Test>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugTestProcess_Test_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugTestProcess_Test_descriptor(), enum_t_value);
}
inline bool DebugTestProcess_Test_Parse(
    const std::string& name, DebugTestProcess_Test* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugTestProcess_Test>(
    DebugTestProcess_Test_descriptor(), name, value);
}
enum DebugEndGame_EndResult : int {
  DebugEndGame_EndResult_Surrender = 1,
  DebugEndGame_EndResult_DeclareVictory = 2
};
bool DebugEndGame_EndResult_IsValid(int value);
constexpr DebugEndGame_EndResult DebugEndGame_EndResult_EndResult_MIN = DebugEndGame_EndResult_Surrender;
constexpr DebugEndGame_EndResult DebugEndGame_EndResult_EndResult_MAX = DebugEndGame_EndResult_DeclareVictory;
constexpr int DebugEndGame_EndResult_EndResult_ARRAYSIZE = DebugEndGame_EndResult_EndResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugEndGame_EndResult_descriptor();
template<typename T>
inline const std::string& DebugEndGame_EndResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugEndGame_EndResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugEndGame_EndResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugEndGame_EndResult_descriptor(), enum_t_value);
}
inline bool DebugEndGame_EndResult_Parse(
    const std::string& name, DebugEndGame_EndResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugEndGame_EndResult>(
    DebugEndGame_EndResult_descriptor(), name, value);
}
enum DebugSetUnitValue_UnitValue : int {
  DebugSetUnitValue_UnitValue_Energy = 1,
  DebugSetUnitValue_UnitValue_Life = 2,
  DebugSetUnitValue_UnitValue_Shields = 3
};
bool DebugSetUnitValue_UnitValue_IsValid(int value);
constexpr DebugSetUnitValue_UnitValue DebugSetUnitValue_UnitValue_UnitValue_MIN = DebugSetUnitValue_UnitValue_Energy;
constexpr DebugSetUnitValue_UnitValue DebugSetUnitValue_UnitValue_UnitValue_MAX = DebugSetUnitValue_UnitValue_Shields;
constexpr int DebugSetUnitValue_UnitValue_UnitValue_ARRAYSIZE = DebugSetUnitValue_UnitValue_UnitValue_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugSetUnitValue_UnitValue_descriptor();
template<typename T>
inline const std::string& DebugSetUnitValue_UnitValue_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugSetUnitValue_UnitValue>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugSetUnitValue_UnitValue_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugSetUnitValue_UnitValue_descriptor(), enum_t_value);
}
inline bool DebugSetUnitValue_UnitValue_Parse(
    const std::string& name, DebugSetUnitValue_UnitValue* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugSetUnitValue_UnitValue>(
    DebugSetUnitValue_UnitValue_descriptor(), name, value);
}
enum DebugGameState : int {
  show_map = 1,
  control_enemy = 2,
  food = 3,
  free = 4,
  all_resources = 5,
  god = 6,
  minerals = 7,
  gas = 8,
  cooldown = 9,
  tech_tree = 10,
  upgrade = 11,
  fast_build = 12
};
bool DebugGameState_IsValid(int value);
constexpr DebugGameState DebugGameState_MIN = show_map;
constexpr DebugGameState DebugGameState_MAX = fast_build;
constexpr int DebugGameState_ARRAYSIZE = DebugGameState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugGameState_descriptor();
template<typename T>
inline const std::string& DebugGameState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugGameState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugGameState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugGameState_descriptor(), enum_t_value);
}
inline bool DebugGameState_Parse(
    const std::string& name, DebugGameState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugGameState>(
    DebugGameState_descriptor(), name, value);
}
// ===================================================================

class DebugCommand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugCommand) */ {
 public:
  DebugCommand();
  virtual ~DebugCommand();

  DebugCommand(const DebugCommand& from);
  DebugCommand(DebugCommand&& from) noexcept
    : DebugCommand() {
    *this = ::std::move(from);
  }

  inline DebugCommand& operator=(const DebugCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugCommand& operator=(DebugCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugCommand& default_instance();

  enum CommandCase {
    kDraw = 1,
    kGameState = 2,
    kCreateUnit = 3,
    kKillUnit = 4,
    kTestProcess = 5,
    kScore = 6,
    kEndGame = 7,
    kUnitValue = 8,
    COMMAND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugCommand* internal_default_instance() {
    return reinterpret_cast<const DebugCommand*>(
               &_DebugCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DebugCommand& a, DebugCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugCommand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugCommand* New() const final {
    return CreateMaybeMessage<DebugCommand>(nullptr);
  }

  DebugCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugCommand& from);
  void MergeFrom(const DebugCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawFieldNumber = 1,
    kGameStateFieldNumber = 2,
    kCreateUnitFieldNumber = 3,
    kKillUnitFieldNumber = 4,
    kTestProcessFieldNumber = 5,
    kScoreFieldNumber = 6,
    kEndGameFieldNumber = 7,
    kUnitValueFieldNumber = 8,
  };
  // optional .SC2APIProtocol.DebugDraw draw = 1;
  bool has_draw() const;
  private:
  bool _internal_has_draw() const;
  public:
  void clear_draw();
  const ::SC2APIProtocol::DebugDraw& draw() const;
  ::SC2APIProtocol::DebugDraw* release_draw();
  ::SC2APIProtocol::DebugDraw* mutable_draw();
  void set_allocated_draw(::SC2APIProtocol::DebugDraw* draw);
  private:
  const ::SC2APIProtocol::DebugDraw& _internal_draw() const;
  ::SC2APIProtocol::DebugDraw* _internal_mutable_draw();
  public:

  // optional .SC2APIProtocol.DebugGameState game_state = 2;
  bool has_game_state() const;
  private:
  bool _internal_has_game_state() const;
  public:
  void clear_game_state();
  ::SC2APIProtocol::DebugGameState game_state() const;
  void set_game_state(::SC2APIProtocol::DebugGameState value);
  private:
  ::SC2APIProtocol::DebugGameState _internal_game_state() const;
  void _internal_set_game_state(::SC2APIProtocol::DebugGameState value);
  public:

  // optional .SC2APIProtocol.DebugCreateUnit create_unit = 3;
  bool has_create_unit() const;
  private:
  bool _internal_has_create_unit() const;
  public:
  void clear_create_unit();
  const ::SC2APIProtocol::DebugCreateUnit& create_unit() const;
  ::SC2APIProtocol::DebugCreateUnit* release_create_unit();
  ::SC2APIProtocol::DebugCreateUnit* mutable_create_unit();
  void set_allocated_create_unit(::SC2APIProtocol::DebugCreateUnit* create_unit);
  private:
  const ::SC2APIProtocol::DebugCreateUnit& _internal_create_unit() const;
  ::SC2APIProtocol::DebugCreateUnit* _internal_mutable_create_unit();
  public:

  // optional .SC2APIProtocol.DebugKillUnit kill_unit = 4;
  bool has_kill_unit() const;
  private:
  bool _internal_has_kill_unit() const;
  public:
  void clear_kill_unit();
  const ::SC2APIProtocol::DebugKillUnit& kill_unit() const;
  ::SC2APIProtocol::DebugKillUnit* release_kill_unit();
  ::SC2APIProtocol::DebugKillUnit* mutable_kill_unit();
  void set_allocated_kill_unit(::SC2APIProtocol::DebugKillUnit* kill_unit);
  private:
  const ::SC2APIProtocol::DebugKillUnit& _internal_kill_unit() const;
  ::SC2APIProtocol::DebugKillUnit* _internal_mutable_kill_unit();
  public:

  // optional .SC2APIProtocol.DebugTestProcess test_process = 5;
  bool has_test_process() const;
  private:
  bool _internal_has_test_process() const;
  public:
  void clear_test_process();
  const ::SC2APIProtocol::DebugTestProcess& test_process() const;
  ::SC2APIProtocol::DebugTestProcess* release_test_process();
  ::SC2APIProtocol::DebugTestProcess* mutable_test_process();
  void set_allocated_test_process(::SC2APIProtocol::DebugTestProcess* test_process);
  private:
  const ::SC2APIProtocol::DebugTestProcess& _internal_test_process() const;
  ::SC2APIProtocol::DebugTestProcess* _internal_mutable_test_process();
  public:

  // optional .SC2APIProtocol.DebugSetScore score = 6;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  const ::SC2APIProtocol::DebugSetScore& score() const;
  ::SC2APIProtocol::DebugSetScore* release_score();
  ::SC2APIProtocol::DebugSetScore* mutable_score();
  void set_allocated_score(::SC2APIProtocol::DebugSetScore* score);
  private:
  const ::SC2APIProtocol::DebugSetScore& _internal_score() const;
  ::SC2APIProtocol::DebugSetScore* _internal_mutable_score();
  public:

  // optional .SC2APIProtocol.DebugEndGame end_game = 7;
  bool has_end_game() const;
  private:
  bool _internal_has_end_game() const;
  public:
  void clear_end_game();
  const ::SC2APIProtocol::DebugEndGame& end_game() const;
  ::SC2APIProtocol::DebugEndGame* release_end_game();
  ::SC2APIProtocol::DebugEndGame* mutable_end_game();
  void set_allocated_end_game(::SC2APIProtocol::DebugEndGame* end_game);
  private:
  const ::SC2APIProtocol::DebugEndGame& _internal_end_game() const;
  ::SC2APIProtocol::DebugEndGame* _internal_mutable_end_game();
  public:

  // optional .SC2APIProtocol.DebugSetUnitValue unit_value = 8;
  bool has_unit_value() const;
  private:
  bool _internal_has_unit_value() const;
  public:
  void clear_unit_value();
  const ::SC2APIProtocol::DebugSetUnitValue& unit_value() const;
  ::SC2APIProtocol::DebugSetUnitValue* release_unit_value();
  ::SC2APIProtocol::DebugSetUnitValue* mutable_unit_value();
  void set_allocated_unit_value(::SC2APIProtocol::DebugSetUnitValue* unit_value);
  private:
  const ::SC2APIProtocol::DebugSetUnitValue& _internal_unit_value() const;
  ::SC2APIProtocol::DebugSetUnitValue* _internal_mutable_unit_value();
  public:

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugCommand)
 private:
  class _Internal;
  void set_has_draw();
  void set_has_game_state();
  void set_has_create_unit();
  void set_has_kill_unit();
  void set_has_test_process();
  void set_has_score();
  void set_has_end_game();
  void set_has_unit_value();

  inline bool has_command() const;
  inline void clear_has_command();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union CommandUnion {
    CommandUnion() {}
    ::SC2APIProtocol::DebugDraw* draw_;
    int game_state_;
    ::SC2APIProtocol::DebugCreateUnit* create_unit_;
    ::SC2APIProtocol::DebugKillUnit* kill_unit_;
    ::SC2APIProtocol::DebugTestProcess* test_process_;
    ::SC2APIProtocol::DebugSetScore* score_;
    ::SC2APIProtocol::DebugEndGame* end_game_;
    ::SC2APIProtocol::DebugSetUnitValue* unit_value_;
  } command_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugDraw :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugDraw) */ {
 public:
  DebugDraw();
  virtual ~DebugDraw();

  DebugDraw(const DebugDraw& from);
  DebugDraw(DebugDraw&& from) noexcept
    : DebugDraw() {
    *this = ::std::move(from);
  }

  inline DebugDraw& operator=(const DebugDraw& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugDraw& operator=(DebugDraw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugDraw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugDraw* internal_default_instance() {
    return reinterpret_cast<const DebugDraw*>(
               &_DebugDraw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DebugDraw& a, DebugDraw& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugDraw* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugDraw* New() const final {
    return CreateMaybeMessage<DebugDraw>(nullptr);
  }

  DebugDraw* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugDraw>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugDraw& from);
  void MergeFrom(const DebugDraw& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugDraw* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugDraw";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kLinesFieldNumber = 2,
    kBoxesFieldNumber = 3,
    kSpheresFieldNumber = 4,
  };
  // repeated .SC2APIProtocol.DebugText text = 1;
  int text_size() const;
  private:
  int _internal_text_size() const;
  public:
  void clear_text();
  ::SC2APIProtocol::DebugText* mutable_text(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >*
      mutable_text();
  private:
  const ::SC2APIProtocol::DebugText& _internal_text(int index) const;
  ::SC2APIProtocol::DebugText* _internal_add_text();
  public:
  const ::SC2APIProtocol::DebugText& text(int index) const;
  ::SC2APIProtocol::DebugText* add_text();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >&
      text() const;

  // repeated .SC2APIProtocol.DebugLine lines = 2;
  int lines_size() const;
  private:
  int _internal_lines_size() const;
  public:
  void clear_lines();
  ::SC2APIProtocol::DebugLine* mutable_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >*
      mutable_lines();
  private:
  const ::SC2APIProtocol::DebugLine& _internal_lines(int index) const;
  ::SC2APIProtocol::DebugLine* _internal_add_lines();
  public:
  const ::SC2APIProtocol::DebugLine& lines(int index) const;
  ::SC2APIProtocol::DebugLine* add_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >&
      lines() const;

  // repeated .SC2APIProtocol.DebugBox boxes = 3;
  int boxes_size() const;
  private:
  int _internal_boxes_size() const;
  public:
  void clear_boxes();
  ::SC2APIProtocol::DebugBox* mutable_boxes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >*
      mutable_boxes();
  private:
  const ::SC2APIProtocol::DebugBox& _internal_boxes(int index) const;
  ::SC2APIProtocol::DebugBox* _internal_add_boxes();
  public:
  const ::SC2APIProtocol::DebugBox& boxes(int index) const;
  ::SC2APIProtocol::DebugBox* add_boxes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >&
      boxes() const;

  // repeated .SC2APIProtocol.DebugSphere spheres = 4;
  int spheres_size() const;
  private:
  int _internal_spheres_size() const;
  public:
  void clear_spheres();
  ::SC2APIProtocol::DebugSphere* mutable_spheres(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >*
      mutable_spheres();
  private:
  const ::SC2APIProtocol::DebugSphere& _internal_spheres(int index) const;
  ::SC2APIProtocol::DebugSphere* _internal_add_spheres();
  public:
  const ::SC2APIProtocol::DebugSphere& spheres(int index) const;
  ::SC2APIProtocol::DebugSphere* add_spheres();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >&
      spheres() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugDraw)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText > text_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine > lines_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox > boxes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere > spheres_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class Line :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const final {
    return CreateMaybeMessage<Line>(nullptr);
  }

  Line* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Line";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP0FieldNumber = 1,
    kP1FieldNumber = 2,
  };
  // optional .SC2APIProtocol.Point p0 = 1;
  bool has_p0() const;
  private:
  bool _internal_has_p0() const;
  public:
  void clear_p0();
  const ::SC2APIProtocol::Point& p0() const;
  ::SC2APIProtocol::Point* release_p0();
  ::SC2APIProtocol::Point* mutable_p0();
  void set_allocated_p0(::SC2APIProtocol::Point* p0);
  private:
  const ::SC2APIProtocol::Point& _internal_p0() const;
  ::SC2APIProtocol::Point* _internal_mutable_p0();
  public:

  // optional .SC2APIProtocol.Point p1 = 2;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  const ::SC2APIProtocol::Point& p1() const;
  ::SC2APIProtocol::Point* release_p1();
  ::SC2APIProtocol::Point* mutable_p1();
  void set_allocated_p1(::SC2APIProtocol::Point* p1);
  private:
  const ::SC2APIProtocol::Point& _internal_p1() const;
  ::SC2APIProtocol::Point* _internal_mutable_p1();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Line)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Point* p0_;
  ::SC2APIProtocol::Point* p1_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class Color :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Color) */ {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(nullptr);
  }

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Color";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // optional uint32 r = 1;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  ::PROTOBUF_NAMESPACE_ID::uint32 r() const;
  void set_r(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_r() const;
  void _internal_set_r(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 g = 2;
  bool has_g() const;
  private:
  bool _internal_has_g() const;
  public:
  void clear_g();
  ::PROTOBUF_NAMESPACE_ID::uint32 g() const;
  void set_g(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_g() const;
  void _internal_set_g(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 b = 3;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  ::PROTOBUF_NAMESPACE_ID::uint32 b() const;
  void set_b(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_b() const;
  void _internal_set_b(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Color)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 r_;
  ::PROTOBUF_NAMESPACE_ID::uint32 g_;
  ::PROTOBUF_NAMESPACE_ID::uint32 b_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugText :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugText) */ {
 public:
  DebugText();
  virtual ~DebugText();

  DebugText(const DebugText& from);
  DebugText(DebugText&& from) noexcept
    : DebugText() {
    *this = ::std::move(from);
  }

  inline DebugText& operator=(const DebugText& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugText& operator=(DebugText&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugText& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugText* internal_default_instance() {
    return reinterpret_cast<const DebugText*>(
               &_DebugText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DebugText& a, DebugText& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugText* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugText* New() const final {
    return CreateMaybeMessage<DebugText>(nullptr);
  }

  DebugText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugText>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugText& from);
  void MergeFrom(const DebugText& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugText* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugText";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kColorFieldNumber = 1,
    kVirtualPosFieldNumber = 3,
    kWorldPosFieldNumber = 4,
    kSizeFieldNumber = 5,
  };
  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:

  // optional .SC2APIProtocol.Point virtual_pos = 3;
  bool has_virtual_pos() const;
  private:
  bool _internal_has_virtual_pos() const;
  public:
  void clear_virtual_pos();
  const ::SC2APIProtocol::Point& virtual_pos() const;
  ::SC2APIProtocol::Point* release_virtual_pos();
  ::SC2APIProtocol::Point* mutable_virtual_pos();
  void set_allocated_virtual_pos(::SC2APIProtocol::Point* virtual_pos);
  private:
  const ::SC2APIProtocol::Point& _internal_virtual_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_virtual_pos();
  public:

  // optional .SC2APIProtocol.Point world_pos = 4;
  bool has_world_pos() const;
  private:
  bool _internal_has_world_pos() const;
  public:
  void clear_world_pos();
  const ::SC2APIProtocol::Point& world_pos() const;
  ::SC2APIProtocol::Point* release_world_pos();
  ::SC2APIProtocol::Point* mutable_world_pos();
  void set_allocated_world_pos(::SC2APIProtocol::Point* world_pos);
  private:
  const ::SC2APIProtocol::Point& _internal_world_pos() const;
  ::SC2APIProtocol::Point* _internal_mutable_world_pos();
  public:

  // optional uint32 size = 5;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugText)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::SC2APIProtocol::Color* color_;
  ::SC2APIProtocol::Point* virtual_pos_;
  ::SC2APIProtocol::Point* world_pos_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugLine :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugLine) */ {
 public:
  DebugLine();
  virtual ~DebugLine();

  DebugLine(const DebugLine& from);
  DebugLine(DebugLine&& from) noexcept
    : DebugLine() {
    *this = ::std::move(from);
  }

  inline DebugLine& operator=(const DebugLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugLine& operator=(DebugLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugLine* internal_default_instance() {
    return reinterpret_cast<const DebugLine*>(
               &_DebugLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DebugLine& a, DebugLine& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugLine* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugLine* New() const final {
    return CreateMaybeMessage<DebugLine>(nullptr);
  }

  DebugLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugLine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugLine& from);
  void MergeFrom(const DebugLine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugLine";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kLineFieldNumber = 2,
  };
  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:

  // optional .SC2APIProtocol.Line line = 2;
  bool has_line() const;
  private:
  bool _internal_has_line() const;
  public:
  void clear_line();
  const ::SC2APIProtocol::Line& line() const;
  ::SC2APIProtocol::Line* release_line();
  ::SC2APIProtocol::Line* mutable_line();
  void set_allocated_line(::SC2APIProtocol::Line* line);
  private:
  const ::SC2APIProtocol::Line& _internal_line() const;
  ::SC2APIProtocol::Line* _internal_mutable_line();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugLine)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Color* color_;
  ::SC2APIProtocol::Line* line_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugBox :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugBox) */ {
 public:
  DebugBox();
  virtual ~DebugBox();

  DebugBox(const DebugBox& from);
  DebugBox(DebugBox&& from) noexcept
    : DebugBox() {
    *this = ::std::move(from);
  }

  inline DebugBox& operator=(const DebugBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugBox& operator=(DebugBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugBox* internal_default_instance() {
    return reinterpret_cast<const DebugBox*>(
               &_DebugBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DebugBox& a, DebugBox& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugBox* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugBox* New() const final {
    return CreateMaybeMessage<DebugBox>(nullptr);
  }

  DebugBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugBox>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugBox& from);
  void MergeFrom(const DebugBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugBox* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugBox";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:

  // optional .SC2APIProtocol.Point min = 2;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::SC2APIProtocol::Point& min() const;
  ::SC2APIProtocol::Point* release_min();
  ::SC2APIProtocol::Point* mutable_min();
  void set_allocated_min(::SC2APIProtocol::Point* min);
  private:
  const ::SC2APIProtocol::Point& _internal_min() const;
  ::SC2APIProtocol::Point* _internal_mutable_min();
  public:

  // optional .SC2APIProtocol.Point max = 3;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::SC2APIProtocol::Point& max() const;
  ::SC2APIProtocol::Point* release_max();
  ::SC2APIProtocol::Point* mutable_max();
  void set_allocated_max(::SC2APIProtocol::Point* max);
  private:
  const ::SC2APIProtocol::Point& _internal_max() const;
  ::SC2APIProtocol::Point* _internal_mutable_max();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugBox)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Color* color_;
  ::SC2APIProtocol::Point* min_;
  ::SC2APIProtocol::Point* max_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugSphere :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugSphere) */ {
 public:
  DebugSphere();
  virtual ~DebugSphere();

  DebugSphere(const DebugSphere& from);
  DebugSphere(DebugSphere&& from) noexcept
    : DebugSphere() {
    *this = ::std::move(from);
  }

  inline DebugSphere& operator=(const DebugSphere& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSphere& operator=(DebugSphere&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugSphere& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSphere* internal_default_instance() {
    return reinterpret_cast<const DebugSphere*>(
               &_DebugSphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DebugSphere& a, DebugSphere& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSphere* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugSphere* New() const final {
    return CreateMaybeMessage<DebugSphere>(nullptr);
  }

  DebugSphere* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugSphere>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugSphere& from);
  void MergeFrom(const DebugSphere& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSphere* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugSphere";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kPFieldNumber = 2,
    kRFieldNumber = 3,
  };
  // optional .SC2APIProtocol.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::SC2APIProtocol::Color& color() const;
  ::SC2APIProtocol::Color* release_color();
  ::SC2APIProtocol::Color* mutable_color();
  void set_allocated_color(::SC2APIProtocol::Color* color);
  private:
  const ::SC2APIProtocol::Color& _internal_color() const;
  ::SC2APIProtocol::Color* _internal_mutable_color();
  public:

  // optional .SC2APIProtocol.Point p = 2;
  bool has_p() const;
  private:
  bool _internal_has_p() const;
  public:
  void clear_p();
  const ::SC2APIProtocol::Point& p() const;
  ::SC2APIProtocol::Point* release_p();
  ::SC2APIProtocol::Point* mutable_p();
  void set_allocated_p(::SC2APIProtocol::Point* p);
  private:
  const ::SC2APIProtocol::Point& _internal_p() const;
  ::SC2APIProtocol::Point* _internal_mutable_p();
  public:

  // optional float r = 3;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugSphere)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Color* color_;
  ::SC2APIProtocol::Point* p_;
  float r_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugCreateUnit :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugCreateUnit) */ {
 public:
  DebugCreateUnit();
  virtual ~DebugCreateUnit();

  DebugCreateUnit(const DebugCreateUnit& from);
  DebugCreateUnit(DebugCreateUnit&& from) noexcept
    : DebugCreateUnit() {
    *this = ::std::move(from);
  }

  inline DebugCreateUnit& operator=(const DebugCreateUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugCreateUnit& operator=(DebugCreateUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugCreateUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugCreateUnit* internal_default_instance() {
    return reinterpret_cast<const DebugCreateUnit*>(
               &_DebugCreateUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DebugCreateUnit& a, DebugCreateUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugCreateUnit* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugCreateUnit* New() const final {
    return CreateMaybeMessage<DebugCreateUnit>(nullptr);
  }

  DebugCreateUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugCreateUnit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugCreateUnit& from);
  void MergeFrom(const DebugCreateUnit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugCreateUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugCreateUnit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 3,
    kUnitTypeFieldNumber = 1,
    kOwnerFieldNumber = 2,
    kQuantityFieldNumber = 4,
  };
  // optional .SC2APIProtocol.Point2D pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::SC2APIProtocol::Point2D& pos() const;
  ::SC2APIProtocol::Point2D* release_pos();
  ::SC2APIProtocol::Point2D* mutable_pos();
  void set_allocated_pos(::SC2APIProtocol::Point2D* pos);
  private:
  const ::SC2APIProtocol::Point2D& _internal_pos() const;
  ::SC2APIProtocol::Point2D* _internal_mutable_pos();
  public:

  // optional uint32 unit_type = 1;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 unit_type() const;
  void set_unit_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unit_type() const;
  void _internal_set_unit_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 owner = 2;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  ::PROTOBUF_NAMESPACE_ID::int32 owner() const;
  void set_owner(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_owner() const;
  void _internal_set_owner(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 quantity = 4;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  ::PROTOBUF_NAMESPACE_ID::uint32 quantity() const;
  void set_quantity(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_quantity() const;
  void _internal_set_quantity(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugCreateUnit)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Point2D* pos_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unit_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 owner_;
  ::PROTOBUF_NAMESPACE_ID::uint32 quantity_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugKillUnit :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugKillUnit) */ {
 public:
  DebugKillUnit();
  virtual ~DebugKillUnit();

  DebugKillUnit(const DebugKillUnit& from);
  DebugKillUnit(DebugKillUnit&& from) noexcept
    : DebugKillUnit() {
    *this = ::std::move(from);
  }

  inline DebugKillUnit& operator=(const DebugKillUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugKillUnit& operator=(DebugKillUnit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugKillUnit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugKillUnit* internal_default_instance() {
    return reinterpret_cast<const DebugKillUnit*>(
               &_DebugKillUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DebugKillUnit& a, DebugKillUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugKillUnit* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugKillUnit* New() const final {
    return CreateMaybeMessage<DebugKillUnit>(nullptr);
  }

  DebugKillUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugKillUnit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugKillUnit& from);
  void MergeFrom(const DebugKillUnit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugKillUnit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugKillUnit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
  };
  // repeated uint64 tag = 1;
  int tag_size() const;
  private:
  int _internal_tag_size() const;
  public:
  void clear_tag();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tag(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_tag() const;
  void _internal_add_tag(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_tag();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 tag(int index) const;
  void set_tag(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_tag(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      tag() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_tag();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugKillUnit)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > tag_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugTestProcess :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugTestProcess) */ {
 public:
  DebugTestProcess();
  virtual ~DebugTestProcess();

  DebugTestProcess(const DebugTestProcess& from);
  DebugTestProcess(DebugTestProcess&& from) noexcept
    : DebugTestProcess() {
    *this = ::std::move(from);
  }

  inline DebugTestProcess& operator=(const DebugTestProcess& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugTestProcess& operator=(DebugTestProcess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugTestProcess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugTestProcess* internal_default_instance() {
    return reinterpret_cast<const DebugTestProcess*>(
               &_DebugTestProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DebugTestProcess& a, DebugTestProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugTestProcess* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugTestProcess* New() const final {
    return CreateMaybeMessage<DebugTestProcess>(nullptr);
  }

  DebugTestProcess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugTestProcess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugTestProcess& from);
  void MergeFrom(const DebugTestProcess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugTestProcess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugTestProcess";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DebugTestProcess_Test Test;
  static constexpr Test hang =
    DebugTestProcess_Test_hang;
  static constexpr Test crash =
    DebugTestProcess_Test_crash;
  static constexpr Test exit =
    DebugTestProcess_Test_exit;
  static inline bool Test_IsValid(int value) {
    return DebugTestProcess_Test_IsValid(value);
  }
  static constexpr Test Test_MIN =
    DebugTestProcess_Test_Test_MIN;
  static constexpr Test Test_MAX =
    DebugTestProcess_Test_Test_MAX;
  static constexpr int Test_ARRAYSIZE =
    DebugTestProcess_Test_Test_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Test_descriptor() {
    return DebugTestProcess_Test_descriptor();
  }
  template<typename T>
  static inline const std::string& Test_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Test>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Test_Name.");
    return DebugTestProcess_Test_Name(enum_t_value);
  }
  static inline bool Test_Parse(const std::string& name,
      Test* value) {
    return DebugTestProcess_Test_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDelayMsFieldNumber = 2,
    kTestFieldNumber = 1,
  };
  // optional int32 delay_ms = 2;
  bool has_delay_ms() const;
  private:
  bool _internal_has_delay_ms() const;
  public:
  void clear_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 delay_ms() const;
  void set_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_delay_ms() const;
  void _internal_set_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .SC2APIProtocol.DebugTestProcess.Test test = 1;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  ::SC2APIProtocol::DebugTestProcess_Test test() const;
  void set_test(::SC2APIProtocol::DebugTestProcess_Test value);
  private:
  ::SC2APIProtocol::DebugTestProcess_Test _internal_test() const;
  void _internal_set_test(::SC2APIProtocol::DebugTestProcess_Test value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugTestProcess)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 delay_ms_;
  int test_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugSetScore :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugSetScore) */ {
 public:
  DebugSetScore();
  virtual ~DebugSetScore();

  DebugSetScore(const DebugSetScore& from);
  DebugSetScore(DebugSetScore&& from) noexcept
    : DebugSetScore() {
    *this = ::std::move(from);
  }

  inline DebugSetScore& operator=(const DebugSetScore& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSetScore& operator=(DebugSetScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugSetScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSetScore* internal_default_instance() {
    return reinterpret_cast<const DebugSetScore*>(
               &_DebugSetScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DebugSetScore& a, DebugSetScore& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSetScore* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugSetScore* New() const final {
    return CreateMaybeMessage<DebugSetScore>(nullptr);
  }

  DebugSetScore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugSetScore>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugSetScore& from);
  void MergeFrom(const DebugSetScore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSetScore* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugSetScore";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScoreFieldNumber = 1,
  };
  // optional float score = 1;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugSetScore)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float score_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugEndGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugEndGame) */ {
 public:
  DebugEndGame();
  virtual ~DebugEndGame();

  DebugEndGame(const DebugEndGame& from);
  DebugEndGame(DebugEndGame&& from) noexcept
    : DebugEndGame() {
    *this = ::std::move(from);
  }

  inline DebugEndGame& operator=(const DebugEndGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugEndGame& operator=(DebugEndGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugEndGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugEndGame* internal_default_instance() {
    return reinterpret_cast<const DebugEndGame*>(
               &_DebugEndGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DebugEndGame& a, DebugEndGame& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugEndGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugEndGame* New() const final {
    return CreateMaybeMessage<DebugEndGame>(nullptr);
  }

  DebugEndGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugEndGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugEndGame& from);
  void MergeFrom(const DebugEndGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugEndGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugEndGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DebugEndGame_EndResult EndResult;
  static constexpr EndResult Surrender =
    DebugEndGame_EndResult_Surrender;
  static constexpr EndResult DeclareVictory =
    DebugEndGame_EndResult_DeclareVictory;
  static inline bool EndResult_IsValid(int value) {
    return DebugEndGame_EndResult_IsValid(value);
  }
  static constexpr EndResult EndResult_MIN =
    DebugEndGame_EndResult_EndResult_MIN;
  static constexpr EndResult EndResult_MAX =
    DebugEndGame_EndResult_EndResult_MAX;
  static constexpr int EndResult_ARRAYSIZE =
    DebugEndGame_EndResult_EndResult_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EndResult_descriptor() {
    return DebugEndGame_EndResult_descriptor();
  }
  template<typename T>
  static inline const std::string& EndResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EndResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EndResult_Name.");
    return DebugEndGame_EndResult_Name(enum_t_value);
  }
  static inline bool EndResult_Parse(const std::string& name,
      EndResult* value) {
    return DebugEndGame_EndResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEndResultFieldNumber = 1,
  };
  // optional .SC2APIProtocol.DebugEndGame.EndResult end_result = 1;
  bool has_end_result() const;
  private:
  bool _internal_has_end_result() const;
  public:
  void clear_end_result();
  ::SC2APIProtocol::DebugEndGame_EndResult end_result() const;
  void set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value);
  private:
  ::SC2APIProtocol::DebugEndGame_EndResult _internal_end_result() const;
  void _internal_set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugEndGame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int end_result_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// -------------------------------------------------------------------

class DebugSetUnitValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DebugSetUnitValue) */ {
 public:
  DebugSetUnitValue();
  virtual ~DebugSetUnitValue();

  DebugSetUnitValue(const DebugSetUnitValue& from);
  DebugSetUnitValue(DebugSetUnitValue&& from) noexcept
    : DebugSetUnitValue() {
    *this = ::std::move(from);
  }

  inline DebugSetUnitValue& operator=(const DebugSetUnitValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugSetUnitValue& operator=(DebugSetUnitValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugSetUnitValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugSetUnitValue* internal_default_instance() {
    return reinterpret_cast<const DebugSetUnitValue*>(
               &_DebugSetUnitValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DebugSetUnitValue& a, DebugSetUnitValue& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugSetUnitValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugSetUnitValue* New() const final {
    return CreateMaybeMessage<DebugSetUnitValue>(nullptr);
  }

  DebugSetUnitValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugSetUnitValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugSetUnitValue& from);
  void MergeFrom(const DebugSetUnitValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugSetUnitValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DebugSetUnitValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdebug_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdebug_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DebugSetUnitValue_UnitValue UnitValue;
  static constexpr UnitValue Energy =
    DebugSetUnitValue_UnitValue_Energy;
  static constexpr UnitValue Life =
    DebugSetUnitValue_UnitValue_Life;
  static constexpr UnitValue Shields =
    DebugSetUnitValue_UnitValue_Shields;
  static inline bool UnitValue_IsValid(int value) {
    return DebugSetUnitValue_UnitValue_IsValid(value);
  }
  static constexpr UnitValue UnitValue_MIN =
    DebugSetUnitValue_UnitValue_UnitValue_MIN;
  static constexpr UnitValue UnitValue_MAX =
    DebugSetUnitValue_UnitValue_UnitValue_MAX;
  static constexpr int UnitValue_ARRAYSIZE =
    DebugSetUnitValue_UnitValue_UnitValue_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UnitValue_descriptor() {
    return DebugSetUnitValue_UnitValue_descriptor();
  }
  template<typename T>
  static inline const std::string& UnitValue_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UnitValue>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UnitValue_Name.");
    return DebugSetUnitValue_UnitValue_Name(enum_t_value);
  }
  static inline bool UnitValue_Parse(const std::string& name,
      UnitValue* value) {
    return DebugSetUnitValue_UnitValue_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUnitTagFieldNumber = 3,
    kValueFieldNumber = 2,
    kUnitValueFieldNumber = 1,
  };
  // optional uint64 unit_tag = 3;
  bool has_unit_tag() const;
  private:
  bool _internal_has_unit_tag() const;
  public:
  void clear_unit_tag();
  ::PROTOBUF_NAMESPACE_ID::uint64 unit_tag() const;
  void set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_unit_tag() const;
  void _internal_set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional float value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // optional .SC2APIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;
  bool has_unit_value() const;
  private:
  bool _internal_has_unit_value() const;
  public:
  void clear_unit_value();
  ::SC2APIProtocol::DebugSetUnitValue_UnitValue unit_value() const;
  void set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value);
  private:
  ::SC2APIProtocol::DebugSetUnitValue_UnitValue _internal_unit_value() const;
  void _internal_set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DebugSetUnitValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 unit_tag_;
  float value_;
  int unit_value_;
  friend struct ::TableStruct_s2clientprotocol_2fdebug_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DebugCommand

// optional .SC2APIProtocol.DebugDraw draw = 1;
inline bool DebugCommand::_internal_has_draw() const {
  return command_case() == kDraw;
}
inline bool DebugCommand::has_draw() const {
  return _internal_has_draw();
}
inline void DebugCommand::set_has_draw() {
  _oneof_case_[0] = kDraw;
}
inline void DebugCommand::clear_draw() {
  if (_internal_has_draw()) {
    delete command_.draw_;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugDraw* DebugCommand::release_draw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.draw)
  if (_internal_has_draw()) {
    clear_has_command();
      ::SC2APIProtocol::DebugDraw* temp = command_.draw_;
    command_.draw_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugDraw& DebugCommand::_internal_draw() const {
  return _internal_has_draw()
      ? *command_.draw_
      : *reinterpret_cast< ::SC2APIProtocol::DebugDraw*>(&::SC2APIProtocol::_DebugDraw_default_instance_);
}
inline const ::SC2APIProtocol::DebugDraw& DebugCommand::draw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.draw)
  return _internal_draw();
}
inline ::SC2APIProtocol::DebugDraw* DebugCommand::_internal_mutable_draw() {
  if (!_internal_has_draw()) {
    clear_command();
    set_has_draw();
    command_.draw_ = CreateMaybeMessage< ::SC2APIProtocol::DebugDraw >(
        GetArenaNoVirtual());
  }
  return command_.draw_;
}
inline ::SC2APIProtocol::DebugDraw* DebugCommand::mutable_draw() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.draw)
  return _internal_mutable_draw();
}

// optional .SC2APIProtocol.DebugGameState game_state = 2;
inline bool DebugCommand::_internal_has_game_state() const {
  return command_case() == kGameState;
}
inline bool DebugCommand::has_game_state() const {
  return _internal_has_game_state();
}
inline void DebugCommand::set_has_game_state() {
  _oneof_case_[0] = kGameState;
}
inline void DebugCommand::clear_game_state() {
  if (_internal_has_game_state()) {
    command_.game_state_ = 1;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugGameState DebugCommand::_internal_game_state() const {
  if (_internal_has_game_state()) {
    return static_cast< ::SC2APIProtocol::DebugGameState >(command_.game_state_);
  }
  return static_cast< ::SC2APIProtocol::DebugGameState >(1);
}
inline ::SC2APIProtocol::DebugGameState DebugCommand::game_state() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.game_state)
  return _internal_game_state();
}
inline void DebugCommand::_internal_set_game_state(::SC2APIProtocol::DebugGameState value) {
  assert(::SC2APIProtocol::DebugGameState_IsValid(value));
  if (!_internal_has_game_state()) {
    clear_command();
    set_has_game_state();
  }
  command_.game_state_ = value;
}
inline void DebugCommand::set_game_state(::SC2APIProtocol::DebugGameState value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCommand.game_state)
  _internal_set_game_state(value);
}

// optional .SC2APIProtocol.DebugCreateUnit create_unit = 3;
inline bool DebugCommand::_internal_has_create_unit() const {
  return command_case() == kCreateUnit;
}
inline bool DebugCommand::has_create_unit() const {
  return _internal_has_create_unit();
}
inline void DebugCommand::set_has_create_unit() {
  _oneof_case_[0] = kCreateUnit;
}
inline void DebugCommand::clear_create_unit() {
  if (_internal_has_create_unit()) {
    delete command_.create_unit_;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugCreateUnit* DebugCommand::release_create_unit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.create_unit)
  if (_internal_has_create_unit()) {
    clear_has_command();
      ::SC2APIProtocol::DebugCreateUnit* temp = command_.create_unit_;
    command_.create_unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugCreateUnit& DebugCommand::_internal_create_unit() const {
  return _internal_has_create_unit()
      ? *command_.create_unit_
      : *reinterpret_cast< ::SC2APIProtocol::DebugCreateUnit*>(&::SC2APIProtocol::_DebugCreateUnit_default_instance_);
}
inline const ::SC2APIProtocol::DebugCreateUnit& DebugCommand::create_unit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.create_unit)
  return _internal_create_unit();
}
inline ::SC2APIProtocol::DebugCreateUnit* DebugCommand::_internal_mutable_create_unit() {
  if (!_internal_has_create_unit()) {
    clear_command();
    set_has_create_unit();
    command_.create_unit_ = CreateMaybeMessage< ::SC2APIProtocol::DebugCreateUnit >(
        GetArenaNoVirtual());
  }
  return command_.create_unit_;
}
inline ::SC2APIProtocol::DebugCreateUnit* DebugCommand::mutable_create_unit() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.create_unit)
  return _internal_mutable_create_unit();
}

// optional .SC2APIProtocol.DebugKillUnit kill_unit = 4;
inline bool DebugCommand::_internal_has_kill_unit() const {
  return command_case() == kKillUnit;
}
inline bool DebugCommand::has_kill_unit() const {
  return _internal_has_kill_unit();
}
inline void DebugCommand::set_has_kill_unit() {
  _oneof_case_[0] = kKillUnit;
}
inline void DebugCommand::clear_kill_unit() {
  if (_internal_has_kill_unit()) {
    delete command_.kill_unit_;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugKillUnit* DebugCommand::release_kill_unit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.kill_unit)
  if (_internal_has_kill_unit()) {
    clear_has_command();
      ::SC2APIProtocol::DebugKillUnit* temp = command_.kill_unit_;
    command_.kill_unit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugKillUnit& DebugCommand::_internal_kill_unit() const {
  return _internal_has_kill_unit()
      ? *command_.kill_unit_
      : *reinterpret_cast< ::SC2APIProtocol::DebugKillUnit*>(&::SC2APIProtocol::_DebugKillUnit_default_instance_);
}
inline const ::SC2APIProtocol::DebugKillUnit& DebugCommand::kill_unit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.kill_unit)
  return _internal_kill_unit();
}
inline ::SC2APIProtocol::DebugKillUnit* DebugCommand::_internal_mutable_kill_unit() {
  if (!_internal_has_kill_unit()) {
    clear_command();
    set_has_kill_unit();
    command_.kill_unit_ = CreateMaybeMessage< ::SC2APIProtocol::DebugKillUnit >(
        GetArenaNoVirtual());
  }
  return command_.kill_unit_;
}
inline ::SC2APIProtocol::DebugKillUnit* DebugCommand::mutable_kill_unit() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.kill_unit)
  return _internal_mutable_kill_unit();
}

// optional .SC2APIProtocol.DebugTestProcess test_process = 5;
inline bool DebugCommand::_internal_has_test_process() const {
  return command_case() == kTestProcess;
}
inline bool DebugCommand::has_test_process() const {
  return _internal_has_test_process();
}
inline void DebugCommand::set_has_test_process() {
  _oneof_case_[0] = kTestProcess;
}
inline void DebugCommand::clear_test_process() {
  if (_internal_has_test_process()) {
    delete command_.test_process_;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugTestProcess* DebugCommand::release_test_process() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.test_process)
  if (_internal_has_test_process()) {
    clear_has_command();
      ::SC2APIProtocol::DebugTestProcess* temp = command_.test_process_;
    command_.test_process_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugTestProcess& DebugCommand::_internal_test_process() const {
  return _internal_has_test_process()
      ? *command_.test_process_
      : *reinterpret_cast< ::SC2APIProtocol::DebugTestProcess*>(&::SC2APIProtocol::_DebugTestProcess_default_instance_);
}
inline const ::SC2APIProtocol::DebugTestProcess& DebugCommand::test_process() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.test_process)
  return _internal_test_process();
}
inline ::SC2APIProtocol::DebugTestProcess* DebugCommand::_internal_mutable_test_process() {
  if (!_internal_has_test_process()) {
    clear_command();
    set_has_test_process();
    command_.test_process_ = CreateMaybeMessage< ::SC2APIProtocol::DebugTestProcess >(
        GetArenaNoVirtual());
  }
  return command_.test_process_;
}
inline ::SC2APIProtocol::DebugTestProcess* DebugCommand::mutable_test_process() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.test_process)
  return _internal_mutable_test_process();
}

// optional .SC2APIProtocol.DebugSetScore score = 6;
inline bool DebugCommand::_internal_has_score() const {
  return command_case() == kScore;
}
inline bool DebugCommand::has_score() const {
  return _internal_has_score();
}
inline void DebugCommand::set_has_score() {
  _oneof_case_[0] = kScore;
}
inline void DebugCommand::clear_score() {
  if (_internal_has_score()) {
    delete command_.score_;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugSetScore* DebugCommand::release_score() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.score)
  if (_internal_has_score()) {
    clear_has_command();
      ::SC2APIProtocol::DebugSetScore* temp = command_.score_;
    command_.score_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugSetScore& DebugCommand::_internal_score() const {
  return _internal_has_score()
      ? *command_.score_
      : *reinterpret_cast< ::SC2APIProtocol::DebugSetScore*>(&::SC2APIProtocol::_DebugSetScore_default_instance_);
}
inline const ::SC2APIProtocol::DebugSetScore& DebugCommand::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.score)
  return _internal_score();
}
inline ::SC2APIProtocol::DebugSetScore* DebugCommand::_internal_mutable_score() {
  if (!_internal_has_score()) {
    clear_command();
    set_has_score();
    command_.score_ = CreateMaybeMessage< ::SC2APIProtocol::DebugSetScore >(
        GetArenaNoVirtual());
  }
  return command_.score_;
}
inline ::SC2APIProtocol::DebugSetScore* DebugCommand::mutable_score() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.score)
  return _internal_mutable_score();
}

// optional .SC2APIProtocol.DebugEndGame end_game = 7;
inline bool DebugCommand::_internal_has_end_game() const {
  return command_case() == kEndGame;
}
inline bool DebugCommand::has_end_game() const {
  return _internal_has_end_game();
}
inline void DebugCommand::set_has_end_game() {
  _oneof_case_[0] = kEndGame;
}
inline void DebugCommand::clear_end_game() {
  if (_internal_has_end_game()) {
    delete command_.end_game_;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugEndGame* DebugCommand::release_end_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.end_game)
  if (_internal_has_end_game()) {
    clear_has_command();
      ::SC2APIProtocol::DebugEndGame* temp = command_.end_game_;
    command_.end_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugEndGame& DebugCommand::_internal_end_game() const {
  return _internal_has_end_game()
      ? *command_.end_game_
      : *reinterpret_cast< ::SC2APIProtocol::DebugEndGame*>(&::SC2APIProtocol::_DebugEndGame_default_instance_);
}
inline const ::SC2APIProtocol::DebugEndGame& DebugCommand::end_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.end_game)
  return _internal_end_game();
}
inline ::SC2APIProtocol::DebugEndGame* DebugCommand::_internal_mutable_end_game() {
  if (!_internal_has_end_game()) {
    clear_command();
    set_has_end_game();
    command_.end_game_ = CreateMaybeMessage< ::SC2APIProtocol::DebugEndGame >(
        GetArenaNoVirtual());
  }
  return command_.end_game_;
}
inline ::SC2APIProtocol::DebugEndGame* DebugCommand::mutable_end_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.end_game)
  return _internal_mutable_end_game();
}

// optional .SC2APIProtocol.DebugSetUnitValue unit_value = 8;
inline bool DebugCommand::_internal_has_unit_value() const {
  return command_case() == kUnitValue;
}
inline bool DebugCommand::has_unit_value() const {
  return _internal_has_unit_value();
}
inline void DebugCommand::set_has_unit_value() {
  _oneof_case_[0] = kUnitValue;
}
inline void DebugCommand::clear_unit_value() {
  if (_internal_has_unit_value()) {
    delete command_.unit_value_;
    clear_has_command();
  }
}
inline ::SC2APIProtocol::DebugSetUnitValue* DebugCommand::release_unit_value() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCommand.unit_value)
  if (_internal_has_unit_value()) {
    clear_has_command();
      ::SC2APIProtocol::DebugSetUnitValue* temp = command_.unit_value_;
    command_.unit_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::DebugSetUnitValue& DebugCommand::_internal_unit_value() const {
  return _internal_has_unit_value()
      ? *command_.unit_value_
      : *reinterpret_cast< ::SC2APIProtocol::DebugSetUnitValue*>(&::SC2APIProtocol::_DebugSetUnitValue_default_instance_);
}
inline const ::SC2APIProtocol::DebugSetUnitValue& DebugCommand::unit_value() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCommand.unit_value)
  return _internal_unit_value();
}
inline ::SC2APIProtocol::DebugSetUnitValue* DebugCommand::_internal_mutable_unit_value() {
  if (!_internal_has_unit_value()) {
    clear_command();
    set_has_unit_value();
    command_.unit_value_ = CreateMaybeMessage< ::SC2APIProtocol::DebugSetUnitValue >(
        GetArenaNoVirtual());
  }
  return command_.unit_value_;
}
inline ::SC2APIProtocol::DebugSetUnitValue* DebugCommand::mutable_unit_value() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCommand.unit_value)
  return _internal_mutable_unit_value();
}

inline bool DebugCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void DebugCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline DebugCommand::CommandCase DebugCommand::command_case() const {
  return DebugCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DebugDraw

// repeated .SC2APIProtocol.DebugText text = 1;
inline int DebugDraw::_internal_text_size() const {
  return text_.size();
}
inline int DebugDraw::text_size() const {
  return _internal_text_size();
}
inline void DebugDraw::clear_text() {
  text_.Clear();
}
inline ::SC2APIProtocol::DebugText* DebugDraw::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.text)
  return text_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >*
DebugDraw::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.text)
  return &text_;
}
inline const ::SC2APIProtocol::DebugText& DebugDraw::_internal_text(int index) const {
  return text_.Get(index);
}
inline const ::SC2APIProtocol::DebugText& DebugDraw::text(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.text)
  return _internal_text(index);
}
inline ::SC2APIProtocol::DebugText* DebugDraw::_internal_add_text() {
  return text_.Add();
}
inline ::SC2APIProtocol::DebugText* DebugDraw::add_text() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.text)
  return _internal_add_text();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugText >&
DebugDraw::text() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.text)
  return text_;
}

// repeated .SC2APIProtocol.DebugLine lines = 2;
inline int DebugDraw::_internal_lines_size() const {
  return lines_.size();
}
inline int DebugDraw::lines_size() const {
  return _internal_lines_size();
}
inline void DebugDraw::clear_lines() {
  lines_.Clear();
}
inline ::SC2APIProtocol::DebugLine* DebugDraw::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.lines)
  return lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >*
DebugDraw::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.lines)
  return &lines_;
}
inline const ::SC2APIProtocol::DebugLine& DebugDraw::_internal_lines(int index) const {
  return lines_.Get(index);
}
inline const ::SC2APIProtocol::DebugLine& DebugDraw::lines(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.lines)
  return _internal_lines(index);
}
inline ::SC2APIProtocol::DebugLine* DebugDraw::_internal_add_lines() {
  return lines_.Add();
}
inline ::SC2APIProtocol::DebugLine* DebugDraw::add_lines() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.lines)
  return _internal_add_lines();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugLine >&
DebugDraw::lines() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.lines)
  return lines_;
}

// repeated .SC2APIProtocol.DebugBox boxes = 3;
inline int DebugDraw::_internal_boxes_size() const {
  return boxes_.size();
}
inline int DebugDraw::boxes_size() const {
  return _internal_boxes_size();
}
inline void DebugDraw::clear_boxes() {
  boxes_.Clear();
}
inline ::SC2APIProtocol::DebugBox* DebugDraw::mutable_boxes(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.boxes)
  return boxes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >*
DebugDraw::mutable_boxes() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.boxes)
  return &boxes_;
}
inline const ::SC2APIProtocol::DebugBox& DebugDraw::_internal_boxes(int index) const {
  return boxes_.Get(index);
}
inline const ::SC2APIProtocol::DebugBox& DebugDraw::boxes(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.boxes)
  return _internal_boxes(index);
}
inline ::SC2APIProtocol::DebugBox* DebugDraw::_internal_add_boxes() {
  return boxes_.Add();
}
inline ::SC2APIProtocol::DebugBox* DebugDraw::add_boxes() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.boxes)
  return _internal_add_boxes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugBox >&
DebugDraw::boxes() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.boxes)
  return boxes_;
}

// repeated .SC2APIProtocol.DebugSphere spheres = 4;
inline int DebugDraw::_internal_spheres_size() const {
  return spheres_.size();
}
inline int DebugDraw::spheres_size() const {
  return _internal_spheres_size();
}
inline void DebugDraw::clear_spheres() {
  spheres_.Clear();
}
inline ::SC2APIProtocol::DebugSphere* DebugDraw::mutable_spheres(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugDraw.spheres)
  return spheres_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >*
DebugDraw::mutable_spheres() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugDraw.spheres)
  return &spheres_;
}
inline const ::SC2APIProtocol::DebugSphere& DebugDraw::_internal_spheres(int index) const {
  return spheres_.Get(index);
}
inline const ::SC2APIProtocol::DebugSphere& DebugDraw::spheres(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugDraw.spheres)
  return _internal_spheres(index);
}
inline ::SC2APIProtocol::DebugSphere* DebugDraw::_internal_add_spheres() {
  return spheres_.Add();
}
inline ::SC2APIProtocol::DebugSphere* DebugDraw::add_spheres() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugDraw.spheres)
  return _internal_add_spheres();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugSphere >&
DebugDraw::spheres() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugDraw.spheres)
  return spheres_;
}

// -------------------------------------------------------------------

// Line

// optional .SC2APIProtocol.Point p0 = 1;
inline bool Line::_internal_has_p0() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || p0_ != nullptr);
  return value;
}
inline bool Line::has_p0() const {
  return _internal_has_p0();
}
inline const ::SC2APIProtocol::Point& Line::_internal_p0() const {
  const ::SC2APIProtocol::Point* p = p0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point*>(
      &::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& Line::p0() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Line.p0)
  return _internal_p0();
}
inline ::SC2APIProtocol::Point* Line::release_p0() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Line.p0)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point* temp = p0_;
  p0_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* Line::_internal_mutable_p0() {
  _has_bits_[0] |= 0x00000001u;
  if (p0_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaNoVirtual());
    p0_ = p;
  }
  return p0_;
}
inline ::SC2APIProtocol::Point* Line::mutable_p0() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Line.p0)
  return _internal_mutable_p0();
}
inline void Line::set_allocated_p0(::SC2APIProtocol::Point* p0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(p0_);
  }
  if (p0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      p0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p0, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  p0_ = p0;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Line.p0)
}

// optional .SC2APIProtocol.Point p1 = 2;
inline bool Line::_internal_has_p1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || p1_ != nullptr);
  return value;
}
inline bool Line::has_p1() const {
  return _internal_has_p1();
}
inline const ::SC2APIProtocol::Point& Line::_internal_p1() const {
  const ::SC2APIProtocol::Point* p = p1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point*>(
      &::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& Line::p1() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Line.p1)
  return _internal_p1();
}
inline ::SC2APIProtocol::Point* Line::release_p1() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Line.p1)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = p1_;
  p1_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* Line::_internal_mutable_p1() {
  _has_bits_[0] |= 0x00000002u;
  if (p1_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaNoVirtual());
    p1_ = p;
  }
  return p1_;
}
inline ::SC2APIProtocol::Point* Line::mutable_p1() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Line.p1)
  return _internal_mutable_p1();
}
inline void Line::set_allocated_p1(::SC2APIProtocol::Point* p1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(p1_);
  }
  if (p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Line.p1)
}

// -------------------------------------------------------------------

// Color

// optional uint32 r = 1;
inline bool Color::_internal_has_r() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Color::has_r() const {
  return _internal_has_r();
}
inline void Color::clear_r() {
  r_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::_internal_r() const {
  return r_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::r() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  r_ = value;
}
inline void Color::set_r(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Color.r)
}

// optional uint32 g = 2;
inline bool Color::_internal_has_g() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Color::has_g() const {
  return _internal_has_g();
}
inline void Color::clear_g() {
  g_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::_internal_g() const {
  return g_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::g() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  g_ = value;
}
inline void Color::set_g(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Color.g)
}

// optional uint32 b = 3;
inline bool Color::_internal_has_b() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Color::has_b() const {
  return _internal_has_b();
}
inline void Color::clear_b() {
  b_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::_internal_b() const {
  return b_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::b() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  b_ = value;
}
inline void Color::set_b(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Color.b)
}

// -------------------------------------------------------------------

// DebugText

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugText::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool DebugText::has_color() const {
  return _internal_has_color();
}
inline void DebugText::clear_color() {
  if (color_ != nullptr) color_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::Color& DebugText::_internal_color() const {
  const ::SC2APIProtocol::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Color*>(
      &::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugText::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.color)
  return _internal_color();
}
inline ::SC2APIProtocol::Color* DebugText::release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.color)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugText::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000002u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::SC2APIProtocol::Color* DebugText::mutable_color() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.color)
  return _internal_mutable_color();
}
inline void DebugText::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.color)
}

// optional string text = 2;
inline bool DebugText::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugText::has_text() const {
  return _internal_has_text();
}
inline void DebugText::clear_text() {
  text_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DebugText::text() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.text)
  return _internal_text();
}
inline void DebugText::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugText.text)
}
inline std::string* DebugText::mutable_text() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.text)
  return _internal_mutable_text();
}
inline const std::string& DebugText::_internal_text() const {
  return text_.GetNoArena();
}
inline void DebugText::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DebugText::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.DebugText.text)
}
inline void DebugText::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.DebugText.text)
}
inline void DebugText::set_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.DebugText.text)
}
inline std::string* DebugText::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DebugText::release_text() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DebugText::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.text)
}

// optional .SC2APIProtocol.Point virtual_pos = 3;
inline bool DebugText::_internal_has_virtual_pos() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || virtual_pos_ != nullptr);
  return value;
}
inline bool DebugText::has_virtual_pos() const {
  return _internal_has_virtual_pos();
}
inline const ::SC2APIProtocol::Point& DebugText::_internal_virtual_pos() const {
  const ::SC2APIProtocol::Point* p = virtual_pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point*>(
      &::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugText::virtual_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.virtual_pos)
  return _internal_virtual_pos();
}
inline ::SC2APIProtocol::Point* DebugText::release_virtual_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.virtual_pos)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Point* temp = virtual_pos_;
  virtual_pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugText::_internal_mutable_virtual_pos() {
  _has_bits_[0] |= 0x00000004u;
  if (virtual_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaNoVirtual());
    virtual_pos_ = p;
  }
  return virtual_pos_;
}
inline ::SC2APIProtocol::Point* DebugText::mutable_virtual_pos() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.virtual_pos)
  return _internal_mutable_virtual_pos();
}
inline void DebugText::set_allocated_virtual_pos(::SC2APIProtocol::Point* virtual_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_pos_);
  }
  if (virtual_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      virtual_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  virtual_pos_ = virtual_pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.virtual_pos)
}

// optional .SC2APIProtocol.Point world_pos = 4;
inline bool DebugText::_internal_has_world_pos() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || world_pos_ != nullptr);
  return value;
}
inline bool DebugText::has_world_pos() const {
  return _internal_has_world_pos();
}
inline const ::SC2APIProtocol::Point& DebugText::_internal_world_pos() const {
  const ::SC2APIProtocol::Point* p = world_pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point*>(
      &::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugText::world_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.world_pos)
  return _internal_world_pos();
}
inline ::SC2APIProtocol::Point* DebugText::release_world_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugText.world_pos)
  _has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::Point* temp = world_pos_;
  world_pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugText::_internal_mutable_world_pos() {
  _has_bits_[0] |= 0x00000008u;
  if (world_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaNoVirtual());
    world_pos_ = p;
  }
  return world_pos_;
}
inline ::SC2APIProtocol::Point* DebugText::mutable_world_pos() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugText.world_pos)
  return _internal_mutable_world_pos();
}
inline void DebugText::set_allocated_world_pos(::SC2APIProtocol::Point* world_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_pos_);
  }
  if (world_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      world_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  world_pos_ = world_pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugText.world_pos)
}

// optional uint32 size = 5;
inline bool DebugText::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DebugText::has_size() const {
  return _internal_has_size();
}
inline void DebugText::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugText::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugText::size() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugText.size)
  return _internal_size();
}
inline void DebugText::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  size_ = value;
}
inline void DebugText::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugText.size)
}

// -------------------------------------------------------------------

// DebugLine

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugLine::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool DebugLine::has_color() const {
  return _internal_has_color();
}
inline void DebugLine::clear_color() {
  if (color_ != nullptr) color_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Color& DebugLine::_internal_color() const {
  const ::SC2APIProtocol::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Color*>(
      &::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugLine::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugLine.color)
  return _internal_color();
}
inline ::SC2APIProtocol::Color* DebugLine::release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugLine.color)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugLine::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::SC2APIProtocol::Color* DebugLine::mutable_color() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugLine.color)
  return _internal_mutable_color();
}
inline void DebugLine::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugLine.color)
}

// optional .SC2APIProtocol.Line line = 2;
inline bool DebugLine::_internal_has_line() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || line_ != nullptr);
  return value;
}
inline bool DebugLine::has_line() const {
  return _internal_has_line();
}
inline void DebugLine::clear_line() {
  if (line_ != nullptr) line_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::Line& DebugLine::_internal_line() const {
  const ::SC2APIProtocol::Line* p = line_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Line*>(
      &::SC2APIProtocol::_Line_default_instance_);
}
inline const ::SC2APIProtocol::Line& DebugLine::line() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugLine.line)
  return _internal_line();
}
inline ::SC2APIProtocol::Line* DebugLine::release_line() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugLine.line)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Line* temp = line_;
  line_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Line* DebugLine::_internal_mutable_line() {
  _has_bits_[0] |= 0x00000002u;
  if (line_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Line>(GetArenaNoVirtual());
    line_ = p;
  }
  return line_;
}
inline ::SC2APIProtocol::Line* DebugLine::mutable_line() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugLine.line)
  return _internal_mutable_line();
}
inline void DebugLine::set_allocated_line(::SC2APIProtocol::Line* line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete line_;
  }
  if (line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, line, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  line_ = line;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugLine.line)
}

// -------------------------------------------------------------------

// DebugBox

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugBox::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool DebugBox::has_color() const {
  return _internal_has_color();
}
inline void DebugBox::clear_color() {
  if (color_ != nullptr) color_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Color& DebugBox::_internal_color() const {
  const ::SC2APIProtocol::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Color*>(
      &::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugBox::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugBox.color)
  return _internal_color();
}
inline ::SC2APIProtocol::Color* DebugBox::release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugBox.color)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugBox::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::SC2APIProtocol::Color* DebugBox::mutable_color() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugBox.color)
  return _internal_mutable_color();
}
inline void DebugBox::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugBox.color)
}

// optional .SC2APIProtocol.Point min = 2;
inline bool DebugBox::_internal_has_min() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || min_ != nullptr);
  return value;
}
inline bool DebugBox::has_min() const {
  return _internal_has_min();
}
inline const ::SC2APIProtocol::Point& DebugBox::_internal_min() const {
  const ::SC2APIProtocol::Point* p = min_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point*>(
      &::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugBox::min() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugBox.min)
  return _internal_min();
}
inline ::SC2APIProtocol::Point* DebugBox::release_min() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugBox.min)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = min_;
  min_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugBox::_internal_mutable_min() {
  _has_bits_[0] |= 0x00000002u;
  if (min_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaNoVirtual());
    min_ = p;
  }
  return min_;
}
inline ::SC2APIProtocol::Point* DebugBox::mutable_min() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugBox.min)
  return _internal_mutable_min();
}
inline void DebugBox::set_allocated_min(::SC2APIProtocol::Point* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_);
  }
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  min_ = min;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugBox.min)
}

// optional .SC2APIProtocol.Point max = 3;
inline bool DebugBox::_internal_has_max() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || max_ != nullptr);
  return value;
}
inline bool DebugBox::has_max() const {
  return _internal_has_max();
}
inline const ::SC2APIProtocol::Point& DebugBox::_internal_max() const {
  const ::SC2APIProtocol::Point* p = max_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point*>(
      &::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugBox::max() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugBox.max)
  return _internal_max();
}
inline ::SC2APIProtocol::Point* DebugBox::release_max() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugBox.max)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::Point* temp = max_;
  max_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugBox::_internal_mutable_max() {
  _has_bits_[0] |= 0x00000004u;
  if (max_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaNoVirtual());
    max_ = p;
  }
  return max_;
}
inline ::SC2APIProtocol::Point* DebugBox::mutable_max() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugBox.max)
  return _internal_mutable_max();
}
inline void DebugBox::set_allocated_max(::SC2APIProtocol::Point* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_);
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  max_ = max;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugBox.max)
}

// -------------------------------------------------------------------

// DebugSphere

// optional .SC2APIProtocol.Color color = 1;
inline bool DebugSphere::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || color_ != nullptr);
  return value;
}
inline bool DebugSphere::has_color() const {
  return _internal_has_color();
}
inline void DebugSphere::clear_color() {
  if (color_ != nullptr) color_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Color& DebugSphere::_internal_color() const {
  const ::SC2APIProtocol::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Color*>(
      &::SC2APIProtocol::_Color_default_instance_);
}
inline const ::SC2APIProtocol::Color& DebugSphere::color() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSphere.color)
  return _internal_color();
}
inline ::SC2APIProtocol::Color* DebugSphere::release_color() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugSphere.color)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Color* DebugSphere::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  return color_;
}
inline ::SC2APIProtocol::Color* DebugSphere::mutable_color() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugSphere.color)
  return _internal_mutable_color();
}
inline void DebugSphere::set_allocated_color(::SC2APIProtocol::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugSphere.color)
}

// optional .SC2APIProtocol.Point p = 2;
inline bool DebugSphere::_internal_has_p() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || p_ != nullptr);
  return value;
}
inline bool DebugSphere::has_p() const {
  return _internal_has_p();
}
inline const ::SC2APIProtocol::Point& DebugSphere::_internal_p() const {
  const ::SC2APIProtocol::Point* p = p_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point*>(
      &::SC2APIProtocol::_Point_default_instance_);
}
inline const ::SC2APIProtocol::Point& DebugSphere::p() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSphere.p)
  return _internal_p();
}
inline ::SC2APIProtocol::Point* DebugSphere::release_p() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugSphere.p)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Point* temp = p_;
  p_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point* DebugSphere::_internal_mutable_p() {
  _has_bits_[0] |= 0x00000002u;
  if (p_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point>(GetArenaNoVirtual());
    p_ = p;
  }
  return p_;
}
inline ::SC2APIProtocol::Point* DebugSphere::mutable_p() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugSphere.p)
  return _internal_mutable_p();
}
inline void DebugSphere::set_allocated_p(::SC2APIProtocol::Point* p) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(p_);
  }
  if (p) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      p = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  p_ = p;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugSphere.p)
}

// optional float r = 3;
inline bool DebugSphere::_internal_has_r() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugSphere::has_r() const {
  return _internal_has_r();
}
inline void DebugSphere::clear_r() {
  r_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float DebugSphere::_internal_r() const {
  return r_;
}
inline float DebugSphere::r() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSphere.r)
  return _internal_r();
}
inline void DebugSphere::_internal_set_r(float value) {
  _has_bits_[0] |= 0x00000004u;
  r_ = value;
}
inline void DebugSphere::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSphere.r)
}

// -------------------------------------------------------------------

// DebugCreateUnit

// optional uint32 unit_type = 1;
inline bool DebugCreateUnit::_internal_has_unit_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugCreateUnit::has_unit_type() const {
  return _internal_has_unit_type();
}
inline void DebugCreateUnit::clear_unit_type() {
  unit_type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugCreateUnit::_internal_unit_type() const {
  return unit_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugCreateUnit::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.unit_type)
  return _internal_unit_type();
}
inline void DebugCreateUnit::_internal_set_unit_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  unit_type_ = value;
}
inline void DebugCreateUnit::set_unit_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unit_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCreateUnit.unit_type)
}

// optional int32 owner = 2;
inline bool DebugCreateUnit::_internal_has_owner() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugCreateUnit::has_owner() const {
  return _internal_has_owner();
}
inline void DebugCreateUnit::clear_owner() {
  owner_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DebugCreateUnit::_internal_owner() const {
  return owner_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DebugCreateUnit::owner() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.owner)
  return _internal_owner();
}
inline void DebugCreateUnit::_internal_set_owner(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  owner_ = value;
}
inline void DebugCreateUnit::set_owner(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCreateUnit.owner)
}

// optional .SC2APIProtocol.Point2D pos = 3;
inline bool DebugCreateUnit::_internal_has_pos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pos_ != nullptr);
  return value;
}
inline bool DebugCreateUnit::has_pos() const {
  return _internal_has_pos();
}
inline const ::SC2APIProtocol::Point2D& DebugCreateUnit::_internal_pos() const {
  const ::SC2APIProtocol::Point2D* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point2D*>(
      &::SC2APIProtocol::_Point2D_default_instance_);
}
inline const ::SC2APIProtocol::Point2D& DebugCreateUnit::pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.pos)
  return _internal_pos();
}
inline ::SC2APIProtocol::Point2D* DebugCreateUnit::release_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.DebugCreateUnit.pos)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point2D* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point2D* DebugCreateUnit::_internal_mutable_pos() {
  _has_bits_[0] |= 0x00000001u;
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point2D>(GetArenaNoVirtual());
    pos_ = p;
  }
  return pos_;
}
inline ::SC2APIProtocol::Point2D* DebugCreateUnit::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.DebugCreateUnit.pos)
  return _internal_mutable_pos();
}
inline void DebugCreateUnit::set_allocated_pos(::SC2APIProtocol::Point2D* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.DebugCreateUnit.pos)
}

// optional uint32 quantity = 4;
inline bool DebugCreateUnit::_internal_has_quantity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DebugCreateUnit::has_quantity() const {
  return _internal_has_quantity();
}
inline void DebugCreateUnit::clear_quantity() {
  quantity_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugCreateUnit::_internal_quantity() const {
  return quantity_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DebugCreateUnit::quantity() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugCreateUnit.quantity)
  return _internal_quantity();
}
inline void DebugCreateUnit::_internal_set_quantity(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  quantity_ = value;
}
inline void DebugCreateUnit::set_quantity(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugCreateUnit.quantity)
}

// -------------------------------------------------------------------

// DebugKillUnit

// repeated uint64 tag = 1;
inline int DebugKillUnit::_internal_tag_size() const {
  return tag_.size();
}
inline int DebugKillUnit::tag_size() const {
  return _internal_tag_size();
}
inline void DebugKillUnit::clear_tag() {
  tag_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DebugKillUnit::_internal_tag(int index) const {
  return tag_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DebugKillUnit::tag(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugKillUnit.tag)
  return _internal_tag(index);
}
inline void DebugKillUnit::set_tag(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  tag_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugKillUnit.tag)
}
inline void DebugKillUnit::_internal_add_tag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  tag_.Add(value);
}
inline void DebugKillUnit::add_tag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_tag(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.DebugKillUnit.tag)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
DebugKillUnit::_internal_tag() const {
  return tag_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
DebugKillUnit::tag() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.DebugKillUnit.tag)
  return _internal_tag();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
DebugKillUnit::_internal_mutable_tag() {
  return &tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
DebugKillUnit::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.DebugKillUnit.tag)
  return _internal_mutable_tag();
}

// -------------------------------------------------------------------

// DebugTestProcess

// optional .SC2APIProtocol.DebugTestProcess.Test test = 1;
inline bool DebugTestProcess::_internal_has_test() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugTestProcess::has_test() const {
  return _internal_has_test();
}
inline void DebugTestProcess::clear_test() {
  test_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::DebugTestProcess_Test DebugTestProcess::_internal_test() const {
  return static_cast< ::SC2APIProtocol::DebugTestProcess_Test >(test_);
}
inline ::SC2APIProtocol::DebugTestProcess_Test DebugTestProcess::test() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugTestProcess.test)
  return _internal_test();
}
inline void DebugTestProcess::_internal_set_test(::SC2APIProtocol::DebugTestProcess_Test value) {
  assert(::SC2APIProtocol::DebugTestProcess_Test_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  test_ = value;
}
inline void DebugTestProcess::set_test(::SC2APIProtocol::DebugTestProcess_Test value) {
  _internal_set_test(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugTestProcess.test)
}

// optional int32 delay_ms = 2;
inline bool DebugTestProcess::_internal_has_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugTestProcess::has_delay_ms() const {
  return _internal_has_delay_ms();
}
inline void DebugTestProcess::clear_delay_ms() {
  delay_ms_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DebugTestProcess::_internal_delay_ms() const {
  return delay_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DebugTestProcess::delay_ms() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugTestProcess.delay_ms)
  return _internal_delay_ms();
}
inline void DebugTestProcess::_internal_set_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  delay_ms_ = value;
}
inline void DebugTestProcess::set_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugTestProcess.delay_ms)
}

// -------------------------------------------------------------------

// DebugSetScore

// optional float score = 1;
inline bool DebugSetScore::_internal_has_score() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugSetScore::has_score() const {
  return _internal_has_score();
}
inline void DebugSetScore::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float DebugSetScore::_internal_score() const {
  return score_;
}
inline float DebugSetScore::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetScore.score)
  return _internal_score();
}
inline void DebugSetScore::_internal_set_score(float value) {
  _has_bits_[0] |= 0x00000001u;
  score_ = value;
}
inline void DebugSetScore::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetScore.score)
}

// -------------------------------------------------------------------

// DebugEndGame

// optional .SC2APIProtocol.DebugEndGame.EndResult end_result = 1;
inline bool DebugEndGame::_internal_has_end_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugEndGame::has_end_result() const {
  return _internal_has_end_result();
}
inline void DebugEndGame::clear_end_result() {
  end_result_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::SC2APIProtocol::DebugEndGame_EndResult DebugEndGame::_internal_end_result() const {
  return static_cast< ::SC2APIProtocol::DebugEndGame_EndResult >(end_result_);
}
inline ::SC2APIProtocol::DebugEndGame_EndResult DebugEndGame::end_result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugEndGame.end_result)
  return _internal_end_result();
}
inline void DebugEndGame::_internal_set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value) {
  assert(::SC2APIProtocol::DebugEndGame_EndResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  end_result_ = value;
}
inline void DebugEndGame::set_end_result(::SC2APIProtocol::DebugEndGame_EndResult value) {
  _internal_set_end_result(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugEndGame.end_result)
}

// -------------------------------------------------------------------

// DebugSetUnitValue

// optional .SC2APIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;
inline bool DebugSetUnitValue::_internal_has_unit_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DebugSetUnitValue::has_unit_value() const {
  return _internal_has_unit_value();
}
inline void DebugSetUnitValue::clear_unit_value() {
  unit_value_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SC2APIProtocol::DebugSetUnitValue_UnitValue DebugSetUnitValue::_internal_unit_value() const {
  return static_cast< ::SC2APIProtocol::DebugSetUnitValue_UnitValue >(unit_value_);
}
inline ::SC2APIProtocol::DebugSetUnitValue_UnitValue DebugSetUnitValue::unit_value() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetUnitValue.unit_value)
  return _internal_unit_value();
}
inline void DebugSetUnitValue::_internal_set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value) {
  assert(::SC2APIProtocol::DebugSetUnitValue_UnitValue_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  unit_value_ = value;
}
inline void DebugSetUnitValue::set_unit_value(::SC2APIProtocol::DebugSetUnitValue_UnitValue value) {
  _internal_set_unit_value(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetUnitValue.unit_value)
}

// optional float value = 2;
inline bool DebugSetUnitValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DebugSetUnitValue::has_value() const {
  return _internal_has_value();
}
inline void DebugSetUnitValue::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float DebugSetUnitValue::_internal_value() const {
  return value_;
}
inline float DebugSetUnitValue::value() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetUnitValue.value)
  return _internal_value();
}
inline void DebugSetUnitValue::_internal_set_value(float value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void DebugSetUnitValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetUnitValue.value)
}

// optional uint64 unit_tag = 3;
inline bool DebugSetUnitValue::_internal_has_unit_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugSetUnitValue::has_unit_tag() const {
  return _internal_has_unit_tag();
}
inline void DebugSetUnitValue::clear_unit_tag() {
  unit_tag_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DebugSetUnitValue::_internal_unit_tag() const {
  return unit_tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DebugSetUnitValue::unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DebugSetUnitValue.unit_tag)
  return _internal_unit_tag();
}
inline void DebugSetUnitValue::_internal_set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  unit_tag_ = value;
}
inline void DebugSetUnitValue::set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_unit_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DebugSetUnitValue.unit_tag)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SC2APIProtocol::DebugTestProcess_Test> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugTestProcess_Test>() {
  return ::SC2APIProtocol::DebugTestProcess_Test_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::DebugEndGame_EndResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugEndGame_EndResult>() {
  return ::SC2APIProtocol::DebugEndGame_EndResult_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::DebugSetUnitValue_UnitValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugSetUnitValue_UnitValue>() {
  return ::SC2APIProtocol::DebugSetUnitValue_UnitValue_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::DebugGameState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::DebugGameState>() {
  return ::SC2APIProtocol::DebugGameState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdebug_2eproto
