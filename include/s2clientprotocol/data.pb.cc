// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/data.proto

#include "s2clientprotocol/data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fdata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DamageBonus_s2clientprotocol_2fdata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fdata_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Weapon_s2clientprotocol_2fdata_2eproto;
namespace SC2APIProtocol {
class AbilityDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AbilityData> _instance;
} _AbilityData_default_instance_;
class DamageBonusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DamageBonus> _instance;
} _DamageBonus_default_instance_;
class WeaponDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Weapon> _instance;
} _Weapon_default_instance_;
class UnitTypeDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UnitTypeData> _instance;
} _UnitTypeData_default_instance_;
class UpgradeDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UpgradeData> _instance;
} _UpgradeData_default_instance_;
class BuffDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BuffData> _instance;
} _BuffData_default_instance_;
class EffectDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EffectData> _instance;
} _EffectData_default_instance_;
}  // namespace SC2APIProtocol
static void InitDefaultsscc_info_AbilityData_s2clientprotocol_2fdata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_AbilityData_default_instance_;
    new (ptr) ::SC2APIProtocol::AbilityData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::AbilityData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AbilityData_s2clientprotocol_2fdata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AbilityData_s2clientprotocol_2fdata_2eproto}, {}};

static void InitDefaultsscc_info_BuffData_s2clientprotocol_2fdata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_BuffData_default_instance_;
    new (ptr) ::SC2APIProtocol::BuffData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::BuffData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BuffData_s2clientprotocol_2fdata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BuffData_s2clientprotocol_2fdata_2eproto}, {}};

static void InitDefaultsscc_info_DamageBonus_s2clientprotocol_2fdata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_DamageBonus_default_instance_;
    new (ptr) ::SC2APIProtocol::DamageBonus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::DamageBonus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DamageBonus_s2clientprotocol_2fdata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_DamageBonus_s2clientprotocol_2fdata_2eproto}, {}};

static void InitDefaultsscc_info_EffectData_s2clientprotocol_2fdata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_EffectData_default_instance_;
    new (ptr) ::SC2APIProtocol::EffectData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::EffectData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EffectData_s2clientprotocol_2fdata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EffectData_s2clientprotocol_2fdata_2eproto}, {}};

static void InitDefaultsscc_info_UnitTypeData_s2clientprotocol_2fdata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_UnitTypeData_default_instance_;
    new (ptr) ::SC2APIProtocol::UnitTypeData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::UnitTypeData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UnitTypeData_s2clientprotocol_2fdata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_UnitTypeData_s2clientprotocol_2fdata_2eproto}, {
      &scc_info_Weapon_s2clientprotocol_2fdata_2eproto.base,}};

static void InitDefaultsscc_info_UpgradeData_s2clientprotocol_2fdata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_UpgradeData_default_instance_;
    new (ptr) ::SC2APIProtocol::UpgradeData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::UpgradeData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_UpgradeData_s2clientprotocol_2fdata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_UpgradeData_s2clientprotocol_2fdata_2eproto}, {}};

static void InitDefaultsscc_info_Weapon_s2clientprotocol_2fdata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_Weapon_default_instance_;
    new (ptr) ::SC2APIProtocol::Weapon();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::Weapon::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Weapon_s2clientprotocol_2fdata_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Weapon_s2clientprotocol_2fdata_2eproto}, {
      &scc_info_DamageBonus_s2clientprotocol_2fdata_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_s2clientprotocol_2fdata_2eproto[7];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_s2clientprotocol_2fdata_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_s2clientprotocol_2fdata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, link_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, link_index_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, button_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, friendly_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, hotkey_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, remaps_to_ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, available_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, target_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, allow_minimap_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, allow_autocast_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, is_building_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, footprint_radius_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, is_instant_placement_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::AbilityData, cast_range_),
  4,
  0,
  5,
  1,
  2,
  3,
  6,
  7,
  14,
  8,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, attribute_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::DamageBonus, bonus_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, type_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, damage_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, damage_bonus_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, attacks_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Weapon, speed_),
  4,
  0,
  ~0u,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, unit_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, available_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, cargo_size_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, mineral_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, vespene_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, food_required_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, food_provided_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, race_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, build_time_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, has_vespene_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, has_minerals_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, sight_range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, tech_alias_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, unit_alias_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, tech_requirement_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, require_attached_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, attributes_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, movement_speed_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, armor_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitTypeData, weapons_),
  1,
  0,
  10,
  2,
  5,
  6,
  7,
  15,
  8,
  9,
  14,
  11,
  12,
  18,
  ~0u,
  16,
  17,
  13,
  ~0u,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, upgrade_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, mineral_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, vespene_cost_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, research_time_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UpgradeData, ability_id_),
  1,
  0,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, buff_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::BuffData, name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, effect_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, friendly_name_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::EffectData, radius_),
  2,
  0,
  1,
  3,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 20, sizeof(::SC2APIProtocol::AbilityData)},
  { 35, 42, sizeof(::SC2APIProtocol::DamageBonus)},
  { 44, 55, sizeof(::SC2APIProtocol::Weapon)},
  { 61, 88, sizeof(::SC2APIProtocol::UnitTypeData)},
  { 110, 121, sizeof(::SC2APIProtocol::UpgradeData)},
  { 127, 134, sizeof(::SC2APIProtocol::BuffData)},
  { 136, 145, sizeof(::SC2APIProtocol::EffectData)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_AbilityData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_DamageBonus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_Weapon_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_UnitTypeData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_UpgradeData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_BuffData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_EffectData_default_instance_),
};

const char descriptor_table_protodef_s2clientprotocol_2fdata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033s2clientprotocol/data.proto\022\016SC2APIPro"
  "tocol\032\035s2clientprotocol/common.proto\"\304\003\n"
  "\013AbilityData\022\022\n\nability_id\030\001 \001(\r\022\021\n\tlink"
  "_name\030\002 \001(\t\022\022\n\nlink_index\030\003 \001(\r\022\023\n\013butto"
  "n_name\030\004 \001(\t\022\025\n\rfriendly_name\030\005 \001(\t\022\016\n\006h"
  "otkey\030\006 \001(\t\022\034\n\024remaps_to_ability_id\030\007 \001("
  "\r\022\021\n\tavailable\030\010 \001(\010\0222\n\006target\030\t \001(\0162\".S"
  "C2APIProtocol.AbilityData.Target\022\025\n\rallo"
  "w_minimap\030\n \001(\010\022\026\n\016allow_autocast\030\013 \001(\010\022"
  "\023\n\013is_building\030\014 \001(\010\022\030\n\020footprint_radius"
  "\030\r \001(\002\022\034\n\024is_instant_placement\030\016 \001(\010\022\022\n\n"
  "cast_range\030\017 \001(\002\"I\n\006Target\022\010\n\004None\020\001\022\t\n\005"
  "Point\020\002\022\010\n\004Unit\020\003\022\017\n\013PointOrUnit\020\004\022\017\n\013Po"
  "intOrNone\020\005\"J\n\013DamageBonus\022,\n\tattribute\030"
  "\001 \001(\0162\031.SC2APIProtocol.Attribute\022\r\n\005bonu"
  "s\030\002 \001(\002\"\327\001\n\006Weapon\022/\n\004type\030\001 \001(\0162!.SC2AP"
  "IProtocol.Weapon.TargetType\022\016\n\006damage\030\002 "
  "\001(\002\0221\n\014damage_bonus\030\003 \003(\0132\033.SC2APIProtoc"
  "ol.DamageBonus\022\017\n\007attacks\030\004 \001(\r\022\r\n\005range"
  "\030\005 \001(\002\022\r\n\005speed\030\006 \001(\002\"*\n\nTargetType\022\n\n\006G"
  "round\020\001\022\007\n\003Air\020\002\022\007\n\003Any\020\003\"\225\004\n\014UnitTypeDa"
  "ta\022\017\n\007unit_id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022\021\n\tava"
  "ilable\030\003 \001(\010\022\022\n\ncargo_size\030\004 \001(\r\022\024\n\014mine"
  "ral_cost\030\014 \001(\r\022\024\n\014vespene_cost\030\r \001(\r\022\025\n\r"
  "food_required\030\016 \001(\002\022\025\n\rfood_provided\030\022 \001"
  "(\002\022\022\n\nability_id\030\017 \001(\r\022\"\n\004race\030\020 \001(\0162\024.S"
  "C2APIProtocol.Race\022\022\n\nbuild_time\030\021 \001(\002\022\023"
  "\n\013has_vespene\030\023 \001(\010\022\024\n\014has_minerals\030\024 \001("
  "\010\022\023\n\013sight_range\030\031 \001(\002\022\022\n\ntech_alias\030\025 \003"
  "(\r\022\022\n\nunit_alias\030\026 \001(\r\022\030\n\020tech_requireme"
  "nt\030\027 \001(\r\022\030\n\020require_attached\030\030 \001(\010\022-\n\nat"
  "tributes\030\010 \003(\0162\031.SC2APIProtocol.Attribut"
  "e\022\026\n\016movement_speed\030\t \001(\002\022\r\n\005armor\030\n \001(\002"
  "\022\'\n\007weapons\030\013 \003(\0132\026.SC2APIProtocol.Weapo"
  "n\"\206\001\n\013UpgradeData\022\022\n\nupgrade_id\030\001 \001(\r\022\014\n"
  "\004name\030\002 \001(\t\022\024\n\014mineral_cost\030\003 \001(\r\022\024\n\014ves"
  "pene_cost\030\004 \001(\r\022\025\n\rresearch_time\030\005 \001(\002\022\022"
  "\n\nability_id\030\006 \001(\r\")\n\010BuffData\022\017\n\007buff_i"
  "d\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\"T\n\nEffectData\022\021\n\te"
  "ffect_id\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022\025\n\rfriendly"
  "_name\030\003 \001(\t\022\016\n\006radius\030\004 \001(\002*\236\001\n\tAttribut"
  "e\022\t\n\005Light\020\001\022\013\n\007Armored\020\002\022\016\n\nBiological\020"
  "\003\022\016\n\nMechanical\020\004\022\013\n\007Robotic\020\005\022\013\n\007Psioni"
  "c\020\006\022\013\n\007Massive\020\007\022\r\n\tStructure\020\010\022\t\n\005Hover"
  "\020\t\022\n\n\006Heroic\020\n\022\014\n\010Summoned\020\013"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_s2clientprotocol_2fdata_2eproto_deps[1] = {
  &::descriptor_table_s2clientprotocol_2fcommon_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_s2clientprotocol_2fdata_2eproto_sccs[7] = {
  &scc_info_AbilityData_s2clientprotocol_2fdata_2eproto.base,
  &scc_info_BuffData_s2clientprotocol_2fdata_2eproto.base,
  &scc_info_DamageBonus_s2clientprotocol_2fdata_2eproto.base,
  &scc_info_EffectData_s2clientprotocol_2fdata_2eproto.base,
  &scc_info_UnitTypeData_s2clientprotocol_2fdata_2eproto.base,
  &scc_info_UpgradeData_s2clientprotocol_2fdata_2eproto.base,
  &scc_info_Weapon_s2clientprotocol_2fdata_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_s2clientprotocol_2fdata_2eproto_once;
static bool descriptor_table_s2clientprotocol_2fdata_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fdata_2eproto = {
  &descriptor_table_s2clientprotocol_2fdata_2eproto_initialized, descriptor_table_protodef_s2clientprotocol_2fdata_2eproto, "s2clientprotocol/data.proto", 1788,
  &descriptor_table_s2clientprotocol_2fdata_2eproto_once, descriptor_table_s2clientprotocol_2fdata_2eproto_sccs, descriptor_table_s2clientprotocol_2fdata_2eproto_deps, 7, 1,
  schemas, file_default_instances, TableStruct_s2clientprotocol_2fdata_2eproto::offsets,
  file_level_metadata_s2clientprotocol_2fdata_2eproto, 7, file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto, file_level_service_descriptors_s2clientprotocol_2fdata_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_s2clientprotocol_2fdata_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_s2clientprotocol_2fdata_2eproto)), true);
namespace SC2APIProtocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbilityData_Target_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fdata_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[0];
}
bool AbilityData_Target_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AbilityData_Target AbilityData::None;
constexpr AbilityData_Target AbilityData::Point;
constexpr AbilityData_Target AbilityData::Unit;
constexpr AbilityData_Target AbilityData::PointOrUnit;
constexpr AbilityData_Target AbilityData::PointOrNone;
constexpr AbilityData_Target AbilityData::Target_MIN;
constexpr AbilityData_Target AbilityData::Target_MAX;
constexpr int AbilityData::Target_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Weapon_TargetType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fdata_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[1];
}
bool Weapon_TargetType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Weapon_TargetType Weapon::Ground;
constexpr Weapon_TargetType Weapon::Air;
constexpr Weapon_TargetType Weapon::Any;
constexpr Weapon_TargetType Weapon::TargetType_MIN;
constexpr Weapon_TargetType Weapon::TargetType_MAX;
constexpr int Weapon::TargetType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Attribute_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fdata_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fdata_2eproto[2];
}
bool Attribute_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void AbilityData::InitAsDefaultInstance() {
}
class AbilityData::_Internal {
 public:
  using HasBits = decltype(std::declval<AbilityData>()._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_link_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_button_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hotkey(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remaps_to_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_available(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_target(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_allow_minimap(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_allow_autocast(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_building(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_footprint_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_instant_placement(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_cast_range(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

AbilityData::AbilityData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.AbilityData)
}
AbilityData::AbilityData(const AbilityData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_link_name()) {
    link_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.link_name_);
  }
  button_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_button_name()) {
    button_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.button_name_);
  }
  friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_friendly_name()) {
    friendly_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.friendly_name_);
  }
  hotkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hotkey()) {
    hotkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hotkey_);
  }
  ::memcpy(&ability_id_, &from.ability_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_) -
    reinterpret_cast<char*>(&ability_id_)) + sizeof(target_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.AbilityData)
}

void AbilityData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AbilityData_s2clientprotocol_2fdata_2eproto.base);
  link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  button_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hotkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&ability_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cast_range_) -
      reinterpret_cast<char*>(&ability_id_)) + sizeof(cast_range_));
  target_ = 1;
}

AbilityData::~AbilityData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.AbilityData)
  SharedDtor();
}

void AbilityData::SharedDtor() {
  link_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  button_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  friendly_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hotkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AbilityData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AbilityData& AbilityData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AbilityData_s2clientprotocol_2fdata_2eproto.base);
  return *internal_default_instance();
}


void AbilityData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.AbilityData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      link_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      button_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      friendly_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      hotkey_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&available_) -
        reinterpret_cast<char*>(&ability_id_)) + sizeof(available_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&allow_minimap_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cast_range_) -
        reinterpret_cast<char*>(&allow_minimap_)) + sizeof(cast_range_));
    target_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* AbilityData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string link_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_link_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.AbilityData.link_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 link_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_link_index(&has_bits);
          link_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string button_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_button_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.AbilityData.button_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string friendly_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_friendly_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.AbilityData.friendly_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string hotkey = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_hotkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.AbilityData.hotkey");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 remaps_to_ability_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_remaps_to_ability_id(&has_bits);
          remaps_to_ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool available = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_available(&has_bits);
          available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.AbilityData.Target target = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::AbilityData_Target_IsValid(val))) {
            _internal_set_target(static_cast<::SC2APIProtocol::AbilityData_Target>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool allow_minimap = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_allow_minimap(&has_bits);
          allow_minimap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool allow_autocast = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_allow_autocast(&has_bits);
          allow_autocast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_building = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_is_building(&has_bits);
          is_building_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float footprint_radius = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 109)) {
          _Internal::set_has_footprint_radius(&has_bits);
          footprint_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool is_instant_placement = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_is_instant_placement(&has_bits);
          is_instant_placement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float cast_range = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_cast_range(&has_bits);
          cast_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AbilityData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.AbilityData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 ability_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ability_id(), target);
  }

  // optional string link_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_link_name().data(), static_cast<int>(this->_internal_link_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.link_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_link_name(), target);
  }

  // optional uint32 link_index = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_link_index(), target);
  }

  // optional string button_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_button_name().data(), static_cast<int>(this->_internal_button_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.button_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_button_name(), target);
  }

  // optional string friendly_name = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friendly_name().data(), static_cast<int>(this->_internal_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.friendly_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_friendly_name(), target);
  }

  // optional string hotkey = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hotkey().data(), static_cast<int>(this->_internal_hotkey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.AbilityData.hotkey");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_hotkey(), target);
  }

  // optional uint32 remaps_to_ability_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_remaps_to_ability_id(), target);
  }

  // optional bool available = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_available(), target);
  }

  // optional .SC2APIProtocol.AbilityData.Target target = 9;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_target(), target);
  }

  // optional bool allow_minimap = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_allow_minimap(), target);
  }

  // optional bool allow_autocast = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_allow_autocast(), target);
  }

  // optional bool is_building = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_building(), target);
  }

  // optional float footprint_radius = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_footprint_radius(), target);
  }

  // optional bool is_instant_placement = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_is_instant_placement(), target);
  }

  // optional float cast_range = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_cast_range(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.AbilityData)
  return target;
}

size_t AbilityData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.AbilityData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string link_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_link_name());
    }

    // optional string button_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_button_name());
    }

    // optional string friendly_name = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friendly_name());
    }

    // optional string hotkey = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hotkey());
    }

    // optional uint32 ability_id = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ability_id());
    }

    // optional uint32 link_index = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_link_index());
    }

    // optional uint32 remaps_to_ability_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_remaps_to_ability_id());
    }

    // optional bool available = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool allow_minimap = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool allow_autocast = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_building = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional float footprint_radius = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional bool is_instant_placement = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional float cast_range = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.AbilityData.Target target = 9;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_target());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AbilityData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.AbilityData)
  GOOGLE_DCHECK_NE(&from, this);
  const AbilityData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AbilityData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.AbilityData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.AbilityData)
    MergeFrom(*source);
  }
}

void AbilityData::MergeFrom(const AbilityData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.AbilityData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      link_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.link_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      button_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.button_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      friendly_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.friendly_name_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      hotkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.hotkey_);
    }
    if (cached_has_bits & 0x00000010u) {
      ability_id_ = from.ability_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      link_index_ = from.link_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      remaps_to_ability_id_ = from.remaps_to_ability_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      available_ = from.available_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      allow_minimap_ = from.allow_minimap_;
    }
    if (cached_has_bits & 0x00000200u) {
      allow_autocast_ = from.allow_autocast_;
    }
    if (cached_has_bits & 0x00000400u) {
      is_building_ = from.is_building_;
    }
    if (cached_has_bits & 0x00000800u) {
      footprint_radius_ = from.footprint_radius_;
    }
    if (cached_has_bits & 0x00001000u) {
      is_instant_placement_ = from.is_instant_placement_;
    }
    if (cached_has_bits & 0x00002000u) {
      cast_range_ = from.cast_range_;
    }
    if (cached_has_bits & 0x00004000u) {
      target_ = from.target_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AbilityData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.AbilityData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AbilityData::CopyFrom(const AbilityData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.AbilityData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbilityData::IsInitialized() const {
  return true;
}

void AbilityData::InternalSwap(AbilityData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  link_name_.Swap(&other->link_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  button_name_.Swap(&other->button_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  friendly_name_.Swap(&other->friendly_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  hotkey_.Swap(&other->hotkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(ability_id_, other->ability_id_);
  swap(link_index_, other->link_index_);
  swap(remaps_to_ability_id_, other->remaps_to_ability_id_);
  swap(available_, other->available_);
  swap(allow_minimap_, other->allow_minimap_);
  swap(allow_autocast_, other->allow_autocast_);
  swap(is_building_, other->is_building_);
  swap(footprint_radius_, other->footprint_radius_);
  swap(is_instant_placement_, other->is_instant_placement_);
  swap(cast_range_, other->cast_range_);
  swap(target_, other->target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbilityData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void DamageBonus::InitAsDefaultInstance() {
}
class DamageBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<DamageBonus>()._has_bits_);
  static void set_has_attribute(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bonus(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DamageBonus::DamageBonus()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.DamageBonus)
}
DamageBonus::DamageBonus(const DamageBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bonus_, &from.bonus_,
    static_cast<size_t>(reinterpret_cast<char*>(&attribute_) -
    reinterpret_cast<char*>(&bonus_)) + sizeof(attribute_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.DamageBonus)
}

void DamageBonus::SharedCtor() {
  bonus_ = 0;
  attribute_ = 1;
}

DamageBonus::~DamageBonus() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.DamageBonus)
  SharedDtor();
}

void DamageBonus::SharedDtor() {
}

void DamageBonus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DamageBonus& DamageBonus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DamageBonus_s2clientprotocol_2fdata_2eproto.base);
  return *internal_default_instance();
}


void DamageBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.DamageBonus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    bonus_ = 0;
    attribute_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* DamageBonus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Attribute attribute = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Attribute_IsValid(val))) {
            _internal_set_attribute(static_cast<::SC2APIProtocol::Attribute>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float bonus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_bonus(&has_bits);
          bonus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DamageBonus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.DamageBonus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Attribute attribute = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_attribute(), target);
  }

  // optional float bonus = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_bonus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.DamageBonus)
  return target;
}

size_t DamageBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.DamageBonus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float bonus = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.Attribute attribute = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_attribute());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DamageBonus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.DamageBonus)
  GOOGLE_DCHECK_NE(&from, this);
  const DamageBonus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DamageBonus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.DamageBonus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.DamageBonus)
    MergeFrom(*source);
  }
}

void DamageBonus::MergeFrom(const DamageBonus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.DamageBonus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      bonus_ = from.bonus_;
    }
    if (cached_has_bits & 0x00000002u) {
      attribute_ = from.attribute_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DamageBonus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.DamageBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DamageBonus::CopyFrom(const DamageBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.DamageBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DamageBonus::IsInitialized() const {
  return true;
}

void DamageBonus::InternalSwap(DamageBonus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bonus_, other->bonus_);
  swap(attribute_, other->attribute_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DamageBonus::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Weapon::InitAsDefaultInstance() {
}
class Weapon::_Internal {
 public:
  using HasBits = decltype(std::declval<Weapon>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_damage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attacks(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_range(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Weapon::Weapon()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.Weapon)
}
Weapon::Weapon(const Weapon& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      damage_bonus_(from.damage_bonus_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&damage_, &from.damage_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&damage_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Weapon)
}

void Weapon::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Weapon_s2clientprotocol_2fdata_2eproto.base);
  ::memset(&damage_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_) -
      reinterpret_cast<char*>(&damage_)) + sizeof(speed_));
  type_ = 1;
}

Weapon::~Weapon() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Weapon)
  SharedDtor();
}

void Weapon::SharedDtor() {
}

void Weapon::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Weapon& Weapon::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Weapon_s2clientprotocol_2fdata_2eproto.base);
  return *internal_default_instance();
}


void Weapon::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Weapon)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  damage_bonus_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&damage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&damage_)) + sizeof(speed_));
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Weapon::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Weapon.TargetType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Weapon_TargetType_IsValid(val))) {
            _internal_set_type(static_cast<::SC2APIProtocol::Weapon_TargetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float damage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_damage(&has_bits);
          damage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_damage_bonus(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 attacks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_attacks(&has_bits);
          attacks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float range = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_range(&has_bits);
          range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_speed(&has_bits);
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Weapon::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Weapon)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Weapon.TargetType type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float damage = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_damage(), target);
  }

  // repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_damage_bonus_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_damage_bonus(i), target, stream);
  }

  // optional uint32 attacks = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_attacks(), target);
  }

  // optional float range = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_range(), target);
  }

  // optional float speed = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Weapon)
  return target;
}

size_t Weapon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Weapon)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
  total_size += 1UL * this->_internal_damage_bonus_size();
  for (const auto& msg : this->damage_bonus_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float damage = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional uint32 attacks = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_attacks());
    }

    // optional float range = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float speed = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.Weapon.TargetType type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Weapon::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.Weapon)
  GOOGLE_DCHECK_NE(&from, this);
  const Weapon* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Weapon>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.Weapon)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.Weapon)
    MergeFrom(*source);
  }
}

void Weapon::MergeFrom(const Weapon& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Weapon)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  damage_bonus_.MergeFrom(from.damage_bonus_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      damage_ = from.damage_;
    }
    if (cached_has_bits & 0x00000002u) {
      attacks_ = from.attacks_;
    }
    if (cached_has_bits & 0x00000004u) {
      range_ = from.range_;
    }
    if (cached_has_bits & 0x00000008u) {
      speed_ = from.speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Weapon::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.Weapon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Weapon::CopyFrom(const Weapon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Weapon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Weapon::IsInitialized() const {
  return true;
}

void Weapon::InternalSwap(Weapon* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  damage_bonus_.InternalSwap(&other->damage_bonus_);
  swap(damage_, other->damage_);
  swap(attacks_, other->attacks_);
  swap(range_, other->range_);
  swap(speed_, other->speed_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Weapon::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UnitTypeData::InitAsDefaultInstance() {
}
class UnitTypeData::_Internal {
 public:
  using HasBits = decltype(std::declval<UnitTypeData>()._has_bits_);
  static void set_has_unit_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_available(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_cargo_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mineral_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_vespene_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_food_required(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_food_provided(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_race(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_build_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_has_vespene(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_has_minerals(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_sight_range(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_unit_alias(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_tech_requirement(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_require_attached(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_movement_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_armor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UnitTypeData::UnitTypeData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.UnitTypeData)
}
UnitTypeData::UnitTypeData(const UnitTypeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      attributes_(from.attributes_),
      weapons_(from.weapons_),
      tech_alias_(from.tech_alias_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&unit_id_, &from.unit_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&sight_range_) -
    reinterpret_cast<char*>(&unit_id_)) + sizeof(sight_range_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.UnitTypeData)
}

void UnitTypeData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UnitTypeData_s2clientprotocol_2fdata_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&unit_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sight_range_) -
      reinterpret_cast<char*>(&unit_id_)) + sizeof(sight_range_));
}

UnitTypeData::~UnitTypeData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.UnitTypeData)
  SharedDtor();
}

void UnitTypeData::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UnitTypeData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UnitTypeData& UnitTypeData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UnitTypeData_s2clientprotocol_2fdata_2eproto.base);
  return *internal_default_instance();
}


void UnitTypeData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.UnitTypeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  attributes_.Clear();
  weapons_.Clear();
  tech_alias_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&unit_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&food_required_) -
        reinterpret_cast<char*>(&unit_id_)) + sizeof(food_required_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&food_provided_) -
        reinterpret_cast<char*>(&ability_id_)) + sizeof(food_provided_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&unit_alias_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sight_range_) -
        reinterpret_cast<char*>(&unit_alias_)) + sizeof(sight_range_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* UnitTypeData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 unit_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_unit_id(&has_bits);
          unit_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.UnitTypeData.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool available = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_available(&has_bits);
          available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cargo_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_cargo_size(&has_bits);
          cargo_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Attribute attributes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Attribute_IsValid(val))) {
              _internal_add_attributes(static_cast<::SC2APIProtocol::Attribute>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_attributes(), ptr, ctx, ::SC2APIProtocol::Attribute_IsValid, &_internal_metadata_, 8);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float movement_speed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_movement_speed(&has_bits);
          movement_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float armor = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_armor(&has_bits);
          armor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Weapon weapons = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_weapons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 mineral_cost = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_mineral_cost(&has_bits);
          mineral_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 vespene_cost = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_vespene_cost(&has_bits);
          vespene_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float food_required = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          _Internal::set_has_food_required(&has_bits);
          food_required_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 ability_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_ability_id(&has_bits);
          ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Race race = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Race_IsValid(val))) {
            _internal_set_race(static_cast<::SC2APIProtocol::Race>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float build_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_build_time(&has_bits);
          build_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float food_provided = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_food_provided(&has_bits);
          food_provided_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool has_vespene = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_has_vespene(&has_bits);
          has_vespene_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool has_minerals = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_has_minerals(&has_bits);
          has_minerals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 tech_alias = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_tech_alias(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_tech_alias(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 unit_alias = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_unit_alias(&has_bits);
          unit_alias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tech_requirement = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_tech_requirement(&has_bits);
          tech_requirement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool require_attached = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_require_attached(&has_bits);
          require_attached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float sight_range = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 205)) {
          _Internal::set_has_sight_range(&has_bits);
          sight_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UnitTypeData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.UnitTypeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 unit_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_unit_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.UnitTypeData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional bool available = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_available(), target);
  }

  // optional uint32 cargo_size = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cargo_size(), target);
  }

  // repeated .SC2APIProtocol.Attribute attributes = 8;
  for (int i = 0, n = this->_internal_attributes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        8, this->_internal_attributes(i), target);
  }

  // optional float movement_speed = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_movement_speed(), target);
  }

  // optional float armor = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_armor(), target);
  }

  // repeated .SC2APIProtocol.Weapon weapons = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_weapons_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_weapons(i), target, stream);
  }

  // optional uint32 mineral_cost = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_mineral_cost(), target);
  }

  // optional uint32 vespene_cost = 13;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_vespene_cost(), target);
  }

  // optional float food_required = 14;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_food_required(), target);
  }

  // optional uint32 ability_id = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->_internal_ability_id(), target);
  }

  // optional .SC2APIProtocol.Race race = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      16, this->_internal_race(), target);
  }

  // optional float build_time = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_build_time(), target);
  }

  // optional float food_provided = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_food_provided(), target);
  }

  // optional bool has_vespene = 19;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_has_vespene(), target);
  }

  // optional bool has_minerals = 20;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_has_minerals(), target);
  }

  // repeated uint32 tech_alias = 21;
  for (int i = 0, n = this->_internal_tech_alias_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(21, this->_internal_tech_alias(i), target);
  }

  // optional uint32 unit_alias = 22;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(22, this->_internal_unit_alias(), target);
  }

  // optional uint32 tech_requirement = 23;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(23, this->_internal_tech_requirement(), target);
  }

  // optional bool require_attached = 24;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_require_attached(), target);
  }

  // optional float sight_range = 25;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_sight_range(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.UnitTypeData)
  return target;
}

size_t UnitTypeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.UnitTypeData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Attribute attributes = 8;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_attributes_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_attributes(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .SC2APIProtocol.Weapon weapons = 11;
  total_size += 1UL * this->_internal_weapons_size();
  for (const auto& msg : this->weapons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 tech_alias = 21;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->tech_alias_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_tech_alias_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 unit_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_unit_id());
    }

    // optional uint32 cargo_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_cargo_size());
    }

    // optional float movement_speed = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float armor = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 mineral_cost = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_mineral_cost());
    }

    // optional uint32 vespene_cost = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_vespene_cost());
    }

    // optional float food_required = 14;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 ability_id = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ability_id());
    }

    // optional .SC2APIProtocol.Race race = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_race());
    }

    // optional bool available = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool has_vespene = 19;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool has_minerals = 20;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool require_attached = 24;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional float build_time = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional float food_provided = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 unit_alias = 22;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_unit_alias());
    }

    // optional uint32 tech_requirement = 23;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_tech_requirement());
    }

    // optional float sight_range = 25;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnitTypeData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.UnitTypeData)
  GOOGLE_DCHECK_NE(&from, this);
  const UnitTypeData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UnitTypeData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.UnitTypeData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.UnitTypeData)
    MergeFrom(*source);
  }
}

void UnitTypeData::MergeFrom(const UnitTypeData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.UnitTypeData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  attributes_.MergeFrom(from.attributes_);
  weapons_.MergeFrom(from.weapons_);
  tech_alias_.MergeFrom(from.tech_alias_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      unit_id_ = from.unit_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      cargo_size_ = from.cargo_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      movement_speed_ = from.movement_speed_;
    }
    if (cached_has_bits & 0x00000010u) {
      armor_ = from.armor_;
    }
    if (cached_has_bits & 0x00000020u) {
      mineral_cost_ = from.mineral_cost_;
    }
    if (cached_has_bits & 0x00000040u) {
      vespene_cost_ = from.vespene_cost_;
    }
    if (cached_has_bits & 0x00000080u) {
      food_required_ = from.food_required_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      ability_id_ = from.ability_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      race_ = from.race_;
    }
    if (cached_has_bits & 0x00000400u) {
      available_ = from.available_;
    }
    if (cached_has_bits & 0x00000800u) {
      has_vespene_ = from.has_vespene_;
    }
    if (cached_has_bits & 0x00001000u) {
      has_minerals_ = from.has_minerals_;
    }
    if (cached_has_bits & 0x00002000u) {
      require_attached_ = from.require_attached_;
    }
    if (cached_has_bits & 0x00004000u) {
      build_time_ = from.build_time_;
    }
    if (cached_has_bits & 0x00008000u) {
      food_provided_ = from.food_provided_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      unit_alias_ = from.unit_alias_;
    }
    if (cached_has_bits & 0x00020000u) {
      tech_requirement_ = from.tech_requirement_;
    }
    if (cached_has_bits & 0x00040000u) {
      sight_range_ = from.sight_range_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UnitTypeData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.UnitTypeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnitTypeData::CopyFrom(const UnitTypeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.UnitTypeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnitTypeData::IsInitialized() const {
  return true;
}

void UnitTypeData::InternalSwap(UnitTypeData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  attributes_.InternalSwap(&other->attributes_);
  weapons_.InternalSwap(&other->weapons_);
  tech_alias_.InternalSwap(&other->tech_alias_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(unit_id_, other->unit_id_);
  swap(cargo_size_, other->cargo_size_);
  swap(movement_speed_, other->movement_speed_);
  swap(armor_, other->armor_);
  swap(mineral_cost_, other->mineral_cost_);
  swap(vespene_cost_, other->vespene_cost_);
  swap(food_required_, other->food_required_);
  swap(ability_id_, other->ability_id_);
  swap(race_, other->race_);
  swap(available_, other->available_);
  swap(has_vespene_, other->has_vespene_);
  swap(has_minerals_, other->has_minerals_);
  swap(require_attached_, other->require_attached_);
  swap(build_time_, other->build_time_);
  swap(food_provided_, other->food_provided_);
  swap(unit_alias_, other->unit_alias_);
  swap(tech_requirement_, other->tech_requirement_);
  swap(sight_range_, other->sight_range_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UnitTypeData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UpgradeData::InitAsDefaultInstance() {
}
class UpgradeData::_Internal {
 public:
  using HasBits = decltype(std::declval<UpgradeData>()._has_bits_);
  static void set_has_upgrade_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mineral_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vespene_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_research_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

UpgradeData::UpgradeData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.UpgradeData)
}
UpgradeData::UpgradeData(const UpgradeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&upgrade_id_, &from.upgrade_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&ability_id_) -
    reinterpret_cast<char*>(&upgrade_id_)) + sizeof(ability_id_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.UpgradeData)
}

void UpgradeData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UpgradeData_s2clientprotocol_2fdata_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&upgrade_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ability_id_) -
      reinterpret_cast<char*>(&upgrade_id_)) + sizeof(ability_id_));
}

UpgradeData::~UpgradeData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.UpgradeData)
  SharedDtor();
}

void UpgradeData::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UpgradeData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UpgradeData& UpgradeData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UpgradeData_s2clientprotocol_2fdata_2eproto.base);
  return *internal_default_instance();
}


void UpgradeData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.UpgradeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&upgrade_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ability_id_) -
        reinterpret_cast<char*>(&upgrade_id_)) + sizeof(ability_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* UpgradeData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 upgrade_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_upgrade_id(&has_bits);
          upgrade_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.UpgradeData.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mineral_cost = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_mineral_cost(&has_bits);
          mineral_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 vespene_cost = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_vespene_cost(&has_bits);
          vespene_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float research_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_research_time(&has_bits);
          research_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 ability_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ability_id(&has_bits);
          ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UpgradeData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.UpgradeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 upgrade_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_upgrade_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.UpgradeData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional uint32 mineral_cost = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mineral_cost(), target);
  }

  // optional uint32 vespene_cost = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_vespene_cost(), target);
  }

  // optional float research_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_research_time(), target);
  }

  // optional uint32 ability_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_ability_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.UpgradeData)
  return target;
}

size_t UpgradeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.UpgradeData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 upgrade_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_upgrade_id());
    }

    // optional uint32 mineral_cost = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_mineral_cost());
    }

    // optional uint32 vespene_cost = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_vespene_cost());
    }

    // optional float research_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 ability_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ability_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpgradeData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.UpgradeData)
  GOOGLE_DCHECK_NE(&from, this);
  const UpgradeData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UpgradeData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.UpgradeData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.UpgradeData)
    MergeFrom(*source);
  }
}

void UpgradeData::MergeFrom(const UpgradeData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.UpgradeData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      upgrade_id_ = from.upgrade_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      mineral_cost_ = from.mineral_cost_;
    }
    if (cached_has_bits & 0x00000008u) {
      vespene_cost_ = from.vespene_cost_;
    }
    if (cached_has_bits & 0x00000010u) {
      research_time_ = from.research_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      ability_id_ = from.ability_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UpgradeData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.UpgradeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpgradeData::CopyFrom(const UpgradeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.UpgradeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeData::IsInitialized() const {
  return true;
}

void UpgradeData::InternalSwap(UpgradeData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(upgrade_id_, other->upgrade_id_);
  swap(mineral_cost_, other->mineral_cost_);
  swap(vespene_cost_, other->vespene_cost_);
  swap(research_time_, other->research_time_);
  swap(ability_id_, other->ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpgradeData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BuffData::InitAsDefaultInstance() {
}
class BuffData::_Internal {
 public:
  using HasBits = decltype(std::declval<BuffData>()._has_bits_);
  static void set_has_buff_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BuffData::BuffData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.BuffData)
}
BuffData::BuffData(const BuffData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  buff_id_ = from.buff_id_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.BuffData)
}

void BuffData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BuffData_s2clientprotocol_2fdata_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  buff_id_ = 0u;
}

BuffData::~BuffData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.BuffData)
  SharedDtor();
}

void BuffData::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BuffData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BuffData& BuffData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BuffData_s2clientprotocol_2fdata_2eproto.base);
  return *internal_default_instance();
}


void BuffData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.BuffData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  buff_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* BuffData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 buff_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_buff_id(&has_bits);
          buff_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.BuffData.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BuffData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.BuffData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 buff_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_buff_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.BuffData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.BuffData)
  return target;
}

size_t BuffData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.BuffData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 buff_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_buff_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BuffData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.BuffData)
  GOOGLE_DCHECK_NE(&from, this);
  const BuffData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BuffData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.BuffData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.BuffData)
    MergeFrom(*source);
  }
}

void BuffData::MergeFrom(const BuffData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.BuffData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      buff_id_ = from.buff_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BuffData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.BuffData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuffData::CopyFrom(const BuffData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.BuffData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuffData::IsInitialized() const {
  return true;
}

void BuffData::InternalSwap(BuffData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(buff_id_, other->buff_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BuffData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void EffectData::InitAsDefaultInstance() {
}
class EffectData::_Internal {
 public:
  using HasBits = decltype(std::declval<EffectData>()._has_bits_);
  static void set_has_effect_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

EffectData::EffectData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.EffectData)
}
EffectData::EffectData(const EffectData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_friendly_name()) {
    friendly_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.friendly_name_);
  }
  ::memcpy(&effect_id_, &from.effect_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&radius_) -
    reinterpret_cast<char*>(&effect_id_)) + sizeof(radius_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.EffectData)
}

void EffectData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EffectData_s2clientprotocol_2fdata_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&effect_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&radius_) -
      reinterpret_cast<char*>(&effect_id_)) + sizeof(radius_));
}

EffectData::~EffectData() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.EffectData)
  SharedDtor();
}

void EffectData::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  friendly_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EffectData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EffectData& EffectData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EffectData_s2clientprotocol_2fdata_2eproto.base);
  return *internal_default_instance();
}


void EffectData::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.EffectData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      friendly_name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&effect_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&radius_) -
        reinterpret_cast<char*>(&effect_id_)) + sizeof(radius_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* EffectData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 effect_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_effect_id(&has_bits);
          effect_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.EffectData.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string friendly_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_friendly_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SC2APIProtocol.EffectData.friendly_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EffectData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.EffectData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 effect_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_effect_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.EffectData.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string friendly_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friendly_name().data(), static_cast<int>(this->_internal_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "SC2APIProtocol.EffectData.friendly_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_friendly_name(), target);
  }

  // optional float radius = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.EffectData)
  return target;
}

size_t EffectData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.EffectData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string friendly_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friendly_name());
    }

    // optional uint32 effect_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_effect_id());
    }

    // optional float radius = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EffectData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.EffectData)
  GOOGLE_DCHECK_NE(&from, this);
  const EffectData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EffectData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.EffectData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.EffectData)
    MergeFrom(*source);
  }
}

void EffectData::MergeFrom(const EffectData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.EffectData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      friendly_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.friendly_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      effect_id_ = from.effect_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      radius_ = from.radius_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EffectData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.EffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EffectData::CopyFrom(const EffectData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.EffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EffectData::IsInitialized() const {
  return true;
}

void EffectData::InternalSwap(EffectData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  friendly_name_.Swap(&other->friendly_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(effect_id_, other->effect_id_);
  swap(radius_, other->radius_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EffectData::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::AbilityData* Arena::CreateMaybeMessage< ::SC2APIProtocol::AbilityData >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::AbilityData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::DamageBonus* Arena::CreateMaybeMessage< ::SC2APIProtocol::DamageBonus >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::DamageBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Weapon* Arena::CreateMaybeMessage< ::SC2APIProtocol::Weapon >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::Weapon >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::UnitTypeData* Arena::CreateMaybeMessage< ::SC2APIProtocol::UnitTypeData >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::UnitTypeData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::UpgradeData* Arena::CreateMaybeMessage< ::SC2APIProtocol::UpgradeData >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::UpgradeData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::BuffData* Arena::CreateMaybeMessage< ::SC2APIProtocol::BuffData >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::BuffData >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::EffectData* Arena::CreateMaybeMessage< ::SC2APIProtocol::EffectData >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::EffectData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
