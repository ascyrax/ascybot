// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/spatial.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fspatial_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fspatial_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fspatial_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_s2clientprotocol_2fspatial_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fspatial_2eproto;
namespace SC2APIProtocol {
class ActionSpatial;
class ActionSpatialDefaultTypeInternal;
extern ActionSpatialDefaultTypeInternal _ActionSpatial_default_instance_;
class ActionSpatialCameraMove;
class ActionSpatialCameraMoveDefaultTypeInternal;
extern ActionSpatialCameraMoveDefaultTypeInternal _ActionSpatialCameraMove_default_instance_;
class ActionSpatialUnitCommand;
class ActionSpatialUnitCommandDefaultTypeInternal;
extern ActionSpatialUnitCommandDefaultTypeInternal _ActionSpatialUnitCommand_default_instance_;
class ActionSpatialUnitSelectionPoint;
class ActionSpatialUnitSelectionPointDefaultTypeInternal;
extern ActionSpatialUnitSelectionPointDefaultTypeInternal _ActionSpatialUnitSelectionPoint_default_instance_;
class ActionSpatialUnitSelectionRect;
class ActionSpatialUnitSelectionRectDefaultTypeInternal;
extern ActionSpatialUnitSelectionRectDefaultTypeInternal _ActionSpatialUnitSelectionRect_default_instance_;
class FeatureLayers;
class FeatureLayersDefaultTypeInternal;
extern FeatureLayersDefaultTypeInternal _FeatureLayers_default_instance_;
class FeatureLayersMinimap;
class FeatureLayersMinimapDefaultTypeInternal;
extern FeatureLayersMinimapDefaultTypeInternal _FeatureLayersMinimap_default_instance_;
class ObservationFeatureLayer;
class ObservationFeatureLayerDefaultTypeInternal;
extern ObservationFeatureLayerDefaultTypeInternal _ObservationFeatureLayer_default_instance_;
class ObservationRender;
class ObservationRenderDefaultTypeInternal;
extern ObservationRenderDefaultTypeInternal _ObservationRender_default_instance_;
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::SC2APIProtocol::ActionSpatial* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatial>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialCameraMove* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialCameraMove>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialUnitCommand* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialUnitCommand>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialUnitSelectionPoint>(Arena*);
template<> ::SC2APIProtocol::ActionSpatialUnitSelectionRect* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionSpatialUnitSelectionRect>(Arena*);
template<> ::SC2APIProtocol::FeatureLayers* Arena::CreateMaybeMessage<::SC2APIProtocol::FeatureLayers>(Arena*);
template<> ::SC2APIProtocol::FeatureLayersMinimap* Arena::CreateMaybeMessage<::SC2APIProtocol::FeatureLayersMinimap>(Arena*);
template<> ::SC2APIProtocol::ObservationFeatureLayer* Arena::CreateMaybeMessage<::SC2APIProtocol::ObservationFeatureLayer>(Arena*);
template<> ::SC2APIProtocol::ObservationRender* Arena::CreateMaybeMessage<::SC2APIProtocol::ObservationRender>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SC2APIProtocol {

enum ActionSpatialUnitSelectionPoint_Type : int {
  ActionSpatialUnitSelectionPoint_Type_Select = 1,
  ActionSpatialUnitSelectionPoint_Type_Toggle = 2,
  ActionSpatialUnitSelectionPoint_Type_AllType = 3,
  ActionSpatialUnitSelectionPoint_Type_AddAllType = 4
};
bool ActionSpatialUnitSelectionPoint_Type_IsValid(int value);
constexpr ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MIN = ActionSpatialUnitSelectionPoint_Type_Select;
constexpr ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint_Type_Type_MAX = ActionSpatialUnitSelectionPoint_Type_AddAllType;
constexpr int ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE = ActionSpatialUnitSelectionPoint_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionSpatialUnitSelectionPoint_Type_descriptor();
template<typename T>
inline const std::string& ActionSpatialUnitSelectionPoint_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionSpatialUnitSelectionPoint_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionSpatialUnitSelectionPoint_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), enum_t_value);
}
inline bool ActionSpatialUnitSelectionPoint_Type_Parse(
    const std::string& name, ActionSpatialUnitSelectionPoint_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionSpatialUnitSelectionPoint_Type>(
    ActionSpatialUnitSelectionPoint_Type_descriptor(), name, value);
}
// ===================================================================

class ObservationFeatureLayer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationFeatureLayer) */ {
 public:
  ObservationFeatureLayer();
  virtual ~ObservationFeatureLayer();

  ObservationFeatureLayer(const ObservationFeatureLayer& from);
  ObservationFeatureLayer(ObservationFeatureLayer&& from) noexcept
    : ObservationFeatureLayer() {
    *this = ::std::move(from);
  }

  inline ObservationFeatureLayer& operator=(const ObservationFeatureLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObservationFeatureLayer& operator=(ObservationFeatureLayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObservationFeatureLayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObservationFeatureLayer* internal_default_instance() {
    return reinterpret_cast<const ObservationFeatureLayer*>(
               &_ObservationFeatureLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ObservationFeatureLayer& a, ObservationFeatureLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ObservationFeatureLayer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObservationFeatureLayer* New() const final {
    return CreateMaybeMessage<ObservationFeatureLayer>(nullptr);
  }

  ObservationFeatureLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObservationFeatureLayer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObservationFeatureLayer& from);
  void MergeFrom(const ObservationFeatureLayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationFeatureLayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ObservationFeatureLayer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRendersFieldNumber = 1,
    kMinimapRendersFieldNumber = 2,
  };
  // optional .SC2APIProtocol.FeatureLayers renders = 1;
  bool has_renders() const;
  private:
  bool _internal_has_renders() const;
  public:
  void clear_renders();
  const ::SC2APIProtocol::FeatureLayers& renders() const;
  ::SC2APIProtocol::FeatureLayers* release_renders();
  ::SC2APIProtocol::FeatureLayers* mutable_renders();
  void set_allocated_renders(::SC2APIProtocol::FeatureLayers* renders);
  private:
  const ::SC2APIProtocol::FeatureLayers& _internal_renders() const;
  ::SC2APIProtocol::FeatureLayers* _internal_mutable_renders();
  public:

  // optional .SC2APIProtocol.FeatureLayersMinimap minimap_renders = 2;
  bool has_minimap_renders() const;
  private:
  bool _internal_has_minimap_renders() const;
  public:
  void clear_minimap_renders();
  const ::SC2APIProtocol::FeatureLayersMinimap& minimap_renders() const;
  ::SC2APIProtocol::FeatureLayersMinimap* release_minimap_renders();
  ::SC2APIProtocol::FeatureLayersMinimap* mutable_minimap_renders();
  void set_allocated_minimap_renders(::SC2APIProtocol::FeatureLayersMinimap* minimap_renders);
  private:
  const ::SC2APIProtocol::FeatureLayersMinimap& _internal_minimap_renders() const;
  ::SC2APIProtocol::FeatureLayersMinimap* _internal_mutable_minimap_renders();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationFeatureLayer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::FeatureLayers* renders_;
  ::SC2APIProtocol::FeatureLayersMinimap* minimap_renders_;
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class FeatureLayers :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.FeatureLayers) */ {
 public:
  FeatureLayers();
  virtual ~FeatureLayers();

  FeatureLayers(const FeatureLayers& from);
  FeatureLayers(FeatureLayers&& from) noexcept
    : FeatureLayers() {
    *this = ::std::move(from);
  }

  inline FeatureLayers& operator=(const FeatureLayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureLayers& operator=(FeatureLayers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeatureLayers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureLayers* internal_default_instance() {
    return reinterpret_cast<const FeatureLayers*>(
               &_FeatureLayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FeatureLayers& a, FeatureLayers& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureLayers* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeatureLayers* New() const final {
    return CreateMaybeMessage<FeatureLayers>(nullptr);
  }

  FeatureLayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeatureLayers>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeatureLayers& from);
  void MergeFrom(const FeatureLayers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureLayers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.FeatureLayers";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightMapFieldNumber = 1,
    kVisibilityMapFieldNumber = 2,
    kCreepFieldNumber = 3,
    kPowerFieldNumber = 4,
    kPlayerIdFieldNumber = 5,
    kUnitTypeFieldNumber = 6,
    kSelectedFieldNumber = 7,
    kUnitHitPointsFieldNumber = 8,
    kUnitEnergyFieldNumber = 9,
    kUnitShieldsFieldNumber = 10,
    kPlayerRelativeFieldNumber = 11,
    kUnitDensityAaFieldNumber = 14,
    kUnitDensityFieldNumber = 15,
    kUnitHitPointsRatioFieldNumber = 17,
    kUnitEnergyRatioFieldNumber = 18,
    kUnitShieldsRatioFieldNumber = 19,
    kEffectsFieldNumber = 20,
    kHallucinationsFieldNumber = 21,
    kCloakedFieldNumber = 22,
    kBlipFieldNumber = 23,
    kBuffsFieldNumber = 24,
    kActiveFieldNumber = 25,
    kBuffDurationFieldNumber = 26,
    kBuildProgressFieldNumber = 27,
    kBuildableFieldNumber = 28,
    kPathableFieldNumber = 29,
    kPlaceholderFieldNumber = 30,
  };
  // optional .SC2APIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  private:
  bool _internal_has_height_map() const;
  public:
  void clear_height_map();
  const ::SC2APIProtocol::ImageData& height_map() const;
  ::SC2APIProtocol::ImageData* release_height_map();
  ::SC2APIProtocol::ImageData* mutable_height_map();
  void set_allocated_height_map(::SC2APIProtocol::ImageData* height_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_height_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_height_map();
  public:

  // optional .SC2APIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  private:
  bool _internal_has_visibility_map() const;
  public:
  void clear_visibility_map();
  const ::SC2APIProtocol::ImageData& visibility_map() const;
  ::SC2APIProtocol::ImageData* release_visibility_map();
  ::SC2APIProtocol::ImageData* mutable_visibility_map();
  void set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_visibility_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_visibility_map();
  public:

  // optional .SC2APIProtocol.ImageData creep = 3;
  bool has_creep() const;
  private:
  bool _internal_has_creep() const;
  public:
  void clear_creep();
  const ::SC2APIProtocol::ImageData& creep() const;
  ::SC2APIProtocol::ImageData* release_creep();
  ::SC2APIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);
  private:
  const ::SC2APIProtocol::ImageData& _internal_creep() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_creep();
  public:

  // optional .SC2APIProtocol.ImageData power = 4;
  bool has_power() const;
  private:
  bool _internal_has_power() const;
  public:
  void clear_power();
  const ::SC2APIProtocol::ImageData& power() const;
  ::SC2APIProtocol::ImageData* release_power();
  ::SC2APIProtocol::ImageData* mutable_power();
  void set_allocated_power(::SC2APIProtocol::ImageData* power);
  private:
  const ::SC2APIProtocol::ImageData& _internal_power() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_power();
  public:

  // optional .SC2APIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::SC2APIProtocol::ImageData& player_id() const;
  ::SC2APIProtocol::ImageData* release_player_id();
  ::SC2APIProtocol::ImageData* mutable_player_id();
  void set_allocated_player_id(::SC2APIProtocol::ImageData* player_id);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_id() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_id();
  public:

  // optional .SC2APIProtocol.ImageData unit_type = 6;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  const ::SC2APIProtocol::ImageData& unit_type() const;
  ::SC2APIProtocol::ImageData* release_unit_type();
  ::SC2APIProtocol::ImageData* mutable_unit_type();
  void set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_type() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_type();
  public:

  // optional .SC2APIProtocol.ImageData selected = 7;
  bool has_selected() const;
  private:
  bool _internal_has_selected() const;
  public:
  void clear_selected();
  const ::SC2APIProtocol::ImageData& selected() const;
  ::SC2APIProtocol::ImageData* release_selected();
  ::SC2APIProtocol::ImageData* mutable_selected();
  void set_allocated_selected(::SC2APIProtocol::ImageData* selected);
  private:
  const ::SC2APIProtocol::ImageData& _internal_selected() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_selected();
  public:

  // optional .SC2APIProtocol.ImageData unit_hit_points = 8;
  bool has_unit_hit_points() const;
  private:
  bool _internal_has_unit_hit_points() const;
  public:
  void clear_unit_hit_points();
  const ::SC2APIProtocol::ImageData& unit_hit_points() const;
  ::SC2APIProtocol::ImageData* release_unit_hit_points();
  ::SC2APIProtocol::ImageData* mutable_unit_hit_points();
  void set_allocated_unit_hit_points(::SC2APIProtocol::ImageData* unit_hit_points);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_hit_points() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_hit_points();
  public:

  // optional .SC2APIProtocol.ImageData unit_energy = 9;
  bool has_unit_energy() const;
  private:
  bool _internal_has_unit_energy() const;
  public:
  void clear_unit_energy();
  const ::SC2APIProtocol::ImageData& unit_energy() const;
  ::SC2APIProtocol::ImageData* release_unit_energy();
  ::SC2APIProtocol::ImageData* mutable_unit_energy();
  void set_allocated_unit_energy(::SC2APIProtocol::ImageData* unit_energy);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_energy() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_energy();
  public:

  // optional .SC2APIProtocol.ImageData unit_shields = 10;
  bool has_unit_shields() const;
  private:
  bool _internal_has_unit_shields() const;
  public:
  void clear_unit_shields();
  const ::SC2APIProtocol::ImageData& unit_shields() const;
  ::SC2APIProtocol::ImageData* release_unit_shields();
  ::SC2APIProtocol::ImageData* mutable_unit_shields();
  void set_allocated_unit_shields(::SC2APIProtocol::ImageData* unit_shields);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_shields() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_shields();
  public:

  // optional .SC2APIProtocol.ImageData player_relative = 11;
  bool has_player_relative() const;
  private:
  bool _internal_has_player_relative() const;
  public:
  void clear_player_relative();
  const ::SC2APIProtocol::ImageData& player_relative() const;
  ::SC2APIProtocol::ImageData* release_player_relative();
  ::SC2APIProtocol::ImageData* mutable_player_relative();
  void set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_relative() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_relative();
  public:

  // optional .SC2APIProtocol.ImageData unit_density_aa = 14;
  bool has_unit_density_aa() const;
  private:
  bool _internal_has_unit_density_aa() const;
  public:
  void clear_unit_density_aa();
  const ::SC2APIProtocol::ImageData& unit_density_aa() const;
  ::SC2APIProtocol::ImageData* release_unit_density_aa();
  ::SC2APIProtocol::ImageData* mutable_unit_density_aa();
  void set_allocated_unit_density_aa(::SC2APIProtocol::ImageData* unit_density_aa);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_density_aa() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_density_aa();
  public:

  // optional .SC2APIProtocol.ImageData unit_density = 15;
  bool has_unit_density() const;
  private:
  bool _internal_has_unit_density() const;
  public:
  void clear_unit_density();
  const ::SC2APIProtocol::ImageData& unit_density() const;
  ::SC2APIProtocol::ImageData* release_unit_density();
  ::SC2APIProtocol::ImageData* mutable_unit_density();
  void set_allocated_unit_density(::SC2APIProtocol::ImageData* unit_density);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_density() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_density();
  public:

  // optional .SC2APIProtocol.ImageData unit_hit_points_ratio = 17;
  bool has_unit_hit_points_ratio() const;
  private:
  bool _internal_has_unit_hit_points_ratio() const;
  public:
  void clear_unit_hit_points_ratio();
  const ::SC2APIProtocol::ImageData& unit_hit_points_ratio() const;
  ::SC2APIProtocol::ImageData* release_unit_hit_points_ratio();
  ::SC2APIProtocol::ImageData* mutable_unit_hit_points_ratio();
  void set_allocated_unit_hit_points_ratio(::SC2APIProtocol::ImageData* unit_hit_points_ratio);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_hit_points_ratio() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_hit_points_ratio();
  public:

  // optional .SC2APIProtocol.ImageData unit_energy_ratio = 18;
  bool has_unit_energy_ratio() const;
  private:
  bool _internal_has_unit_energy_ratio() const;
  public:
  void clear_unit_energy_ratio();
  const ::SC2APIProtocol::ImageData& unit_energy_ratio() const;
  ::SC2APIProtocol::ImageData* release_unit_energy_ratio();
  ::SC2APIProtocol::ImageData* mutable_unit_energy_ratio();
  void set_allocated_unit_energy_ratio(::SC2APIProtocol::ImageData* unit_energy_ratio);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_energy_ratio() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_energy_ratio();
  public:

  // optional .SC2APIProtocol.ImageData unit_shields_ratio = 19;
  bool has_unit_shields_ratio() const;
  private:
  bool _internal_has_unit_shields_ratio() const;
  public:
  void clear_unit_shields_ratio();
  const ::SC2APIProtocol::ImageData& unit_shields_ratio() const;
  ::SC2APIProtocol::ImageData* release_unit_shields_ratio();
  ::SC2APIProtocol::ImageData* mutable_unit_shields_ratio();
  void set_allocated_unit_shields_ratio(::SC2APIProtocol::ImageData* unit_shields_ratio);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_shields_ratio() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_shields_ratio();
  public:

  // optional .SC2APIProtocol.ImageData effects = 20;
  bool has_effects() const;
  private:
  bool _internal_has_effects() const;
  public:
  void clear_effects();
  const ::SC2APIProtocol::ImageData& effects() const;
  ::SC2APIProtocol::ImageData* release_effects();
  ::SC2APIProtocol::ImageData* mutable_effects();
  void set_allocated_effects(::SC2APIProtocol::ImageData* effects);
  private:
  const ::SC2APIProtocol::ImageData& _internal_effects() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_effects();
  public:

  // optional .SC2APIProtocol.ImageData hallucinations = 21;
  bool has_hallucinations() const;
  private:
  bool _internal_has_hallucinations() const;
  public:
  void clear_hallucinations();
  const ::SC2APIProtocol::ImageData& hallucinations() const;
  ::SC2APIProtocol::ImageData* release_hallucinations();
  ::SC2APIProtocol::ImageData* mutable_hallucinations();
  void set_allocated_hallucinations(::SC2APIProtocol::ImageData* hallucinations);
  private:
  const ::SC2APIProtocol::ImageData& _internal_hallucinations() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_hallucinations();
  public:

  // optional .SC2APIProtocol.ImageData cloaked = 22;
  bool has_cloaked() const;
  private:
  bool _internal_has_cloaked() const;
  public:
  void clear_cloaked();
  const ::SC2APIProtocol::ImageData& cloaked() const;
  ::SC2APIProtocol::ImageData* release_cloaked();
  ::SC2APIProtocol::ImageData* mutable_cloaked();
  void set_allocated_cloaked(::SC2APIProtocol::ImageData* cloaked);
  private:
  const ::SC2APIProtocol::ImageData& _internal_cloaked() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_cloaked();
  public:

  // optional .SC2APIProtocol.ImageData blip = 23;
  bool has_blip() const;
  private:
  bool _internal_has_blip() const;
  public:
  void clear_blip();
  const ::SC2APIProtocol::ImageData& blip() const;
  ::SC2APIProtocol::ImageData* release_blip();
  ::SC2APIProtocol::ImageData* mutable_blip();
  void set_allocated_blip(::SC2APIProtocol::ImageData* blip);
  private:
  const ::SC2APIProtocol::ImageData& _internal_blip() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_blip();
  public:

  // optional .SC2APIProtocol.ImageData buffs = 24;
  bool has_buffs() const;
  private:
  bool _internal_has_buffs() const;
  public:
  void clear_buffs();
  const ::SC2APIProtocol::ImageData& buffs() const;
  ::SC2APIProtocol::ImageData* release_buffs();
  ::SC2APIProtocol::ImageData* mutable_buffs();
  void set_allocated_buffs(::SC2APIProtocol::ImageData* buffs);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buffs() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buffs();
  public:

  // optional .SC2APIProtocol.ImageData active = 25;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  const ::SC2APIProtocol::ImageData& active() const;
  ::SC2APIProtocol::ImageData* release_active();
  ::SC2APIProtocol::ImageData* mutable_active();
  void set_allocated_active(::SC2APIProtocol::ImageData* active);
  private:
  const ::SC2APIProtocol::ImageData& _internal_active() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_active();
  public:

  // optional .SC2APIProtocol.ImageData buff_duration = 26;
  bool has_buff_duration() const;
  private:
  bool _internal_has_buff_duration() const;
  public:
  void clear_buff_duration();
  const ::SC2APIProtocol::ImageData& buff_duration() const;
  ::SC2APIProtocol::ImageData* release_buff_duration();
  ::SC2APIProtocol::ImageData* mutable_buff_duration();
  void set_allocated_buff_duration(::SC2APIProtocol::ImageData* buff_duration);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buff_duration() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buff_duration();
  public:

  // optional .SC2APIProtocol.ImageData build_progress = 27;
  bool has_build_progress() const;
  private:
  bool _internal_has_build_progress() const;
  public:
  void clear_build_progress();
  const ::SC2APIProtocol::ImageData& build_progress() const;
  ::SC2APIProtocol::ImageData* release_build_progress();
  ::SC2APIProtocol::ImageData* mutable_build_progress();
  void set_allocated_build_progress(::SC2APIProtocol::ImageData* build_progress);
  private:
  const ::SC2APIProtocol::ImageData& _internal_build_progress() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_build_progress();
  public:

  // optional .SC2APIProtocol.ImageData buildable = 28;
  bool has_buildable() const;
  private:
  bool _internal_has_buildable() const;
  public:
  void clear_buildable();
  const ::SC2APIProtocol::ImageData& buildable() const;
  ::SC2APIProtocol::ImageData* release_buildable();
  ::SC2APIProtocol::ImageData* mutable_buildable();
  void set_allocated_buildable(::SC2APIProtocol::ImageData* buildable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buildable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buildable();
  public:

  // optional .SC2APIProtocol.ImageData pathable = 29;
  bool has_pathable() const;
  private:
  bool _internal_has_pathable() const;
  public:
  void clear_pathable();
  const ::SC2APIProtocol::ImageData& pathable() const;
  ::SC2APIProtocol::ImageData* release_pathable();
  ::SC2APIProtocol::ImageData* mutable_pathable();
  void set_allocated_pathable(::SC2APIProtocol::ImageData* pathable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_pathable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_pathable();
  public:

  // optional .SC2APIProtocol.ImageData placeholder = 30;
  bool has_placeholder() const;
  private:
  bool _internal_has_placeholder() const;
  public:
  void clear_placeholder();
  const ::SC2APIProtocol::ImageData& placeholder() const;
  ::SC2APIProtocol::ImageData* release_placeholder();
  ::SC2APIProtocol::ImageData* mutable_placeholder();
  void set_allocated_placeholder(::SC2APIProtocol::ImageData* placeholder);
  private:
  const ::SC2APIProtocol::ImageData& _internal_placeholder() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_placeholder();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.FeatureLayers)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::ImageData* height_map_;
  ::SC2APIProtocol::ImageData* visibility_map_;
  ::SC2APIProtocol::ImageData* creep_;
  ::SC2APIProtocol::ImageData* power_;
  ::SC2APIProtocol::ImageData* player_id_;
  ::SC2APIProtocol::ImageData* unit_type_;
  ::SC2APIProtocol::ImageData* selected_;
  ::SC2APIProtocol::ImageData* unit_hit_points_;
  ::SC2APIProtocol::ImageData* unit_energy_;
  ::SC2APIProtocol::ImageData* unit_shields_;
  ::SC2APIProtocol::ImageData* player_relative_;
  ::SC2APIProtocol::ImageData* unit_density_aa_;
  ::SC2APIProtocol::ImageData* unit_density_;
  ::SC2APIProtocol::ImageData* unit_hit_points_ratio_;
  ::SC2APIProtocol::ImageData* unit_energy_ratio_;
  ::SC2APIProtocol::ImageData* unit_shields_ratio_;
  ::SC2APIProtocol::ImageData* effects_;
  ::SC2APIProtocol::ImageData* hallucinations_;
  ::SC2APIProtocol::ImageData* cloaked_;
  ::SC2APIProtocol::ImageData* blip_;
  ::SC2APIProtocol::ImageData* buffs_;
  ::SC2APIProtocol::ImageData* active_;
  ::SC2APIProtocol::ImageData* buff_duration_;
  ::SC2APIProtocol::ImageData* build_progress_;
  ::SC2APIProtocol::ImageData* buildable_;
  ::SC2APIProtocol::ImageData* pathable_;
  ::SC2APIProtocol::ImageData* placeholder_;
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class FeatureLayersMinimap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.FeatureLayersMinimap) */ {
 public:
  FeatureLayersMinimap();
  virtual ~FeatureLayersMinimap();

  FeatureLayersMinimap(const FeatureLayersMinimap& from);
  FeatureLayersMinimap(FeatureLayersMinimap&& from) noexcept
    : FeatureLayersMinimap() {
    *this = ::std::move(from);
  }

  inline FeatureLayersMinimap& operator=(const FeatureLayersMinimap& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureLayersMinimap& operator=(FeatureLayersMinimap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeatureLayersMinimap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureLayersMinimap* internal_default_instance() {
    return reinterpret_cast<const FeatureLayersMinimap*>(
               &_FeatureLayersMinimap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FeatureLayersMinimap& a, FeatureLayersMinimap& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureLayersMinimap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeatureLayersMinimap* New() const final {
    return CreateMaybeMessage<FeatureLayersMinimap>(nullptr);
  }

  FeatureLayersMinimap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeatureLayersMinimap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeatureLayersMinimap& from);
  void MergeFrom(const FeatureLayersMinimap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureLayersMinimap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.FeatureLayersMinimap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightMapFieldNumber = 1,
    kVisibilityMapFieldNumber = 2,
    kCreepFieldNumber = 3,
    kCameraFieldNumber = 4,
    kPlayerIdFieldNumber = 5,
    kPlayerRelativeFieldNumber = 6,
    kSelectedFieldNumber = 7,
    kUnitTypeFieldNumber = 8,
    kAlertsFieldNumber = 9,
    kBuildableFieldNumber = 10,
    kPathableFieldNumber = 11,
  };
  // optional .SC2APIProtocol.ImageData height_map = 1;
  bool has_height_map() const;
  private:
  bool _internal_has_height_map() const;
  public:
  void clear_height_map();
  const ::SC2APIProtocol::ImageData& height_map() const;
  ::SC2APIProtocol::ImageData* release_height_map();
  ::SC2APIProtocol::ImageData* mutable_height_map();
  void set_allocated_height_map(::SC2APIProtocol::ImageData* height_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_height_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_height_map();
  public:

  // optional .SC2APIProtocol.ImageData visibility_map = 2;
  bool has_visibility_map() const;
  private:
  bool _internal_has_visibility_map() const;
  public:
  void clear_visibility_map();
  const ::SC2APIProtocol::ImageData& visibility_map() const;
  ::SC2APIProtocol::ImageData* release_visibility_map();
  ::SC2APIProtocol::ImageData* mutable_visibility_map();
  void set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_visibility_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_visibility_map();
  public:

  // optional .SC2APIProtocol.ImageData creep = 3;
  bool has_creep() const;
  private:
  bool _internal_has_creep() const;
  public:
  void clear_creep();
  const ::SC2APIProtocol::ImageData& creep() const;
  ::SC2APIProtocol::ImageData* release_creep();
  ::SC2APIProtocol::ImageData* mutable_creep();
  void set_allocated_creep(::SC2APIProtocol::ImageData* creep);
  private:
  const ::SC2APIProtocol::ImageData& _internal_creep() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_creep();
  public:

  // optional .SC2APIProtocol.ImageData camera = 4;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::SC2APIProtocol::ImageData& camera() const;
  ::SC2APIProtocol::ImageData* release_camera();
  ::SC2APIProtocol::ImageData* mutable_camera();
  void set_allocated_camera(::SC2APIProtocol::ImageData* camera);
  private:
  const ::SC2APIProtocol::ImageData& _internal_camera() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_camera();
  public:

  // optional .SC2APIProtocol.ImageData player_id = 5;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  const ::SC2APIProtocol::ImageData& player_id() const;
  ::SC2APIProtocol::ImageData* release_player_id();
  ::SC2APIProtocol::ImageData* mutable_player_id();
  void set_allocated_player_id(::SC2APIProtocol::ImageData* player_id);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_id() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_id();
  public:

  // optional .SC2APIProtocol.ImageData player_relative = 6;
  bool has_player_relative() const;
  private:
  bool _internal_has_player_relative() const;
  public:
  void clear_player_relative();
  const ::SC2APIProtocol::ImageData& player_relative() const;
  ::SC2APIProtocol::ImageData* release_player_relative();
  ::SC2APIProtocol::ImageData* mutable_player_relative();
  void set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative);
  private:
  const ::SC2APIProtocol::ImageData& _internal_player_relative() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_player_relative();
  public:

  // optional .SC2APIProtocol.ImageData selected = 7;
  bool has_selected() const;
  private:
  bool _internal_has_selected() const;
  public:
  void clear_selected();
  const ::SC2APIProtocol::ImageData& selected() const;
  ::SC2APIProtocol::ImageData* release_selected();
  ::SC2APIProtocol::ImageData* mutable_selected();
  void set_allocated_selected(::SC2APIProtocol::ImageData* selected);
  private:
  const ::SC2APIProtocol::ImageData& _internal_selected() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_selected();
  public:

  // optional .SC2APIProtocol.ImageData unit_type = 8;
  bool has_unit_type() const;
  private:
  bool _internal_has_unit_type() const;
  public:
  void clear_unit_type();
  const ::SC2APIProtocol::ImageData& unit_type() const;
  ::SC2APIProtocol::ImageData* release_unit_type();
  ::SC2APIProtocol::ImageData* mutable_unit_type();
  void set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type);
  private:
  const ::SC2APIProtocol::ImageData& _internal_unit_type() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_unit_type();
  public:

  // optional .SC2APIProtocol.ImageData alerts = 9;
  bool has_alerts() const;
  private:
  bool _internal_has_alerts() const;
  public:
  void clear_alerts();
  const ::SC2APIProtocol::ImageData& alerts() const;
  ::SC2APIProtocol::ImageData* release_alerts();
  ::SC2APIProtocol::ImageData* mutable_alerts();
  void set_allocated_alerts(::SC2APIProtocol::ImageData* alerts);
  private:
  const ::SC2APIProtocol::ImageData& _internal_alerts() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_alerts();
  public:

  // optional .SC2APIProtocol.ImageData buildable = 10;
  bool has_buildable() const;
  private:
  bool _internal_has_buildable() const;
  public:
  void clear_buildable();
  const ::SC2APIProtocol::ImageData& buildable() const;
  ::SC2APIProtocol::ImageData* release_buildable();
  ::SC2APIProtocol::ImageData* mutable_buildable();
  void set_allocated_buildable(::SC2APIProtocol::ImageData* buildable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_buildable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_buildable();
  public:

  // optional .SC2APIProtocol.ImageData pathable = 11;
  bool has_pathable() const;
  private:
  bool _internal_has_pathable() const;
  public:
  void clear_pathable();
  const ::SC2APIProtocol::ImageData& pathable() const;
  ::SC2APIProtocol::ImageData* release_pathable();
  ::SC2APIProtocol::ImageData* mutable_pathable();
  void set_allocated_pathable(::SC2APIProtocol::ImageData* pathable);
  private:
  const ::SC2APIProtocol::ImageData& _internal_pathable() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_pathable();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.FeatureLayersMinimap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::ImageData* height_map_;
  ::SC2APIProtocol::ImageData* visibility_map_;
  ::SC2APIProtocol::ImageData* creep_;
  ::SC2APIProtocol::ImageData* camera_;
  ::SC2APIProtocol::ImageData* player_id_;
  ::SC2APIProtocol::ImageData* player_relative_;
  ::SC2APIProtocol::ImageData* selected_;
  ::SC2APIProtocol::ImageData* unit_type_;
  ::SC2APIProtocol::ImageData* alerts_;
  ::SC2APIProtocol::ImageData* buildable_;
  ::SC2APIProtocol::ImageData* pathable_;
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ObservationRender :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObservationRender) */ {
 public:
  ObservationRender();
  virtual ~ObservationRender();

  ObservationRender(const ObservationRender& from);
  ObservationRender(ObservationRender&& from) noexcept
    : ObservationRender() {
    *this = ::std::move(from);
  }

  inline ObservationRender& operator=(const ObservationRender& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObservationRender& operator=(ObservationRender&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObservationRender& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObservationRender* internal_default_instance() {
    return reinterpret_cast<const ObservationRender*>(
               &_ObservationRender_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ObservationRender& a, ObservationRender& b) {
    a.Swap(&b);
  }
  inline void Swap(ObservationRender* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObservationRender* New() const final {
    return CreateMaybeMessage<ObservationRender>(nullptr);
  }

  ObservationRender* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObservationRender>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObservationRender& from);
  void MergeFrom(const ObservationRender& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObservationRender* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ObservationRender";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 1,
    kMinimapFieldNumber = 2,
  };
  // optional .SC2APIProtocol.ImageData map = 1;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::SC2APIProtocol::ImageData& map() const;
  ::SC2APIProtocol::ImageData* release_map();
  ::SC2APIProtocol::ImageData* mutable_map();
  void set_allocated_map(::SC2APIProtocol::ImageData* map);
  private:
  const ::SC2APIProtocol::ImageData& _internal_map() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_map();
  public:

  // optional .SC2APIProtocol.ImageData minimap = 2;
  bool has_minimap() const;
  private:
  bool _internal_has_minimap() const;
  public:
  void clear_minimap();
  const ::SC2APIProtocol::ImageData& minimap() const;
  ::SC2APIProtocol::ImageData* release_minimap();
  ::SC2APIProtocol::ImageData* mutable_minimap();
  void set_allocated_minimap(::SC2APIProtocol::ImageData* minimap);
  private:
  const ::SC2APIProtocol::ImageData& _internal_minimap() const;
  ::SC2APIProtocol::ImageData* _internal_mutable_minimap();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObservationRender)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::ImageData* map_;
  ::SC2APIProtocol::ImageData* minimap_;
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatial :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatial) */ {
 public:
  ActionSpatial();
  virtual ~ActionSpatial();

  ActionSpatial(const ActionSpatial& from);
  ActionSpatial(ActionSpatial&& from) noexcept
    : ActionSpatial() {
    *this = ::std::move(from);
  }

  inline ActionSpatial& operator=(const ActionSpatial& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatial& operator=(ActionSpatial&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionSpatial& default_instance();

  enum ActionCase {
    kUnitCommand = 1,
    kCameraMove = 2,
    kUnitSelectionPoint = 3,
    kUnitSelectionRect = 4,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatial* internal_default_instance() {
    return reinterpret_cast<const ActionSpatial*>(
               &_ActionSpatial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ActionSpatial& a, ActionSpatial& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatial* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatial* New() const final {
    return CreateMaybeMessage<ActionSpatial>(nullptr);
  }

  ActionSpatial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatial>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionSpatial& from);
  void MergeFrom(const ActionSpatial& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatial* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatial";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitCommandFieldNumber = 1,
    kCameraMoveFieldNumber = 2,
    kUnitSelectionPointFieldNumber = 3,
    kUnitSelectionRectFieldNumber = 4,
  };
  // optional .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;
  bool has_unit_command() const;
  private:
  bool _internal_has_unit_command() const;
  public:
  void clear_unit_command();
  const ::SC2APIProtocol::ActionSpatialUnitCommand& unit_command() const;
  ::SC2APIProtocol::ActionSpatialUnitCommand* release_unit_command();
  ::SC2APIProtocol::ActionSpatialUnitCommand* mutable_unit_command();
  void set_allocated_unit_command(::SC2APIProtocol::ActionSpatialUnitCommand* unit_command);
  private:
  const ::SC2APIProtocol::ActionSpatialUnitCommand& _internal_unit_command() const;
  ::SC2APIProtocol::ActionSpatialUnitCommand* _internal_mutable_unit_command();
  public:

  // optional .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;
  bool has_camera_move() const;
  private:
  bool _internal_has_camera_move() const;
  public:
  void clear_camera_move();
  const ::SC2APIProtocol::ActionSpatialCameraMove& camera_move() const;
  ::SC2APIProtocol::ActionSpatialCameraMove* release_camera_move();
  ::SC2APIProtocol::ActionSpatialCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SC2APIProtocol::ActionSpatialCameraMove* camera_move);
  private:
  const ::SC2APIProtocol::ActionSpatialCameraMove& _internal_camera_move() const;
  ::SC2APIProtocol::ActionSpatialCameraMove* _internal_mutable_camera_move();
  public:

  // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
  bool has_unit_selection_point() const;
  private:
  bool _internal_has_unit_selection_point() const;
  public:
  void clear_unit_selection_point();
  const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& unit_selection_point() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* release_unit_selection_point();
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* mutable_unit_selection_point();
  void set_allocated_unit_selection_point(::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point);
  private:
  const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& _internal_unit_selection_point() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* _internal_mutable_unit_selection_point();
  public:

  // optional .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
  bool has_unit_selection_rect() const;
  private:
  bool _internal_has_unit_selection_rect() const;
  public:
  void clear_unit_selection_rect();
  const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& unit_selection_rect() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* release_unit_selection_rect();
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* mutable_unit_selection_rect();
  void set_allocated_unit_selection_rect(::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect);
  private:
  const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& _internal_unit_selection_rect() const;
  ::SC2APIProtocol::ActionSpatialUnitSelectionRect* _internal_mutable_unit_selection_rect();
  public:

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatial)
 private:
  class _Internal;
  void set_has_unit_command();
  void set_has_camera_move();
  void set_has_unit_selection_point();
  void set_has_unit_selection_rect();

  inline bool has_action() const;
  inline void clear_has_action();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SC2APIProtocol::ActionSpatialUnitCommand* unit_command_;
    ::SC2APIProtocol::ActionSpatialCameraMove* camera_move_;
    ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* unit_selection_point_;
    ::SC2APIProtocol::ActionSpatialUnitSelectionRect* unit_selection_rect_;
  } action_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialUnitCommand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitCommand) */ {
 public:
  ActionSpatialUnitCommand();
  virtual ~ActionSpatialUnitCommand();

  ActionSpatialUnitCommand(const ActionSpatialUnitCommand& from);
  ActionSpatialUnitCommand(ActionSpatialUnitCommand&& from) noexcept
    : ActionSpatialUnitCommand() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitCommand& operator=(const ActionSpatialUnitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialUnitCommand& operator=(ActionSpatialUnitCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionSpatialUnitCommand& default_instance();

  enum TargetCase {
    kTargetScreenCoord = 2,
    kTargetMinimapCoord = 3,
    TARGET_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialUnitCommand* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitCommand*>(
               &_ActionSpatialUnitCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ActionSpatialUnitCommand& a, ActionSpatialUnitCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialUnitCommand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitCommand* New() const final {
    return CreateMaybeMessage<ActionSpatialUnitCommand>(nullptr);
  }

  ActionSpatialUnitCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialUnitCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionSpatialUnitCommand& from);
  void MergeFrom(const ActionSpatialUnitCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialUnitCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilityIdFieldNumber = 1,
    kQueueCommandFieldNumber = 4,
    kTargetScreenCoordFieldNumber = 2,
    kTargetMinimapCoordFieldNumber = 3,
  };
  // optional int32 ability_id = 1;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  ::PROTOBUF_NAMESPACE_ID::int32 ability_id() const;
  void set_ability_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ability_id() const;
  void _internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool queue_command = 4;
  bool has_queue_command() const;
  private:
  bool _internal_has_queue_command() const;
  public:
  void clear_queue_command();
  bool queue_command() const;
  void set_queue_command(bool value);
  private:
  bool _internal_queue_command() const;
  void _internal_set_queue_command(bool value);
  public:

  // optional .SC2APIProtocol.PointI target_screen_coord = 2;
  bool has_target_screen_coord() const;
  private:
  bool _internal_has_target_screen_coord() const;
  public:
  void clear_target_screen_coord();
  const ::SC2APIProtocol::PointI& target_screen_coord() const;
  ::SC2APIProtocol::PointI* release_target_screen_coord();
  ::SC2APIProtocol::PointI* mutable_target_screen_coord();
  void set_allocated_target_screen_coord(::SC2APIProtocol::PointI* target_screen_coord);
  private:
  const ::SC2APIProtocol::PointI& _internal_target_screen_coord() const;
  ::SC2APIProtocol::PointI* _internal_mutable_target_screen_coord();
  public:

  // optional .SC2APIProtocol.PointI target_minimap_coord = 3;
  bool has_target_minimap_coord() const;
  private:
  bool _internal_has_target_minimap_coord() const;
  public:
  void clear_target_minimap_coord();
  const ::SC2APIProtocol::PointI& target_minimap_coord() const;
  ::SC2APIProtocol::PointI* release_target_minimap_coord();
  ::SC2APIProtocol::PointI* mutable_target_minimap_coord();
  void set_allocated_target_minimap_coord(::SC2APIProtocol::PointI* target_minimap_coord);
  private:
  const ::SC2APIProtocol::PointI& _internal_target_minimap_coord() const;
  ::SC2APIProtocol::PointI* _internal_mutable_target_minimap_coord();
  public:

  void clear_target();
  TargetCase target_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitCommand)
 private:
  class _Internal;
  void set_has_target_screen_coord();
  void set_has_target_minimap_coord();

  inline bool has_target() const;
  inline void clear_has_target();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 ability_id_;
  bool queue_command_;
  union TargetUnion {
    TargetUnion() {}
    ::SC2APIProtocol::PointI* target_screen_coord_;
    ::SC2APIProtocol::PointI* target_minimap_coord_;
  } target_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialCameraMove :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialCameraMove) */ {
 public:
  ActionSpatialCameraMove();
  virtual ~ActionSpatialCameraMove();

  ActionSpatialCameraMove(const ActionSpatialCameraMove& from);
  ActionSpatialCameraMove(ActionSpatialCameraMove&& from) noexcept
    : ActionSpatialCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionSpatialCameraMove& operator=(const ActionSpatialCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialCameraMove& operator=(ActionSpatialCameraMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionSpatialCameraMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialCameraMove*>(
               &_ActionSpatialCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ActionSpatialCameraMove& a, ActionSpatialCameraMove& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialCameraMove* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialCameraMove* New() const final {
    return CreateMaybeMessage<ActionSpatialCameraMove>(nullptr);
  }

  ActionSpatialCameraMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialCameraMove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionSpatialCameraMove& from);
  void MergeFrom(const ActionSpatialCameraMove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialCameraMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialCameraMove";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterMinimapFieldNumber = 1,
  };
  // optional .SC2APIProtocol.PointI center_minimap = 1;
  bool has_center_minimap() const;
  private:
  bool _internal_has_center_minimap() const;
  public:
  void clear_center_minimap();
  const ::SC2APIProtocol::PointI& center_minimap() const;
  ::SC2APIProtocol::PointI* release_center_minimap();
  ::SC2APIProtocol::PointI* mutable_center_minimap();
  void set_allocated_center_minimap(::SC2APIProtocol::PointI* center_minimap);
  private:
  const ::SC2APIProtocol::PointI& _internal_center_minimap() const;
  ::SC2APIProtocol::PointI* _internal_mutable_center_minimap();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialCameraMove)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::PointI* center_minimap_;
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitSelectionPoint) */ {
 public:
  ActionSpatialUnitSelectionPoint();
  virtual ~ActionSpatialUnitSelectionPoint();

  ActionSpatialUnitSelectionPoint(const ActionSpatialUnitSelectionPoint& from);
  ActionSpatialUnitSelectionPoint(ActionSpatialUnitSelectionPoint&& from) noexcept
    : ActionSpatialUnitSelectionPoint() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitSelectionPoint& operator=(const ActionSpatialUnitSelectionPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialUnitSelectionPoint& operator=(ActionSpatialUnitSelectionPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionSpatialUnitSelectionPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialUnitSelectionPoint* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitSelectionPoint*>(
               &_ActionSpatialUnitSelectionPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ActionSpatialUnitSelectionPoint& a, ActionSpatialUnitSelectionPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialUnitSelectionPoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitSelectionPoint* New() const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionPoint>(nullptr);
  }

  ActionSpatialUnitSelectionPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionSpatialUnitSelectionPoint& from);
  void MergeFrom(const ActionSpatialUnitSelectionPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitSelectionPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialUnitSelectionPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ActionSpatialUnitSelectionPoint_Type Type;
  static constexpr Type Select =
    ActionSpatialUnitSelectionPoint_Type_Select;
  static constexpr Type Toggle =
    ActionSpatialUnitSelectionPoint_Type_Toggle;
  static constexpr Type AllType =
    ActionSpatialUnitSelectionPoint_Type_AllType;
  static constexpr Type AddAllType =
    ActionSpatialUnitSelectionPoint_Type_AddAllType;
  static inline bool Type_IsValid(int value) {
    return ActionSpatialUnitSelectionPoint_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ActionSpatialUnitSelectionPoint_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ActionSpatialUnitSelectionPoint_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ActionSpatialUnitSelectionPoint_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ActionSpatialUnitSelectionPoint_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ActionSpatialUnitSelectionPoint_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return ActionSpatialUnitSelectionPoint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSelectionScreenCoordFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .SC2APIProtocol.PointI selection_screen_coord = 1;
  bool has_selection_screen_coord() const;
  private:
  bool _internal_has_selection_screen_coord() const;
  public:
  void clear_selection_screen_coord();
  const ::SC2APIProtocol::PointI& selection_screen_coord() const;
  ::SC2APIProtocol::PointI* release_selection_screen_coord();
  ::SC2APIProtocol::PointI* mutable_selection_screen_coord();
  void set_allocated_selection_screen_coord(::SC2APIProtocol::PointI* selection_screen_coord);
  private:
  const ::SC2APIProtocol::PointI& _internal_selection_screen_coord() const;
  ::SC2APIProtocol::PointI* _internal_mutable_selection_screen_coord();
  public:

  // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type type() const;
  void set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value);
  private:
  ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type _internal_type() const;
  void _internal_set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitSelectionPoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::PointI* selection_screen_coord_;
  int type_;
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// -------------------------------------------------------------------

class ActionSpatialUnitSelectionRect :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionSpatialUnitSelectionRect) */ {
 public:
  ActionSpatialUnitSelectionRect();
  virtual ~ActionSpatialUnitSelectionRect();

  ActionSpatialUnitSelectionRect(const ActionSpatialUnitSelectionRect& from);
  ActionSpatialUnitSelectionRect(ActionSpatialUnitSelectionRect&& from) noexcept
    : ActionSpatialUnitSelectionRect() {
    *this = ::std::move(from);
  }

  inline ActionSpatialUnitSelectionRect& operator=(const ActionSpatialUnitSelectionRect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpatialUnitSelectionRect& operator=(ActionSpatialUnitSelectionRect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionSpatialUnitSelectionRect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpatialUnitSelectionRect* internal_default_instance() {
    return reinterpret_cast<const ActionSpatialUnitSelectionRect*>(
               &_ActionSpatialUnitSelectionRect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ActionSpatialUnitSelectionRect& a, ActionSpatialUnitSelectionRect& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpatialUnitSelectionRect* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionSpatialUnitSelectionRect* New() const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionRect>(nullptr);
  }

  ActionSpatialUnitSelectionRect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpatialUnitSelectionRect>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionSpatialUnitSelectionRect& from);
  void MergeFrom(const ActionSpatialUnitSelectionRect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpatialUnitSelectionRect* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionSpatialUnitSelectionRect";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fspatial_2eproto);
    return ::descriptor_table_s2clientprotocol_2fspatial_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectionScreenCoordFieldNumber = 1,
    kSelectionAddFieldNumber = 2,
  };
  // repeated .SC2APIProtocol.RectangleI selection_screen_coord = 1;
  int selection_screen_coord_size() const;
  private:
  int _internal_selection_screen_coord_size() const;
  public:
  void clear_selection_screen_coord();
  ::SC2APIProtocol::RectangleI* mutable_selection_screen_coord(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >*
      mutable_selection_screen_coord();
  private:
  const ::SC2APIProtocol::RectangleI& _internal_selection_screen_coord(int index) const;
  ::SC2APIProtocol::RectangleI* _internal_add_selection_screen_coord();
  public:
  const ::SC2APIProtocol::RectangleI& selection_screen_coord(int index) const;
  ::SC2APIProtocol::RectangleI* add_selection_screen_coord();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >&
      selection_screen_coord() const;

  // optional bool selection_add = 2;
  bool has_selection_add() const;
  private:
  bool _internal_has_selection_add() const;
  public:
  void clear_selection_add();
  bool selection_add() const;
  void set_selection_add(bool value);
  private:
  bool _internal_selection_add() const;
  void _internal_set_selection_add(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionSpatialUnitSelectionRect)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI > selection_screen_coord_;
  bool selection_add_;
  friend struct ::TableStruct_s2clientprotocol_2fspatial_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObservationFeatureLayer

// optional .SC2APIProtocol.FeatureLayers renders = 1;
inline bool ObservationFeatureLayer::_internal_has_renders() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || renders_ != nullptr);
  return value;
}
inline bool ObservationFeatureLayer::has_renders() const {
  return _internal_has_renders();
}
inline void ObservationFeatureLayer::clear_renders() {
  if (renders_ != nullptr) renders_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::FeatureLayers& ObservationFeatureLayer::_internal_renders() const {
  const ::SC2APIProtocol::FeatureLayers* p = renders_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::FeatureLayers*>(
      &::SC2APIProtocol::_FeatureLayers_default_instance_);
}
inline const ::SC2APIProtocol::FeatureLayers& ObservationFeatureLayer::renders() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationFeatureLayer.renders)
  return _internal_renders();
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::release_renders() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationFeatureLayer.renders)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::FeatureLayers* temp = renders_;
  renders_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::_internal_mutable_renders() {
  _has_bits_[0] |= 0x00000001u;
  if (renders_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::FeatureLayers>(GetArenaNoVirtual());
    renders_ = p;
  }
  return renders_;
}
inline ::SC2APIProtocol::FeatureLayers* ObservationFeatureLayer::mutable_renders() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationFeatureLayer.renders)
  return _internal_mutable_renders();
}
inline void ObservationFeatureLayer::set_allocated_renders(::SC2APIProtocol::FeatureLayers* renders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete renders_;
  }
  if (renders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      renders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renders, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  renders_ = renders;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationFeatureLayer.renders)
}

// optional .SC2APIProtocol.FeatureLayersMinimap minimap_renders = 2;
inline bool ObservationFeatureLayer::_internal_has_minimap_renders() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || minimap_renders_ != nullptr);
  return value;
}
inline bool ObservationFeatureLayer::has_minimap_renders() const {
  return _internal_has_minimap_renders();
}
inline void ObservationFeatureLayer::clear_minimap_renders() {
  if (minimap_renders_ != nullptr) minimap_renders_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::FeatureLayersMinimap& ObservationFeatureLayer::_internal_minimap_renders() const {
  const ::SC2APIProtocol::FeatureLayersMinimap* p = minimap_renders_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::FeatureLayersMinimap*>(
      &::SC2APIProtocol::_FeatureLayersMinimap_default_instance_);
}
inline const ::SC2APIProtocol::FeatureLayersMinimap& ObservationFeatureLayer::minimap_renders() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  return _internal_minimap_renders();
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::release_minimap_renders() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::FeatureLayersMinimap* temp = minimap_renders_;
  minimap_renders_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::_internal_mutable_minimap_renders() {
  _has_bits_[0] |= 0x00000002u;
  if (minimap_renders_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::FeatureLayersMinimap>(GetArenaNoVirtual());
    minimap_renders_ = p;
  }
  return minimap_renders_;
}
inline ::SC2APIProtocol::FeatureLayersMinimap* ObservationFeatureLayer::mutable_minimap_renders() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
  return _internal_mutable_minimap_renders();
}
inline void ObservationFeatureLayer::set_allocated_minimap_renders(::SC2APIProtocol::FeatureLayersMinimap* minimap_renders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete minimap_renders_;
  }
  if (minimap_renders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      minimap_renders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimap_renders, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  minimap_renders_ = minimap_renders;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
}

// -------------------------------------------------------------------

// FeatureLayers

// optional .SC2APIProtocol.ImageData height_map = 1;
inline bool FeatureLayers::_internal_has_height_map() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || height_map_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_height_map() const {
  return _internal_has_height_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_height_map() const {
  const ::SC2APIProtocol::ImageData* p = height_map_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::height_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.height_map)
  return _internal_height_map();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_height_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.height_map)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = height_map_;
  height_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_height_map() {
  _has_bits_[0] |= 0x00000001u;
  if (height_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    height_map_ = p;
  }
  return height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_height_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.height_map)
  return _internal_mutable_height_map();
}
inline void FeatureLayers::set_allocated_height_map(::SC2APIProtocol::ImageData* height_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(height_map_);
  }
  if (height_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      height_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height_map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  height_map_ = height_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.height_map)
}

// optional .SC2APIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayers::_internal_has_visibility_map() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || visibility_map_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_visibility_map() const {
  return _internal_has_visibility_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_visibility_map() const {
  const ::SC2APIProtocol::ImageData* p = visibility_map_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::visibility_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.visibility_map)
  return _internal_visibility_map();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_visibility_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.visibility_map)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = visibility_map_;
  visibility_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_visibility_map() {
  _has_bits_[0] |= 0x00000002u;
  if (visibility_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    visibility_map_ = p;
  }
  return visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_visibility_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.visibility_map)
  return _internal_mutable_visibility_map();
}
inline void FeatureLayers::set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(visibility_map_);
  }
  if (visibility_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      visibility_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility_map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  visibility_map_ = visibility_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.visibility_map)
}

// optional .SC2APIProtocol.ImageData creep = 3;
inline bool FeatureLayers::_internal_has_creep() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || creep_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_creep() const {
  return _internal_has_creep();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_creep() const {
  const ::SC2APIProtocol::ImageData* p = creep_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.creep)
  return _internal_creep();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.creep)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = creep_;
  creep_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_creep() {
  _has_bits_[0] |= 0x00000004u;
  if (creep_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    creep_ = p;
  }
  return creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_creep() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.creep)
  return _internal_mutable_creep();
}
inline void FeatureLayers::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(creep_);
  }
  if (creep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      creep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.creep)
}

// optional .SC2APIProtocol.ImageData power = 4;
inline bool FeatureLayers::_internal_has_power() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || power_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_power() const {
  return _internal_has_power();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_power() const {
  const ::SC2APIProtocol::ImageData* p = power_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::power() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.power)
  return _internal_power();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_power() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.power)
  _has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = power_;
  power_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_power() {
  _has_bits_[0] |= 0x00000008u;
  if (power_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    power_ = p;
  }
  return power_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_power() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.power)
  return _internal_mutable_power();
}
inline void FeatureLayers::set_allocated_power(::SC2APIProtocol::ImageData* power) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(power_);
  }
  if (power) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      power = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  power_ = power;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.power)
}

// optional .SC2APIProtocol.ImageData player_id = 5;
inline bool FeatureLayers::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || player_id_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_player_id() const {
  const ::SC2APIProtocol::ImageData* p = player_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.player_id)
  return _internal_player_id();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_player_id() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.player_id)
  _has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ImageData* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_player_id() {
  _has_bits_[0] |= 0x00000010u;
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    player_id_ = p;
  }
  return player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_player_id() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.player_id)
  return _internal_mutable_player_id();
}
inline void FeatureLayers::set_allocated_player_id(::SC2APIProtocol::ImageData* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.player_id)
}

// optional .SC2APIProtocol.ImageData unit_type = 6;
inline bool FeatureLayers::_internal_has_unit_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || unit_type_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_type() const {
  return _internal_has_unit_type();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_type() const {
  const ::SC2APIProtocol::ImageData* p = unit_type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_type)
  return _internal_unit_type();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_type() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_type)
  _has_bits_[0] &= ~0x00000020u;
  ::SC2APIProtocol::ImageData* temp = unit_type_;
  unit_type_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_type() {
  _has_bits_[0] |= 0x00000020u;
  if (unit_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_type_ = p;
  }
  return unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_type() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_type)
  return _internal_mutable_unit_type();
}
inline void FeatureLayers::set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_type_);
  }
  if (unit_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  unit_type_ = unit_type;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_type)
}

// optional .SC2APIProtocol.ImageData selected = 7;
inline bool FeatureLayers::_internal_has_selected() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || selected_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_selected() const {
  return _internal_has_selected();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_selected() const {
  const ::SC2APIProtocol::ImageData* p = selected_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.selected)
  return _internal_selected();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_selected() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.selected)
  _has_bits_[0] &= ~0x00000040u;
  ::SC2APIProtocol::ImageData* temp = selected_;
  selected_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_selected() {
  _has_bits_[0] |= 0x00000040u;
  if (selected_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    selected_ = p;
  }
  return selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_selected() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.selected)
  return _internal_mutable_selected();
}
inline void FeatureLayers::set_allocated_selected(::SC2APIProtocol::ImageData* selected) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(selected_);
  }
  if (selected) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      selected = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  selected_ = selected;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.selected)
}

// optional .SC2APIProtocol.ImageData unit_hit_points = 8;
inline bool FeatureLayers::_internal_has_unit_hit_points() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || unit_hit_points_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_hit_points() const {
  return _internal_has_unit_hit_points();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_hit_points() const {
  const ::SC2APIProtocol::ImageData* p = unit_hit_points_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_hit_points() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_hit_points)
  return _internal_unit_hit_points();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_hit_points() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_hit_points)
  _has_bits_[0] &= ~0x00000080u;
  ::SC2APIProtocol::ImageData* temp = unit_hit_points_;
  unit_hit_points_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_hit_points() {
  _has_bits_[0] |= 0x00000080u;
  if (unit_hit_points_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_hit_points_ = p;
  }
  return unit_hit_points_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_hit_points)
  return _internal_mutable_unit_hit_points();
}
inline void FeatureLayers::set_allocated_unit_hit_points(::SC2APIProtocol::ImageData* unit_hit_points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_hit_points_);
  }
  if (unit_hit_points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_hit_points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_hit_points, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  unit_hit_points_ = unit_hit_points;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points)
}

// optional .SC2APIProtocol.ImageData unit_hit_points_ratio = 17;
inline bool FeatureLayers::_internal_has_unit_hit_points_ratio() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || unit_hit_points_ratio_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_hit_points_ratio() const {
  return _internal_has_unit_hit_points_ratio();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_hit_points_ratio() const {
  const ::SC2APIProtocol::ImageData* p = unit_hit_points_ratio_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_hit_points_ratio() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  return _internal_unit_hit_points_ratio();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_hit_points_ratio() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  _has_bits_[0] &= ~0x00002000u;
  ::SC2APIProtocol::ImageData* temp = unit_hit_points_ratio_;
  unit_hit_points_ratio_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_hit_points_ratio() {
  _has_bits_[0] |= 0x00002000u;
  if (unit_hit_points_ratio_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_hit_points_ratio_ = p;
  }
  return unit_hit_points_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_hit_points_ratio() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
  return _internal_mutable_unit_hit_points_ratio();
}
inline void FeatureLayers::set_allocated_unit_hit_points_ratio(::SC2APIProtocol::ImageData* unit_hit_points_ratio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_hit_points_ratio_);
  }
  if (unit_hit_points_ratio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_hit_points_ratio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_hit_points_ratio, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  unit_hit_points_ratio_ = unit_hit_points_ratio;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
}

// optional .SC2APIProtocol.ImageData unit_energy = 9;
inline bool FeatureLayers::_internal_has_unit_energy() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || unit_energy_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_energy() const {
  return _internal_has_unit_energy();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_energy() const {
  const ::SC2APIProtocol::ImageData* p = unit_energy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_energy() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_energy)
  return _internal_unit_energy();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_energy() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_energy)
  _has_bits_[0] &= ~0x00000100u;
  ::SC2APIProtocol::ImageData* temp = unit_energy_;
  unit_energy_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_energy() {
  _has_bits_[0] |= 0x00000100u;
  if (unit_energy_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_energy_ = p;
  }
  return unit_energy_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_energy() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_energy)
  return _internal_mutable_unit_energy();
}
inline void FeatureLayers::set_allocated_unit_energy(::SC2APIProtocol::ImageData* unit_energy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_energy_);
  }
  if (unit_energy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_energy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_energy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  unit_energy_ = unit_energy;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_energy)
}

// optional .SC2APIProtocol.ImageData unit_energy_ratio = 18;
inline bool FeatureLayers::_internal_has_unit_energy_ratio() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || unit_energy_ratio_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_energy_ratio() const {
  return _internal_has_unit_energy_ratio();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_energy_ratio() const {
  const ::SC2APIProtocol::ImageData* p = unit_energy_ratio_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_energy_ratio() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
  return _internal_unit_energy_ratio();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_energy_ratio() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
  _has_bits_[0] &= ~0x00004000u;
  ::SC2APIProtocol::ImageData* temp = unit_energy_ratio_;
  unit_energy_ratio_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_energy_ratio() {
  _has_bits_[0] |= 0x00004000u;
  if (unit_energy_ratio_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_energy_ratio_ = p;
  }
  return unit_energy_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_energy_ratio() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
  return _internal_mutable_unit_energy_ratio();
}
inline void FeatureLayers::set_allocated_unit_energy_ratio(::SC2APIProtocol::ImageData* unit_energy_ratio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_energy_ratio_);
  }
  if (unit_energy_ratio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_energy_ratio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_energy_ratio, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  unit_energy_ratio_ = unit_energy_ratio;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
}

// optional .SC2APIProtocol.ImageData unit_shields = 10;
inline bool FeatureLayers::_internal_has_unit_shields() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || unit_shields_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_shields() const {
  return _internal_has_unit_shields();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_shields() const {
  const ::SC2APIProtocol::ImageData* p = unit_shields_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_shields() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_shields)
  return _internal_unit_shields();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_shields() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_shields)
  _has_bits_[0] &= ~0x00000200u;
  ::SC2APIProtocol::ImageData* temp = unit_shields_;
  unit_shields_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_shields() {
  _has_bits_[0] |= 0x00000200u;
  if (unit_shields_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_shields_ = p;
  }
  return unit_shields_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_shields() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_shields)
  return _internal_mutable_unit_shields();
}
inline void FeatureLayers::set_allocated_unit_shields(::SC2APIProtocol::ImageData* unit_shields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_shields_);
  }
  if (unit_shields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_shields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_shields, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  unit_shields_ = unit_shields;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_shields)
}

// optional .SC2APIProtocol.ImageData unit_shields_ratio = 19;
inline bool FeatureLayers::_internal_has_unit_shields_ratio() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || unit_shields_ratio_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_shields_ratio() const {
  return _internal_has_unit_shields_ratio();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_shields_ratio() const {
  const ::SC2APIProtocol::ImageData* p = unit_shields_ratio_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_shields_ratio() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
  return _internal_unit_shields_ratio();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_shields_ratio() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
  _has_bits_[0] &= ~0x00008000u;
  ::SC2APIProtocol::ImageData* temp = unit_shields_ratio_;
  unit_shields_ratio_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_shields_ratio() {
  _has_bits_[0] |= 0x00008000u;
  if (unit_shields_ratio_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_shields_ratio_ = p;
  }
  return unit_shields_ratio_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_shields_ratio() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
  return _internal_mutable_unit_shields_ratio();
}
inline void FeatureLayers::set_allocated_unit_shields_ratio(::SC2APIProtocol::ImageData* unit_shields_ratio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_shields_ratio_);
  }
  if (unit_shields_ratio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_shields_ratio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_shields_ratio, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  unit_shields_ratio_ = unit_shields_ratio;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
}

// optional .SC2APIProtocol.ImageData player_relative = 11;
inline bool FeatureLayers::_internal_has_player_relative() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || player_relative_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_player_relative() const {
  return _internal_has_player_relative();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_player_relative() const {
  const ::SC2APIProtocol::ImageData* p = player_relative_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::player_relative() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.player_relative)
  return _internal_player_relative();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_player_relative() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.player_relative)
  _has_bits_[0] &= ~0x00000400u;
  ::SC2APIProtocol::ImageData* temp = player_relative_;
  player_relative_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_player_relative() {
  _has_bits_[0] |= 0x00000400u;
  if (player_relative_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    player_relative_ = p;
  }
  return player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_player_relative() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.player_relative)
  return _internal_mutable_player_relative();
}
inline void FeatureLayers::set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_relative_);
  }
  if (player_relative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_relative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_relative, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  player_relative_ = player_relative;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.player_relative)
}

// optional .SC2APIProtocol.ImageData unit_density_aa = 14;
inline bool FeatureLayers::_internal_has_unit_density_aa() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || unit_density_aa_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_density_aa() const {
  return _internal_has_unit_density_aa();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_density_aa() const {
  const ::SC2APIProtocol::ImageData* p = unit_density_aa_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_density_aa() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_density_aa)
  return _internal_unit_density_aa();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_density_aa() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_density_aa)
  _has_bits_[0] &= ~0x00000800u;
  ::SC2APIProtocol::ImageData* temp = unit_density_aa_;
  unit_density_aa_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_density_aa() {
  _has_bits_[0] |= 0x00000800u;
  if (unit_density_aa_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_density_aa_ = p;
  }
  return unit_density_aa_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_density_aa() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_density_aa)
  return _internal_mutable_unit_density_aa();
}
inline void FeatureLayers::set_allocated_unit_density_aa(::SC2APIProtocol::ImageData* unit_density_aa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_density_aa_);
  }
  if (unit_density_aa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_density_aa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_density_aa, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  unit_density_aa_ = unit_density_aa;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_density_aa)
}

// optional .SC2APIProtocol.ImageData unit_density = 15;
inline bool FeatureLayers::_internal_has_unit_density() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || unit_density_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_unit_density() const {
  return _internal_has_unit_density();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_unit_density() const {
  const ::SC2APIProtocol::ImageData* p = unit_density_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::unit_density() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.unit_density)
  return _internal_unit_density();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_unit_density() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.unit_density)
  _has_bits_[0] &= ~0x00001000u;
  ::SC2APIProtocol::ImageData* temp = unit_density_;
  unit_density_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_unit_density() {
  _has_bits_[0] |= 0x00001000u;
  if (unit_density_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_density_ = p;
  }
  return unit_density_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_unit_density() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.unit_density)
  return _internal_mutable_unit_density();
}
inline void FeatureLayers::set_allocated_unit_density(::SC2APIProtocol::ImageData* unit_density) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_density_);
  }
  if (unit_density) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_density = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_density, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  unit_density_ = unit_density;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.unit_density)
}

// optional .SC2APIProtocol.ImageData effects = 20;
inline bool FeatureLayers::_internal_has_effects() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || effects_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_effects() const {
  return _internal_has_effects();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_effects() const {
  const ::SC2APIProtocol::ImageData* p = effects_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::effects() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.effects)
  return _internal_effects();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_effects() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.effects)
  _has_bits_[0] &= ~0x00010000u;
  ::SC2APIProtocol::ImageData* temp = effects_;
  effects_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_effects() {
  _has_bits_[0] |= 0x00010000u;
  if (effects_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    effects_ = p;
  }
  return effects_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_effects() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.effects)
  return _internal_mutable_effects();
}
inline void FeatureLayers::set_allocated_effects(::SC2APIProtocol::ImageData* effects) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(effects_);
  }
  if (effects) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      effects = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, effects, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  effects_ = effects;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.effects)
}

// optional .SC2APIProtocol.ImageData hallucinations = 21;
inline bool FeatureLayers::_internal_has_hallucinations() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || hallucinations_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_hallucinations() const {
  return _internal_has_hallucinations();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_hallucinations() const {
  const ::SC2APIProtocol::ImageData* p = hallucinations_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::hallucinations() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.hallucinations)
  return _internal_hallucinations();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_hallucinations() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.hallucinations)
  _has_bits_[0] &= ~0x00020000u;
  ::SC2APIProtocol::ImageData* temp = hallucinations_;
  hallucinations_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_hallucinations() {
  _has_bits_[0] |= 0x00020000u;
  if (hallucinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    hallucinations_ = p;
  }
  return hallucinations_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_hallucinations() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.hallucinations)
  return _internal_mutable_hallucinations();
}
inline void FeatureLayers::set_allocated_hallucinations(::SC2APIProtocol::ImageData* hallucinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hallucinations_);
  }
  if (hallucinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hallucinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hallucinations, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  hallucinations_ = hallucinations;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.hallucinations)
}

// optional .SC2APIProtocol.ImageData cloaked = 22;
inline bool FeatureLayers::_internal_has_cloaked() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || cloaked_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_cloaked() const {
  return _internal_has_cloaked();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_cloaked() const {
  const ::SC2APIProtocol::ImageData* p = cloaked_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::cloaked() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.cloaked)
  return _internal_cloaked();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_cloaked() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.cloaked)
  _has_bits_[0] &= ~0x00040000u;
  ::SC2APIProtocol::ImageData* temp = cloaked_;
  cloaked_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_cloaked() {
  _has_bits_[0] |= 0x00040000u;
  if (cloaked_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    cloaked_ = p;
  }
  return cloaked_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_cloaked() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.cloaked)
  return _internal_mutable_cloaked();
}
inline void FeatureLayers::set_allocated_cloaked(::SC2APIProtocol::ImageData* cloaked) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cloaked_);
  }
  if (cloaked) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cloaked = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cloaked, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  cloaked_ = cloaked;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.cloaked)
}

// optional .SC2APIProtocol.ImageData blip = 23;
inline bool FeatureLayers::_internal_has_blip() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || blip_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_blip() const {
  return _internal_has_blip();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_blip() const {
  const ::SC2APIProtocol::ImageData* p = blip_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::blip() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.blip)
  return _internal_blip();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_blip() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.blip)
  _has_bits_[0] &= ~0x00080000u;
  ::SC2APIProtocol::ImageData* temp = blip_;
  blip_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_blip() {
  _has_bits_[0] |= 0x00080000u;
  if (blip_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    blip_ = p;
  }
  return blip_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_blip() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.blip)
  return _internal_mutable_blip();
}
inline void FeatureLayers::set_allocated_blip(::SC2APIProtocol::ImageData* blip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(blip_);
  }
  if (blip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      blip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blip, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  blip_ = blip;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.blip)
}

// optional .SC2APIProtocol.ImageData buffs = 24;
inline bool FeatureLayers::_internal_has_buffs() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || buffs_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_buffs() const {
  return _internal_has_buffs();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_buffs() const {
  const ::SC2APIProtocol::ImageData* p = buffs_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::buffs() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.buffs)
  return _internal_buffs();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_buffs() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.buffs)
  _has_bits_[0] &= ~0x00100000u;
  ::SC2APIProtocol::ImageData* temp = buffs_;
  buffs_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_buffs() {
  _has_bits_[0] |= 0x00100000u;
  if (buffs_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    buffs_ = p;
  }
  return buffs_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_buffs() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.buffs)
  return _internal_mutable_buffs();
}
inline void FeatureLayers::set_allocated_buffs(::SC2APIProtocol::ImageData* buffs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buffs_);
  }
  if (buffs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buffs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffs, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  buffs_ = buffs;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.buffs)
}

// optional .SC2APIProtocol.ImageData buff_duration = 26;
inline bool FeatureLayers::_internal_has_buff_duration() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || buff_duration_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_buff_duration() const {
  return _internal_has_buff_duration();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_buff_duration() const {
  const ::SC2APIProtocol::ImageData* p = buff_duration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::buff_duration() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.buff_duration)
  return _internal_buff_duration();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_buff_duration() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.buff_duration)
  _has_bits_[0] &= ~0x00400000u;
  ::SC2APIProtocol::ImageData* temp = buff_duration_;
  buff_duration_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_buff_duration() {
  _has_bits_[0] |= 0x00400000u;
  if (buff_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    buff_duration_ = p;
  }
  return buff_duration_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_buff_duration() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.buff_duration)
  return _internal_mutable_buff_duration();
}
inline void FeatureLayers::set_allocated_buff_duration(::SC2APIProtocol::ImageData* buff_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buff_duration_);
  }
  if (buff_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buff_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buff_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  buff_duration_ = buff_duration;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.buff_duration)
}

// optional .SC2APIProtocol.ImageData active = 25;
inline bool FeatureLayers::_internal_has_active() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || active_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_active() const {
  return _internal_has_active();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_active() const {
  const ::SC2APIProtocol::ImageData* p = active_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::active() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.active)
  return _internal_active();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_active() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.active)
  _has_bits_[0] &= ~0x00200000u;
  ::SC2APIProtocol::ImageData* temp = active_;
  active_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_active() {
  _has_bits_[0] |= 0x00200000u;
  if (active_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    active_ = p;
  }
  return active_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_active() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.active)
  return _internal_mutable_active();
}
inline void FeatureLayers::set_allocated_active(::SC2APIProtocol::ImageData* active) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_);
  }
  if (active) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      active = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  active_ = active;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.active)
}

// optional .SC2APIProtocol.ImageData build_progress = 27;
inline bool FeatureLayers::_internal_has_build_progress() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || build_progress_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_build_progress() const {
  return _internal_has_build_progress();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_build_progress() const {
  const ::SC2APIProtocol::ImageData* p = build_progress_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::build_progress() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.build_progress)
  return _internal_build_progress();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_build_progress() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.build_progress)
  _has_bits_[0] &= ~0x00800000u;
  ::SC2APIProtocol::ImageData* temp = build_progress_;
  build_progress_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_build_progress() {
  _has_bits_[0] |= 0x00800000u;
  if (build_progress_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    build_progress_ = p;
  }
  return build_progress_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_build_progress() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.build_progress)
  return _internal_mutable_build_progress();
}
inline void FeatureLayers::set_allocated_build_progress(::SC2APIProtocol::ImageData* build_progress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(build_progress_);
  }
  if (build_progress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      build_progress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, build_progress, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  build_progress_ = build_progress;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.build_progress)
}

// optional .SC2APIProtocol.ImageData buildable = 28;
inline bool FeatureLayers::_internal_has_buildable() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || buildable_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_buildable() const {
  return _internal_has_buildable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_buildable() const {
  const ::SC2APIProtocol::ImageData* p = buildable_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::buildable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.buildable)
  return _internal_buildable();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_buildable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.buildable)
  _has_bits_[0] &= ~0x01000000u;
  ::SC2APIProtocol::ImageData* temp = buildable_;
  buildable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_buildable() {
  _has_bits_[0] |= 0x01000000u;
  if (buildable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    buildable_ = p;
  }
  return buildable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_buildable() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.buildable)
  return _internal_mutable_buildable();
}
inline void FeatureLayers::set_allocated_buildable(::SC2APIProtocol::ImageData* buildable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buildable_);
  }
  if (buildable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buildable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildable, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  buildable_ = buildable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.buildable)
}

// optional .SC2APIProtocol.ImageData pathable = 29;
inline bool FeatureLayers::_internal_has_pathable() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || pathable_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_pathable() const {
  return _internal_has_pathable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_pathable() const {
  const ::SC2APIProtocol::ImageData* p = pathable_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::pathable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.pathable)
  return _internal_pathable();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_pathable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.pathable)
  _has_bits_[0] &= ~0x02000000u;
  ::SC2APIProtocol::ImageData* temp = pathable_;
  pathable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_pathable() {
  _has_bits_[0] |= 0x02000000u;
  if (pathable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    pathable_ = p;
  }
  return pathable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_pathable() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.pathable)
  return _internal_mutable_pathable();
}
inline void FeatureLayers::set_allocated_pathable(::SC2APIProtocol::ImageData* pathable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathable_);
  }
  if (pathable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pathable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathable, submessage_arena);
    }
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  pathable_ = pathable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.pathable)
}

// optional .SC2APIProtocol.ImageData placeholder = 30;
inline bool FeatureLayers::_internal_has_placeholder() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || placeholder_ != nullptr);
  return value;
}
inline bool FeatureLayers::has_placeholder() const {
  return _internal_has_placeholder();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::_internal_placeholder() const {
  const ::SC2APIProtocol::ImageData* p = placeholder_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayers::placeholder() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayers.placeholder)
  return _internal_placeholder();
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::release_placeholder() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayers.placeholder)
  _has_bits_[0] &= ~0x04000000u;
  ::SC2APIProtocol::ImageData* temp = placeholder_;
  placeholder_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::_internal_mutable_placeholder() {
  _has_bits_[0] |= 0x04000000u;
  if (placeholder_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    placeholder_ = p;
  }
  return placeholder_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayers::mutable_placeholder() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayers.placeholder)
  return _internal_mutable_placeholder();
}
inline void FeatureLayers::set_allocated_placeholder(::SC2APIProtocol::ImageData* placeholder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(placeholder_);
  }
  if (placeholder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      placeholder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placeholder, submessage_arena);
    }
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  placeholder_ = placeholder;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayers.placeholder)
}

// -------------------------------------------------------------------

// FeatureLayersMinimap

// optional .SC2APIProtocol.ImageData height_map = 1;
inline bool FeatureLayersMinimap::_internal_has_height_map() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || height_map_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_height_map() const {
  return _internal_has_height_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_height_map() const {
  const ::SC2APIProtocol::ImageData* p = height_map_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::height_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.height_map)
  return _internal_height_map();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_height_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.height_map)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = height_map_;
  height_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_height_map() {
  _has_bits_[0] |= 0x00000001u;
  if (height_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    height_map_ = p;
  }
  return height_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_height_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.height_map)
  return _internal_mutable_height_map();
}
inline void FeatureLayersMinimap::set_allocated_height_map(::SC2APIProtocol::ImageData* height_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(height_map_);
  }
  if (height_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      height_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height_map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  height_map_ = height_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.height_map)
}

// optional .SC2APIProtocol.ImageData visibility_map = 2;
inline bool FeatureLayersMinimap::_internal_has_visibility_map() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || visibility_map_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_visibility_map() const {
  return _internal_has_visibility_map();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_visibility_map() const {
  const ::SC2APIProtocol::ImageData* p = visibility_map_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::visibility_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  return _internal_visibility_map();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_visibility_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = visibility_map_;
  visibility_map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_visibility_map() {
  _has_bits_[0] |= 0x00000002u;
  if (visibility_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    visibility_map_ = p;
  }
  return visibility_map_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_visibility_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
  return _internal_mutable_visibility_map();
}
inline void FeatureLayersMinimap::set_allocated_visibility_map(::SC2APIProtocol::ImageData* visibility_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(visibility_map_);
  }
  if (visibility_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      visibility_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visibility_map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  visibility_map_ = visibility_map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
}

// optional .SC2APIProtocol.ImageData creep = 3;
inline bool FeatureLayersMinimap::_internal_has_creep() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || creep_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_creep() const {
  return _internal_has_creep();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_creep() const {
  const ::SC2APIProtocol::ImageData* p = creep_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::creep() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.creep)
  return _internal_creep();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_creep() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.creep)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ImageData* temp = creep_;
  creep_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_creep() {
  _has_bits_[0] |= 0x00000004u;
  if (creep_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    creep_ = p;
  }
  return creep_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_creep() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.creep)
  return _internal_mutable_creep();
}
inline void FeatureLayersMinimap::set_allocated_creep(::SC2APIProtocol::ImageData* creep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(creep_);
  }
  if (creep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      creep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creep, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  creep_ = creep;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.creep)
}

// optional .SC2APIProtocol.ImageData camera = 4;
inline bool FeatureLayersMinimap::_internal_has_camera() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || camera_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_camera() const {
  return _internal_has_camera();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_camera() const {
  const ::SC2APIProtocol::ImageData* p = camera_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::camera() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.camera)
  return _internal_camera();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_camera() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.camera)
  _has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ImageData* temp = camera_;
  camera_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_camera() {
  _has_bits_[0] |= 0x00000008u;
  if (camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    camera_ = p;
  }
  return camera_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_camera() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.camera)
  return _internal_mutable_camera();
}
inline void FeatureLayersMinimap::set_allocated_camera(::SC2APIProtocol::ImageData* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.camera)
}

// optional .SC2APIProtocol.ImageData player_id = 5;
inline bool FeatureLayersMinimap::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || player_id_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_player_id() const {
  return _internal_has_player_id();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_player_id() const {
  const ::SC2APIProtocol::ImageData* p = player_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.player_id)
  return _internal_player_id();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_player_id() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.player_id)
  _has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ImageData* temp = player_id_;
  player_id_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_player_id() {
  _has_bits_[0] |= 0x00000010u;
  if (player_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    player_id_ = p;
  }
  return player_id_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_player_id() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.player_id)
  return _internal_mutable_player_id();
}
inline void FeatureLayersMinimap::set_allocated_player_id(::SC2APIProtocol::ImageData* player_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_id_);
  }
  if (player_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  player_id_ = player_id;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_id)
}

// optional .SC2APIProtocol.ImageData player_relative = 6;
inline bool FeatureLayersMinimap::_internal_has_player_relative() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || player_relative_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_player_relative() const {
  return _internal_has_player_relative();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_player_relative() const {
  const ::SC2APIProtocol::ImageData* p = player_relative_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::player_relative() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  return _internal_player_relative();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_player_relative() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  _has_bits_[0] &= ~0x00000020u;
  ::SC2APIProtocol::ImageData* temp = player_relative_;
  player_relative_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_player_relative() {
  _has_bits_[0] |= 0x00000020u;
  if (player_relative_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    player_relative_ = p;
  }
  return player_relative_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_player_relative() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.player_relative)
  return _internal_mutable_player_relative();
}
inline void FeatureLayersMinimap::set_allocated_player_relative(::SC2APIProtocol::ImageData* player_relative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_relative_);
  }
  if (player_relative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_relative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_relative, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  player_relative_ = player_relative;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.player_relative)
}

// optional .SC2APIProtocol.ImageData selected = 7;
inline bool FeatureLayersMinimap::_internal_has_selected() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || selected_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_selected() const {
  return _internal_has_selected();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_selected() const {
  const ::SC2APIProtocol::ImageData* p = selected_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::selected() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.selected)
  return _internal_selected();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_selected() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.selected)
  _has_bits_[0] &= ~0x00000040u;
  ::SC2APIProtocol::ImageData* temp = selected_;
  selected_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_selected() {
  _has_bits_[0] |= 0x00000040u;
  if (selected_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    selected_ = p;
  }
  return selected_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_selected() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.selected)
  return _internal_mutable_selected();
}
inline void FeatureLayersMinimap::set_allocated_selected(::SC2APIProtocol::ImageData* selected) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(selected_);
  }
  if (selected) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      selected = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  selected_ = selected;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.selected)
}

// optional .SC2APIProtocol.ImageData alerts = 9;
inline bool FeatureLayersMinimap::_internal_has_alerts() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || alerts_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_alerts() const {
  return _internal_has_alerts();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_alerts() const {
  const ::SC2APIProtocol::ImageData* p = alerts_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::alerts() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.alerts)
  return _internal_alerts();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_alerts() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.alerts)
  _has_bits_[0] &= ~0x00000100u;
  ::SC2APIProtocol::ImageData* temp = alerts_;
  alerts_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_alerts() {
  _has_bits_[0] |= 0x00000100u;
  if (alerts_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    alerts_ = p;
  }
  return alerts_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_alerts() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.alerts)
  return _internal_mutable_alerts();
}
inline void FeatureLayersMinimap::set_allocated_alerts(::SC2APIProtocol::ImageData* alerts) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alerts_);
  }
  if (alerts) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      alerts = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alerts, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  alerts_ = alerts;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.alerts)
}

// optional .SC2APIProtocol.ImageData buildable = 10;
inline bool FeatureLayersMinimap::_internal_has_buildable() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || buildable_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_buildable() const {
  return _internal_has_buildable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_buildable() const {
  const ::SC2APIProtocol::ImageData* p = buildable_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::buildable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.buildable)
  return _internal_buildable();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_buildable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.buildable)
  _has_bits_[0] &= ~0x00000200u;
  ::SC2APIProtocol::ImageData* temp = buildable_;
  buildable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_buildable() {
  _has_bits_[0] |= 0x00000200u;
  if (buildable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    buildable_ = p;
  }
  return buildable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_buildable() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.buildable)
  return _internal_mutable_buildable();
}
inline void FeatureLayersMinimap::set_allocated_buildable(::SC2APIProtocol::ImageData* buildable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buildable_);
  }
  if (buildable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buildable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buildable, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  buildable_ = buildable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.buildable)
}

// optional .SC2APIProtocol.ImageData pathable = 11;
inline bool FeatureLayersMinimap::_internal_has_pathable() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || pathable_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_pathable() const {
  return _internal_has_pathable();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_pathable() const {
  const ::SC2APIProtocol::ImageData* p = pathable_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::pathable() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.pathable)
  return _internal_pathable();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_pathable() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.pathable)
  _has_bits_[0] &= ~0x00000400u;
  ::SC2APIProtocol::ImageData* temp = pathable_;
  pathable_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_pathable() {
  _has_bits_[0] |= 0x00000400u;
  if (pathable_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    pathable_ = p;
  }
  return pathable_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_pathable() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.pathable)
  return _internal_mutable_pathable();
}
inline void FeatureLayersMinimap::set_allocated_pathable(::SC2APIProtocol::ImageData* pathable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathable_);
  }
  if (pathable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pathable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathable, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  pathable_ = pathable;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.pathable)
}

// optional .SC2APIProtocol.ImageData unit_type = 8;
inline bool FeatureLayersMinimap::_internal_has_unit_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || unit_type_ != nullptr);
  return value;
}
inline bool FeatureLayersMinimap::has_unit_type() const {
  return _internal_has_unit_type();
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::_internal_unit_type() const {
  const ::SC2APIProtocol::ImageData* p = unit_type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& FeatureLayersMinimap::unit_type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  return _internal_unit_type();
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::release_unit_type() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  _has_bits_[0] &= ~0x00000080u;
  ::SC2APIProtocol::ImageData* temp = unit_type_;
  unit_type_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::_internal_mutable_unit_type() {
  _has_bits_[0] |= 0x00000080u;
  if (unit_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    unit_type_ = p;
  }
  return unit_type_;
}
inline ::SC2APIProtocol::ImageData* FeatureLayersMinimap::mutable_unit_type() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.FeatureLayersMinimap.unit_type)
  return _internal_mutable_unit_type();
}
inline void FeatureLayersMinimap::set_allocated_unit_type(::SC2APIProtocol::ImageData* unit_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(unit_type_);
  }
  if (unit_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  unit_type_ = unit_type;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.FeatureLayersMinimap.unit_type)
}

// -------------------------------------------------------------------

// ObservationRender

// optional .SC2APIProtocol.ImageData map = 1;
inline bool ObservationRender::_internal_has_map() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || map_ != nullptr);
  return value;
}
inline bool ObservationRender::has_map() const {
  return _internal_has_map();
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::_internal_map() const {
  const ::SC2APIProtocol::ImageData* p = map_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRender.map)
  return _internal_map();
}
inline ::SC2APIProtocol::ImageData* ObservationRender::release_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRender.map)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ImageData* temp = map_;
  map_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::_internal_mutable_map() {
  _has_bits_[0] |= 0x00000001u;
  if (map_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    map_ = p;
  }
  return map_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::mutable_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRender.map)
  return _internal_mutable_map();
}
inline void ObservationRender::set_allocated_map(::SC2APIProtocol::ImageData* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(map_);
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  map_ = map;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRender.map)
}

// optional .SC2APIProtocol.ImageData minimap = 2;
inline bool ObservationRender::_internal_has_minimap() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || minimap_ != nullptr);
  return value;
}
inline bool ObservationRender::has_minimap() const {
  return _internal_has_minimap();
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::_internal_minimap() const {
  const ::SC2APIProtocol::ImageData* p = minimap_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ImageData*>(
      &::SC2APIProtocol::_ImageData_default_instance_);
}
inline const ::SC2APIProtocol::ImageData& ObservationRender::minimap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObservationRender.minimap)
  return _internal_minimap();
}
inline ::SC2APIProtocol::ImageData* ObservationRender::release_minimap() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObservationRender.minimap)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ImageData* temp = minimap_;
  minimap_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::_internal_mutable_minimap() {
  _has_bits_[0] |= 0x00000002u;
  if (minimap_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ImageData>(GetArenaNoVirtual());
    minimap_ = p;
  }
  return minimap_;
}
inline ::SC2APIProtocol::ImageData* ObservationRender::mutable_minimap() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObservationRender.minimap)
  return _internal_mutable_minimap();
}
inline void ObservationRender::set_allocated_minimap(::SC2APIProtocol::ImageData* minimap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimap_);
  }
  if (minimap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      minimap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimap, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  minimap_ = minimap;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ObservationRender.minimap)
}

// -------------------------------------------------------------------

// ActionSpatial

// optional .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;
inline bool ActionSpatial::_internal_has_unit_command() const {
  return action_case() == kUnitCommand;
}
inline bool ActionSpatial::has_unit_command() const {
  return _internal_has_unit_command();
}
inline void ActionSpatial::set_has_unit_command() {
  _oneof_case_[0] = kUnitCommand;
}
inline void ActionSpatial::clear_unit_command() {
  if (_internal_has_unit_command()) {
    delete action_.unit_command_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::release_unit_command() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_command)
  if (_internal_has_unit_command()) {
    clear_has_action();
      ::SC2APIProtocol::ActionSpatialUnitCommand* temp = action_.unit_command_;
    action_.unit_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialUnitCommand& ActionSpatial::_internal_unit_command() const {
  return _internal_has_unit_command()
      ? *action_.unit_command_
      : *reinterpret_cast< ::SC2APIProtocol::ActionSpatialUnitCommand*>(&::SC2APIProtocol::_ActionSpatialUnitCommand_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialUnitCommand& ActionSpatial::unit_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_command)
  return _internal_unit_command();
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::_internal_mutable_unit_command() {
  if (!_internal_has_unit_command()) {
    clear_action();
    set_has_unit_command();
    action_.unit_command_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialUnitCommand >(
        GetArenaNoVirtual());
  }
  return action_.unit_command_;
}
inline ::SC2APIProtocol::ActionSpatialUnitCommand* ActionSpatial::mutable_unit_command() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_command)
  return _internal_mutable_unit_command();
}

// optional .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;
inline bool ActionSpatial::_internal_has_camera_move() const {
  return action_case() == kCameraMove;
}
inline bool ActionSpatial::has_camera_move() const {
  return _internal_has_camera_move();
}
inline void ActionSpatial::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ActionSpatial::clear_camera_move() {
  if (_internal_has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::release_camera_move() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.camera_move)
  if (_internal_has_camera_move()) {
    clear_has_action();
      ::SC2APIProtocol::ActionSpatialCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialCameraMove& ActionSpatial::_internal_camera_move() const {
  return _internal_has_camera_move()
      ? *action_.camera_move_
      : *reinterpret_cast< ::SC2APIProtocol::ActionSpatialCameraMove*>(&::SC2APIProtocol::_ActionSpatialCameraMove_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialCameraMove& ActionSpatial::camera_move() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.camera_move)
  return _internal_camera_move();
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::_internal_mutable_camera_move() {
  if (!_internal_has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialCameraMove >(
        GetArenaNoVirtual());
  }
  return action_.camera_move_;
}
inline ::SC2APIProtocol::ActionSpatialCameraMove* ActionSpatial::mutable_camera_move() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.camera_move)
  return _internal_mutable_camera_move();
}

// optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;
inline bool ActionSpatial::_internal_has_unit_selection_point() const {
  return action_case() == kUnitSelectionPoint;
}
inline bool ActionSpatial::has_unit_selection_point() const {
  return _internal_has_unit_selection_point();
}
inline void ActionSpatial::set_has_unit_selection_point() {
  _oneof_case_[0] = kUnitSelectionPoint;
}
inline void ActionSpatial::clear_unit_selection_point() {
  if (_internal_has_unit_selection_point()) {
    delete action_.unit_selection_point_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::release_unit_selection_point() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_selection_point)
  if (_internal_has_unit_selection_point()) {
    clear_has_action();
      ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* temp = action_.unit_selection_point_;
    action_.unit_selection_point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& ActionSpatial::_internal_unit_selection_point() const {
  return _internal_has_unit_selection_point()
      ? *action_.unit_selection_point_
      : *reinterpret_cast< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint*>(&::SC2APIProtocol::_ActionSpatialUnitSelectionPoint_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionPoint& ActionSpatial::unit_selection_point() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_selection_point)
  return _internal_unit_selection_point();
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::_internal_mutable_unit_selection_point() {
  if (!_internal_has_unit_selection_point()) {
    clear_action();
    set_has_unit_selection_point();
    action_.unit_selection_point_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint >(
        GetArenaNoVirtual());
  }
  return action_.unit_selection_point_;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint* ActionSpatial::mutable_unit_selection_point() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_selection_point)
  return _internal_mutable_unit_selection_point();
}

// optional .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;
inline bool ActionSpatial::_internal_has_unit_selection_rect() const {
  return action_case() == kUnitSelectionRect;
}
inline bool ActionSpatial::has_unit_selection_rect() const {
  return _internal_has_unit_selection_rect();
}
inline void ActionSpatial::set_has_unit_selection_rect() {
  _oneof_case_[0] = kUnitSelectionRect;
}
inline void ActionSpatial::clear_unit_selection_rect() {
  if (_internal_has_unit_selection_rect()) {
    delete action_.unit_selection_rect_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::release_unit_selection_rect() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  if (_internal_has_unit_selection_rect()) {
    clear_has_action();
      ::SC2APIProtocol::ActionSpatialUnitSelectionRect* temp = action_.unit_selection_rect_;
    action_.unit_selection_rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& ActionSpatial::_internal_unit_selection_rect() const {
  return _internal_has_unit_selection_rect()
      ? *action_.unit_selection_rect_
      : *reinterpret_cast< ::SC2APIProtocol::ActionSpatialUnitSelectionRect*>(&::SC2APIProtocol::_ActionSpatialUnitSelectionRect_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatialUnitSelectionRect& ActionSpatial::unit_selection_rect() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  return _internal_unit_selection_rect();
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::_internal_mutable_unit_selection_rect() {
  if (!_internal_has_unit_selection_rect()) {
    clear_action();
    set_has_unit_selection_rect();
    action_.unit_selection_rect_ = CreateMaybeMessage< ::SC2APIProtocol::ActionSpatialUnitSelectionRect >(
        GetArenaNoVirtual());
  }
  return action_.unit_selection_rect_;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionRect* ActionSpatial::mutable_unit_selection_rect() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatial.unit_selection_rect)
  return _internal_mutable_unit_selection_rect();
}

inline bool ActionSpatial::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionSpatial::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionSpatial::ActionCase ActionSpatial::action_case() const {
  return ActionSpatial::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialUnitCommand

// optional int32 ability_id = 1;
inline bool ActionSpatialUnitCommand::_internal_has_ability_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionSpatialUnitCommand::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void ActionSpatialUnitCommand::clear_ability_id() {
  ability_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionSpatialUnitCommand::_internal_ability_id() const {
  return ability_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ActionSpatialUnitCommand::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.ability_id)
  return _internal_ability_id();
}
inline void ActionSpatialUnitCommand::_internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  ability_id_ = value;
}
inline void ActionSpatialUnitCommand::set_ability_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitCommand.ability_id)
}

// optional .SC2APIProtocol.PointI target_screen_coord = 2;
inline bool ActionSpatialUnitCommand::_internal_has_target_screen_coord() const {
  return target_case() == kTargetScreenCoord;
}
inline bool ActionSpatialUnitCommand::has_target_screen_coord() const {
  return _internal_has_target_screen_coord();
}
inline void ActionSpatialUnitCommand::set_has_target_screen_coord() {
  _oneof_case_[0] = kTargetScreenCoord;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::release_target_screen_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  if (_internal_has_target_screen_coord()) {
    clear_has_target();
      ::SC2APIProtocol::PointI* temp = target_.target_screen_coord_;
    target_.target_screen_coord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::_internal_target_screen_coord() const {
  return _internal_has_target_screen_coord()
      ? *target_.target_screen_coord_
      : *reinterpret_cast< ::SC2APIProtocol::PointI*>(&::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::target_screen_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return _internal_target_screen_coord();
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::_internal_mutable_target_screen_coord() {
  if (!_internal_has_target_screen_coord()) {
    clear_target();
    set_has_target_screen_coord();
    target_.target_screen_coord_ = CreateMaybeMessage< ::SC2APIProtocol::PointI >(
        GetArenaNoVirtual());
  }
  return target_.target_screen_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_screen_coord() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
  return _internal_mutable_target_screen_coord();
}

// optional .SC2APIProtocol.PointI target_minimap_coord = 3;
inline bool ActionSpatialUnitCommand::_internal_has_target_minimap_coord() const {
  return target_case() == kTargetMinimapCoord;
}
inline bool ActionSpatialUnitCommand::has_target_minimap_coord() const {
  return _internal_has_target_minimap_coord();
}
inline void ActionSpatialUnitCommand::set_has_target_minimap_coord() {
  _oneof_case_[0] = kTargetMinimapCoord;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::release_target_minimap_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  if (_internal_has_target_minimap_coord()) {
    clear_has_target();
      ::SC2APIProtocol::PointI* temp = target_.target_minimap_coord_;
    target_.target_minimap_coord_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::_internal_target_minimap_coord() const {
  return _internal_has_target_minimap_coord()
      ? *target_.target_minimap_coord_
      : *reinterpret_cast< ::SC2APIProtocol::PointI*>(&::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitCommand::target_minimap_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return _internal_target_minimap_coord();
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::_internal_mutable_target_minimap_coord() {
  if (!_internal_has_target_minimap_coord()) {
    clear_target();
    set_has_target_minimap_coord();
    target_.target_minimap_coord_ = CreateMaybeMessage< ::SC2APIProtocol::PointI >(
        GetArenaNoVirtual());
  }
  return target_.target_minimap_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitCommand::mutable_target_minimap_coord() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
  return _internal_mutable_target_minimap_coord();
}

// optional bool queue_command = 4;
inline bool ActionSpatialUnitCommand::_internal_has_queue_command() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionSpatialUnitCommand::has_queue_command() const {
  return _internal_has_queue_command();
}
inline void ActionSpatialUnitCommand::clear_queue_command() {
  queue_command_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ActionSpatialUnitCommand::_internal_queue_command() const {
  return queue_command_;
}
inline bool ActionSpatialUnitCommand::queue_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitCommand.queue_command)
  return _internal_queue_command();
}
inline void ActionSpatialUnitCommand::_internal_set_queue_command(bool value) {
  _has_bits_[0] |= 0x00000002u;
  queue_command_ = value;
}
inline void ActionSpatialUnitCommand::set_queue_command(bool value) {
  _internal_set_queue_command(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitCommand.queue_command)
}

inline bool ActionSpatialUnitCommand::has_target() const {
  return target_case() != TARGET_NOT_SET;
}
inline void ActionSpatialUnitCommand::clear_has_target() {
  _oneof_case_[0] = TARGET_NOT_SET;
}
inline ActionSpatialUnitCommand::TargetCase ActionSpatialUnitCommand::target_case() const {
  return ActionSpatialUnitCommand::TargetCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpatialCameraMove

// optional .SC2APIProtocol.PointI center_minimap = 1;
inline bool ActionSpatialCameraMove::_internal_has_center_minimap() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || center_minimap_ != nullptr);
  return value;
}
inline bool ActionSpatialCameraMove::has_center_minimap() const {
  return _internal_has_center_minimap();
}
inline const ::SC2APIProtocol::PointI& ActionSpatialCameraMove::_internal_center_minimap() const {
  const ::SC2APIProtocol::PointI* p = center_minimap_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::PointI*>(
      &::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialCameraMove::center_minimap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  return _internal_center_minimap();
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::release_center_minimap() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PointI* temp = center_minimap_;
  center_minimap_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::_internal_mutable_center_minimap() {
  _has_bits_[0] |= 0x00000001u;
  if (center_minimap_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PointI>(GetArenaNoVirtual());
    center_minimap_ = p;
  }
  return center_minimap_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialCameraMove::mutable_center_minimap() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
  return _internal_mutable_center_minimap();
}
inline void ActionSpatialCameraMove::set_allocated_center_minimap(::SC2APIProtocol::PointI* center_minimap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_minimap_);
  }
  if (center_minimap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      center_minimap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_minimap, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  center_minimap_ = center_minimap;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionPoint

// optional .SC2APIProtocol.PointI selection_screen_coord = 1;
inline bool ActionSpatialUnitSelectionPoint::_internal_has_selection_screen_coord() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || selection_screen_coord_ != nullptr);
  return value;
}
inline bool ActionSpatialUnitSelectionPoint::has_selection_screen_coord() const {
  return _internal_has_selection_screen_coord();
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitSelectionPoint::_internal_selection_screen_coord() const {
  const ::SC2APIProtocol::PointI* p = selection_screen_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::PointI*>(
      &::SC2APIProtocol::_PointI_default_instance_);
}
inline const ::SC2APIProtocol::PointI& ActionSpatialUnitSelectionPoint::selection_screen_coord() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return _internal_selection_screen_coord();
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::release_selection_screen_coord() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PointI* temp = selection_screen_coord_;
  selection_screen_coord_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::_internal_mutable_selection_screen_coord() {
  _has_bits_[0] |= 0x00000001u;
  if (selection_screen_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PointI>(GetArenaNoVirtual());
    selection_screen_coord_ = p;
  }
  return selection_screen_coord_;
}
inline ::SC2APIProtocol::PointI* ActionSpatialUnitSelectionPoint::mutable_selection_screen_coord() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
  return _internal_mutable_selection_screen_coord();
}
inline void ActionSpatialUnitSelectionPoint::set_allocated_selection_screen_coord(::SC2APIProtocol::PointI* selection_screen_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(selection_screen_coord_);
  }
  if (selection_screen_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      selection_screen_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selection_screen_coord, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  selection_screen_coord_ = selection_screen_coord;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
}

// optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;
inline bool ActionSpatialUnitSelectionPoint::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionSpatialUnitSelectionPoint::has_type() const {
  return _internal_has_type();
}
inline void ActionSpatialUnitSelectionPoint::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint::_internal_type() const {
  return static_cast< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type >(type_);
}
inline ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type ActionSpatialUnitSelectionPoint::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionPoint.type)
  return _internal_type();
}
inline void ActionSpatialUnitSelectionPoint::_internal_set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value) {
  assert(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void ActionSpatialUnitSelectionPoint::set_type(::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitSelectionPoint.type)
}

// -------------------------------------------------------------------

// ActionSpatialUnitSelectionRect

// repeated .SC2APIProtocol.RectangleI selection_screen_coord = 1;
inline int ActionSpatialUnitSelectionRect::_internal_selection_screen_coord_size() const {
  return selection_screen_coord_.size();
}
inline int ActionSpatialUnitSelectionRect::selection_screen_coord_size() const {
  return _internal_selection_screen_coord_size();
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::mutable_selection_screen_coord(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >*
ActionSpatialUnitSelectionRect::mutable_selection_screen_coord() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return &selection_screen_coord_;
}
inline const ::SC2APIProtocol::RectangleI& ActionSpatialUnitSelectionRect::_internal_selection_screen_coord(int index) const {
  return selection_screen_coord_.Get(index);
}
inline const ::SC2APIProtocol::RectangleI& ActionSpatialUnitSelectionRect::selection_screen_coord(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return _internal_selection_screen_coord(index);
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::_internal_add_selection_screen_coord() {
  return selection_screen_coord_.Add();
}
inline ::SC2APIProtocol::RectangleI* ActionSpatialUnitSelectionRect::add_selection_screen_coord() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return _internal_add_selection_screen_coord();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::RectangleI >&
ActionSpatialUnitSelectionRect::selection_screen_coord() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
  return selection_screen_coord_;
}

// optional bool selection_add = 2;
inline bool ActionSpatialUnitSelectionRect::_internal_has_selection_add() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionSpatialUnitSelectionRect::has_selection_add() const {
  return _internal_has_selection_add();
}
inline void ActionSpatialUnitSelectionRect::clear_selection_add() {
  selection_add_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ActionSpatialUnitSelectionRect::_internal_selection_add() const {
  return selection_add_;
}
inline bool ActionSpatialUnitSelectionRect::selection_add() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_add)
  return _internal_selection_add();
}
inline void ActionSpatialUnitSelectionRect::_internal_set_selection_add(bool value) {
  _has_bits_[0] |= 0x00000001u;
  selection_add_ = value;
}
inline void ActionSpatialUnitSelectionRect::set_selection_add(bool value) {
  _internal_set_selection_add(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_add)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type>() {
  return ::SC2APIProtocol::ActionSpatialUnitSelectionPoint_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fspatial_2eproto
