// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/sc2api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fsc2api_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fsc2api_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
#include "s2clientprotocol/data.pb.h"
#include "s2clientprotocol/debug.pb.h"
#include "s2clientprotocol/error.pb.h"
#include "s2clientprotocol/query.pb.h"
#include "s2clientprotocol/raw.pb.h"
#include "s2clientprotocol/score.pb.h"
#include "s2clientprotocol/spatial.pb.h"
#include "s2clientprotocol/ui.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fsc2api_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_s2clientprotocol_2fsc2api_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[63]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fsc2api_2eproto;
namespace SC2APIProtocol {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionChat;
class ActionChatDefaultTypeInternal;
extern ActionChatDefaultTypeInternal _ActionChat_default_instance_;
class ActionError;
class ActionErrorDefaultTypeInternal;
extern ActionErrorDefaultTypeInternal _ActionError_default_instance_;
class ActionObserverCameraFollowPlayer;
class ActionObserverCameraFollowPlayerDefaultTypeInternal;
extern ActionObserverCameraFollowPlayerDefaultTypeInternal _ActionObserverCameraFollowPlayer_default_instance_;
class ActionObserverCameraFollowUnits;
class ActionObserverCameraFollowUnitsDefaultTypeInternal;
extern ActionObserverCameraFollowUnitsDefaultTypeInternal _ActionObserverCameraFollowUnits_default_instance_;
class ActionObserverCameraMove;
class ActionObserverCameraMoveDefaultTypeInternal;
extern ActionObserverCameraMoveDefaultTypeInternal _ActionObserverCameraMove_default_instance_;
class ActionObserverPlayerPerspective;
class ActionObserverPlayerPerspectiveDefaultTypeInternal;
extern ActionObserverPlayerPerspectiveDefaultTypeInternal _ActionObserverPlayerPerspective_default_instance_;
class ChatReceived;
class ChatReceivedDefaultTypeInternal;
extern ChatReceivedDefaultTypeInternal _ChatReceived_default_instance_;
class InterfaceOptions;
class InterfaceOptionsDefaultTypeInternal;
extern InterfaceOptionsDefaultTypeInternal _InterfaceOptions_default_instance_;
class LocalMap;
class LocalMapDefaultTypeInternal;
extern LocalMapDefaultTypeInternal _LocalMap_default_instance_;
class Observation;
class ObservationDefaultTypeInternal;
extern ObservationDefaultTypeInternal _Observation_default_instance_;
class ObserverAction;
class ObserverActionDefaultTypeInternal;
extern ObserverActionDefaultTypeInternal _ObserverAction_default_instance_;
class PlayerCommon;
class PlayerCommonDefaultTypeInternal;
extern PlayerCommonDefaultTypeInternal _PlayerCommon_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerInfoExtra;
class PlayerInfoExtraDefaultTypeInternal;
extern PlayerInfoExtraDefaultTypeInternal _PlayerInfoExtra_default_instance_;
class PlayerResult;
class PlayerResultDefaultTypeInternal;
extern PlayerResultDefaultTypeInternal _PlayerResult_default_instance_;
class PlayerSetup;
class PlayerSetupDefaultTypeInternal;
extern PlayerSetupDefaultTypeInternal _PlayerSetup_default_instance_;
class PortSet;
class PortSetDefaultTypeInternal;
extern PortSetDefaultTypeInternal _PortSet_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestAction;
class RequestActionDefaultTypeInternal;
extern RequestActionDefaultTypeInternal _RequestAction_default_instance_;
class RequestAvailableMaps;
class RequestAvailableMapsDefaultTypeInternal;
extern RequestAvailableMapsDefaultTypeInternal _RequestAvailableMaps_default_instance_;
class RequestCreateGame;
class RequestCreateGameDefaultTypeInternal;
extern RequestCreateGameDefaultTypeInternal _RequestCreateGame_default_instance_;
class RequestData;
class RequestDataDefaultTypeInternal;
extern RequestDataDefaultTypeInternal _RequestData_default_instance_;
class RequestDebug;
class RequestDebugDefaultTypeInternal;
extern RequestDebugDefaultTypeInternal _RequestDebug_default_instance_;
class RequestGameInfo;
class RequestGameInfoDefaultTypeInternal;
extern RequestGameInfoDefaultTypeInternal _RequestGameInfo_default_instance_;
class RequestJoinGame;
class RequestJoinGameDefaultTypeInternal;
extern RequestJoinGameDefaultTypeInternal _RequestJoinGame_default_instance_;
class RequestLeaveGame;
class RequestLeaveGameDefaultTypeInternal;
extern RequestLeaveGameDefaultTypeInternal _RequestLeaveGame_default_instance_;
class RequestMapCommand;
class RequestMapCommandDefaultTypeInternal;
extern RequestMapCommandDefaultTypeInternal _RequestMapCommand_default_instance_;
class RequestObservation;
class RequestObservationDefaultTypeInternal;
extern RequestObservationDefaultTypeInternal _RequestObservation_default_instance_;
class RequestObserverAction;
class RequestObserverActionDefaultTypeInternal;
extern RequestObserverActionDefaultTypeInternal _RequestObserverAction_default_instance_;
class RequestPing;
class RequestPingDefaultTypeInternal;
extern RequestPingDefaultTypeInternal _RequestPing_default_instance_;
class RequestQuickLoad;
class RequestQuickLoadDefaultTypeInternal;
extern RequestQuickLoadDefaultTypeInternal _RequestQuickLoad_default_instance_;
class RequestQuickSave;
class RequestQuickSaveDefaultTypeInternal;
extern RequestQuickSaveDefaultTypeInternal _RequestQuickSave_default_instance_;
class RequestQuit;
class RequestQuitDefaultTypeInternal;
extern RequestQuitDefaultTypeInternal _RequestQuit_default_instance_;
class RequestReplayInfo;
class RequestReplayInfoDefaultTypeInternal;
extern RequestReplayInfoDefaultTypeInternal _RequestReplayInfo_default_instance_;
class RequestRestartGame;
class RequestRestartGameDefaultTypeInternal;
extern RequestRestartGameDefaultTypeInternal _RequestRestartGame_default_instance_;
class RequestSaveMap;
class RequestSaveMapDefaultTypeInternal;
extern RequestSaveMapDefaultTypeInternal _RequestSaveMap_default_instance_;
class RequestSaveReplay;
class RequestSaveReplayDefaultTypeInternal;
extern RequestSaveReplayDefaultTypeInternal _RequestSaveReplay_default_instance_;
class RequestStartReplay;
class RequestStartReplayDefaultTypeInternal;
extern RequestStartReplayDefaultTypeInternal _RequestStartReplay_default_instance_;
class RequestStep;
class RequestStepDefaultTypeInternal;
extern RequestStepDefaultTypeInternal _RequestStep_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseAction;
class ResponseActionDefaultTypeInternal;
extern ResponseActionDefaultTypeInternal _ResponseAction_default_instance_;
class ResponseAvailableMaps;
class ResponseAvailableMapsDefaultTypeInternal;
extern ResponseAvailableMapsDefaultTypeInternal _ResponseAvailableMaps_default_instance_;
class ResponseCreateGame;
class ResponseCreateGameDefaultTypeInternal;
extern ResponseCreateGameDefaultTypeInternal _ResponseCreateGame_default_instance_;
class ResponseData;
class ResponseDataDefaultTypeInternal;
extern ResponseDataDefaultTypeInternal _ResponseData_default_instance_;
class ResponseDebug;
class ResponseDebugDefaultTypeInternal;
extern ResponseDebugDefaultTypeInternal _ResponseDebug_default_instance_;
class ResponseGameInfo;
class ResponseGameInfoDefaultTypeInternal;
extern ResponseGameInfoDefaultTypeInternal _ResponseGameInfo_default_instance_;
class ResponseJoinGame;
class ResponseJoinGameDefaultTypeInternal;
extern ResponseJoinGameDefaultTypeInternal _ResponseJoinGame_default_instance_;
class ResponseLeaveGame;
class ResponseLeaveGameDefaultTypeInternal;
extern ResponseLeaveGameDefaultTypeInternal _ResponseLeaveGame_default_instance_;
class ResponseMapCommand;
class ResponseMapCommandDefaultTypeInternal;
extern ResponseMapCommandDefaultTypeInternal _ResponseMapCommand_default_instance_;
class ResponseObservation;
class ResponseObservationDefaultTypeInternal;
extern ResponseObservationDefaultTypeInternal _ResponseObservation_default_instance_;
class ResponseObserverAction;
class ResponseObserverActionDefaultTypeInternal;
extern ResponseObserverActionDefaultTypeInternal _ResponseObserverAction_default_instance_;
class ResponsePing;
class ResponsePingDefaultTypeInternal;
extern ResponsePingDefaultTypeInternal _ResponsePing_default_instance_;
class ResponseQuickLoad;
class ResponseQuickLoadDefaultTypeInternal;
extern ResponseQuickLoadDefaultTypeInternal _ResponseQuickLoad_default_instance_;
class ResponseQuickSave;
class ResponseQuickSaveDefaultTypeInternal;
extern ResponseQuickSaveDefaultTypeInternal _ResponseQuickSave_default_instance_;
class ResponseQuit;
class ResponseQuitDefaultTypeInternal;
extern ResponseQuitDefaultTypeInternal _ResponseQuit_default_instance_;
class ResponseReplayInfo;
class ResponseReplayInfoDefaultTypeInternal;
extern ResponseReplayInfoDefaultTypeInternal _ResponseReplayInfo_default_instance_;
class ResponseRestartGame;
class ResponseRestartGameDefaultTypeInternal;
extern ResponseRestartGameDefaultTypeInternal _ResponseRestartGame_default_instance_;
class ResponseSaveMap;
class ResponseSaveMapDefaultTypeInternal;
extern ResponseSaveMapDefaultTypeInternal _ResponseSaveMap_default_instance_;
class ResponseSaveReplay;
class ResponseSaveReplayDefaultTypeInternal;
extern ResponseSaveReplayDefaultTypeInternal _ResponseSaveReplay_default_instance_;
class ResponseStartReplay;
class ResponseStartReplayDefaultTypeInternal;
extern ResponseStartReplayDefaultTypeInternal _ResponseStartReplay_default_instance_;
class ResponseStep;
class ResponseStepDefaultTypeInternal;
extern ResponseStepDefaultTypeInternal _ResponseStep_default_instance_;
class SpatialCameraSetup;
class SpatialCameraSetupDefaultTypeInternal;
extern SpatialCameraSetupDefaultTypeInternal _SpatialCameraSetup_default_instance_;
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::SC2APIProtocol::Action* Arena::CreateMaybeMessage<::SC2APIProtocol::Action>(Arena*);
template<> ::SC2APIProtocol::ActionChat* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionChat>(Arena*);
template<> ::SC2APIProtocol::ActionError* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionError>(Arena*);
template<> ::SC2APIProtocol::ActionObserverCameraFollowPlayer* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverCameraFollowPlayer>(Arena*);
template<> ::SC2APIProtocol::ActionObserverCameraFollowUnits* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverCameraFollowUnits>(Arena*);
template<> ::SC2APIProtocol::ActionObserverCameraMove* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverCameraMove>(Arena*);
template<> ::SC2APIProtocol::ActionObserverPlayerPerspective* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverPlayerPerspective>(Arena*);
template<> ::SC2APIProtocol::ChatReceived* Arena::CreateMaybeMessage<::SC2APIProtocol::ChatReceived>(Arena*);
template<> ::SC2APIProtocol::InterfaceOptions* Arena::CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(Arena*);
template<> ::SC2APIProtocol::LocalMap* Arena::CreateMaybeMessage<::SC2APIProtocol::LocalMap>(Arena*);
template<> ::SC2APIProtocol::Observation* Arena::CreateMaybeMessage<::SC2APIProtocol::Observation>(Arena*);
template<> ::SC2APIProtocol::ObserverAction* Arena::CreateMaybeMessage<::SC2APIProtocol::ObserverAction>(Arena*);
template<> ::SC2APIProtocol::PlayerCommon* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerCommon>(Arena*);
template<> ::SC2APIProtocol::PlayerInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerInfo>(Arena*);
template<> ::SC2APIProtocol::PlayerInfoExtra* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerInfoExtra>(Arena*);
template<> ::SC2APIProtocol::PlayerResult* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerResult>(Arena*);
template<> ::SC2APIProtocol::PlayerSetup* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerSetup>(Arena*);
template<> ::SC2APIProtocol::PortSet* Arena::CreateMaybeMessage<::SC2APIProtocol::PortSet>(Arena*);
template<> ::SC2APIProtocol::Request* Arena::CreateMaybeMessage<::SC2APIProtocol::Request>(Arena*);
template<> ::SC2APIProtocol::RequestAction* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestAction>(Arena*);
template<> ::SC2APIProtocol::RequestAvailableMaps* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestAvailableMaps>(Arena*);
template<> ::SC2APIProtocol::RequestCreateGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestCreateGame>(Arena*);
template<> ::SC2APIProtocol::RequestData* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestData>(Arena*);
template<> ::SC2APIProtocol::RequestDebug* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestDebug>(Arena*);
template<> ::SC2APIProtocol::RequestGameInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestGameInfo>(Arena*);
template<> ::SC2APIProtocol::RequestJoinGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestJoinGame>(Arena*);
template<> ::SC2APIProtocol::RequestLeaveGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestLeaveGame>(Arena*);
template<> ::SC2APIProtocol::RequestMapCommand* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestMapCommand>(Arena*);
template<> ::SC2APIProtocol::RequestObservation* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestObservation>(Arena*);
template<> ::SC2APIProtocol::RequestObserverAction* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestObserverAction>(Arena*);
template<> ::SC2APIProtocol::RequestPing* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestPing>(Arena*);
template<> ::SC2APIProtocol::RequestQuickLoad* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestQuickLoad>(Arena*);
template<> ::SC2APIProtocol::RequestQuickSave* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestQuickSave>(Arena*);
template<> ::SC2APIProtocol::RequestQuit* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestQuit>(Arena*);
template<> ::SC2APIProtocol::RequestReplayInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestReplayInfo>(Arena*);
template<> ::SC2APIProtocol::RequestRestartGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestRestartGame>(Arena*);
template<> ::SC2APIProtocol::RequestSaveMap* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestSaveMap>(Arena*);
template<> ::SC2APIProtocol::RequestSaveReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestSaveReplay>(Arena*);
template<> ::SC2APIProtocol::RequestStartReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestStartReplay>(Arena*);
template<> ::SC2APIProtocol::RequestStep* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestStep>(Arena*);
template<> ::SC2APIProtocol::Response* Arena::CreateMaybeMessage<::SC2APIProtocol::Response>(Arena*);
template<> ::SC2APIProtocol::ResponseAction* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseAction>(Arena*);
template<> ::SC2APIProtocol::ResponseAvailableMaps* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseAvailableMaps>(Arena*);
template<> ::SC2APIProtocol::ResponseCreateGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseCreateGame>(Arena*);
template<> ::SC2APIProtocol::ResponseData* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseData>(Arena*);
template<> ::SC2APIProtocol::ResponseDebug* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseDebug>(Arena*);
template<> ::SC2APIProtocol::ResponseGameInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseGameInfo>(Arena*);
template<> ::SC2APIProtocol::ResponseJoinGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseJoinGame>(Arena*);
template<> ::SC2APIProtocol::ResponseLeaveGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseLeaveGame>(Arena*);
template<> ::SC2APIProtocol::ResponseMapCommand* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseMapCommand>(Arena*);
template<> ::SC2APIProtocol::ResponseObservation* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseObservation>(Arena*);
template<> ::SC2APIProtocol::ResponseObserverAction* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseObserverAction>(Arena*);
template<> ::SC2APIProtocol::ResponsePing* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponsePing>(Arena*);
template<> ::SC2APIProtocol::ResponseQuickLoad* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseQuickLoad>(Arena*);
template<> ::SC2APIProtocol::ResponseQuickSave* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseQuickSave>(Arena*);
template<> ::SC2APIProtocol::ResponseQuit* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseQuit>(Arena*);
template<> ::SC2APIProtocol::ResponseReplayInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseReplayInfo>(Arena*);
template<> ::SC2APIProtocol::ResponseRestartGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseRestartGame>(Arena*);
template<> ::SC2APIProtocol::ResponseSaveMap* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseSaveMap>(Arena*);
template<> ::SC2APIProtocol::ResponseSaveReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseSaveReplay>(Arena*);
template<> ::SC2APIProtocol::ResponseStartReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseStartReplay>(Arena*);
template<> ::SC2APIProtocol::ResponseStep* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseStep>(Arena*);
template<> ::SC2APIProtocol::SpatialCameraSetup* Arena::CreateMaybeMessage<::SC2APIProtocol::SpatialCameraSetup>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SC2APIProtocol {

enum ResponseCreateGame_Error : int {
  ResponseCreateGame_Error_MissingMap = 1,
  ResponseCreateGame_Error_InvalidMapPath = 2,
  ResponseCreateGame_Error_InvalidMapData = 3,
  ResponseCreateGame_Error_InvalidMapName = 4,
  ResponseCreateGame_Error_InvalidMapHandle = 5,
  ResponseCreateGame_Error_MissingPlayerSetup = 6,
  ResponseCreateGame_Error_InvalidPlayerSetup = 7,
  ResponseCreateGame_Error_MultiplayerUnsupported = 8
};
bool ResponseCreateGame_Error_IsValid(int value);
constexpr ResponseCreateGame_Error ResponseCreateGame_Error_Error_MIN = ResponseCreateGame_Error_MissingMap;
constexpr ResponseCreateGame_Error ResponseCreateGame_Error_Error_MAX = ResponseCreateGame_Error_MultiplayerUnsupported;
constexpr int ResponseCreateGame_Error_Error_ARRAYSIZE = ResponseCreateGame_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseCreateGame_Error_descriptor();
template<typename T>
inline const std::string& ResponseCreateGame_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseCreateGame_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseCreateGame_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseCreateGame_Error_descriptor(), enum_t_value);
}
inline bool ResponseCreateGame_Error_Parse(
    const std::string& name, ResponseCreateGame_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseCreateGame_Error>(
    ResponseCreateGame_Error_descriptor(), name, value);
}
enum ResponseJoinGame_Error : int {
  ResponseJoinGame_Error_MissingParticipation = 1,
  ResponseJoinGame_Error_InvalidObservedPlayerId = 2,
  ResponseJoinGame_Error_MissingOptions = 3,
  ResponseJoinGame_Error_MissingPorts = 4,
  ResponseJoinGame_Error_GameFull = 5,
  ResponseJoinGame_Error_LaunchError = 6,
  ResponseJoinGame_Error_FeatureUnsupported = 7,
  ResponseJoinGame_Error_NoSpaceForUser = 8,
  ResponseJoinGame_Error_MapDoesNotExist = 9,
  ResponseJoinGame_Error_CannotOpenMap = 10,
  ResponseJoinGame_Error_ChecksumError = 11,
  ResponseJoinGame_Error_NetworkError = 12,
  ResponseJoinGame_Error_OtherError = 13
};
bool ResponseJoinGame_Error_IsValid(int value);
constexpr ResponseJoinGame_Error ResponseJoinGame_Error_Error_MIN = ResponseJoinGame_Error_MissingParticipation;
constexpr ResponseJoinGame_Error ResponseJoinGame_Error_Error_MAX = ResponseJoinGame_Error_OtherError;
constexpr int ResponseJoinGame_Error_Error_ARRAYSIZE = ResponseJoinGame_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseJoinGame_Error_descriptor();
template<typename T>
inline const std::string& ResponseJoinGame_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseJoinGame_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseJoinGame_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseJoinGame_Error_descriptor(), enum_t_value);
}
inline bool ResponseJoinGame_Error_Parse(
    const std::string& name, ResponseJoinGame_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseJoinGame_Error>(
    ResponseJoinGame_Error_descriptor(), name, value);
}
enum ResponseRestartGame_Error : int {
  ResponseRestartGame_Error_LaunchError = 1
};
bool ResponseRestartGame_Error_IsValid(int value);
constexpr ResponseRestartGame_Error ResponseRestartGame_Error_Error_MIN = ResponseRestartGame_Error_LaunchError;
constexpr ResponseRestartGame_Error ResponseRestartGame_Error_Error_MAX = ResponseRestartGame_Error_LaunchError;
constexpr int ResponseRestartGame_Error_Error_ARRAYSIZE = ResponseRestartGame_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseRestartGame_Error_descriptor();
template<typename T>
inline const std::string& ResponseRestartGame_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseRestartGame_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseRestartGame_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseRestartGame_Error_descriptor(), enum_t_value);
}
inline bool ResponseRestartGame_Error_Parse(
    const std::string& name, ResponseRestartGame_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseRestartGame_Error>(
    ResponseRestartGame_Error_descriptor(), name, value);
}
enum ResponseStartReplay_Error : int {
  ResponseStartReplay_Error_MissingReplay = 1,
  ResponseStartReplay_Error_InvalidReplayPath = 2,
  ResponseStartReplay_Error_InvalidReplayData = 3,
  ResponseStartReplay_Error_InvalidMapData = 4,
  ResponseStartReplay_Error_InvalidObservedPlayerId = 5,
  ResponseStartReplay_Error_MissingOptions = 6,
  ResponseStartReplay_Error_LaunchError = 7
};
bool ResponseStartReplay_Error_IsValid(int value);
constexpr ResponseStartReplay_Error ResponseStartReplay_Error_Error_MIN = ResponseStartReplay_Error_MissingReplay;
constexpr ResponseStartReplay_Error ResponseStartReplay_Error_Error_MAX = ResponseStartReplay_Error_LaunchError;
constexpr int ResponseStartReplay_Error_Error_ARRAYSIZE = ResponseStartReplay_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseStartReplay_Error_descriptor();
template<typename T>
inline const std::string& ResponseStartReplay_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseStartReplay_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseStartReplay_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseStartReplay_Error_descriptor(), enum_t_value);
}
inline bool ResponseStartReplay_Error_Parse(
    const std::string& name, ResponseStartReplay_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseStartReplay_Error>(
    ResponseStartReplay_Error_descriptor(), name, value);
}
enum ResponseMapCommand_Error : int {
  ResponseMapCommand_Error_NoTriggerError = 1
};
bool ResponseMapCommand_Error_IsValid(int value);
constexpr ResponseMapCommand_Error ResponseMapCommand_Error_Error_MIN = ResponseMapCommand_Error_NoTriggerError;
constexpr ResponseMapCommand_Error ResponseMapCommand_Error_Error_MAX = ResponseMapCommand_Error_NoTriggerError;
constexpr int ResponseMapCommand_Error_Error_ARRAYSIZE = ResponseMapCommand_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseMapCommand_Error_descriptor();
template<typename T>
inline const std::string& ResponseMapCommand_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseMapCommand_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseMapCommand_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseMapCommand_Error_descriptor(), enum_t_value);
}
inline bool ResponseMapCommand_Error_Parse(
    const std::string& name, ResponseMapCommand_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseMapCommand_Error>(
    ResponseMapCommand_Error_descriptor(), name, value);
}
enum ResponseReplayInfo_Error : int {
  ResponseReplayInfo_Error_MissingReplay = 1,
  ResponseReplayInfo_Error_InvalidReplayPath = 2,
  ResponseReplayInfo_Error_InvalidReplayData = 3,
  ResponseReplayInfo_Error_ParsingError = 4,
  ResponseReplayInfo_Error_DownloadError = 5
};
bool ResponseReplayInfo_Error_IsValid(int value);
constexpr ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MIN = ResponseReplayInfo_Error_MissingReplay;
constexpr ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MAX = ResponseReplayInfo_Error_DownloadError;
constexpr int ResponseReplayInfo_Error_Error_ARRAYSIZE = ResponseReplayInfo_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseReplayInfo_Error_descriptor();
template<typename T>
inline const std::string& ResponseReplayInfo_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseReplayInfo_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseReplayInfo_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseReplayInfo_Error_descriptor(), enum_t_value);
}
inline bool ResponseReplayInfo_Error_Parse(
    const std::string& name, ResponseReplayInfo_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseReplayInfo_Error>(
    ResponseReplayInfo_Error_descriptor(), name, value);
}
enum ResponseSaveMap_Error : int {
  ResponseSaveMap_Error_InvalidMapData = 1
};
bool ResponseSaveMap_Error_IsValid(int value);
constexpr ResponseSaveMap_Error ResponseSaveMap_Error_Error_MIN = ResponseSaveMap_Error_InvalidMapData;
constexpr ResponseSaveMap_Error ResponseSaveMap_Error_Error_MAX = ResponseSaveMap_Error_InvalidMapData;
constexpr int ResponseSaveMap_Error_Error_ARRAYSIZE = ResponseSaveMap_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseSaveMap_Error_descriptor();
template<typename T>
inline const std::string& ResponseSaveMap_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseSaveMap_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseSaveMap_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseSaveMap_Error_descriptor(), enum_t_value);
}
inline bool ResponseSaveMap_Error_Parse(
    const std::string& name, ResponseSaveMap_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseSaveMap_Error>(
    ResponseSaveMap_Error_descriptor(), name, value);
}
enum ActionChat_Channel : int {
  ActionChat_Channel_Broadcast = 1,
  ActionChat_Channel_Team = 2
};
bool ActionChat_Channel_IsValid(int value);
constexpr ActionChat_Channel ActionChat_Channel_Channel_MIN = ActionChat_Channel_Broadcast;
constexpr ActionChat_Channel ActionChat_Channel_Channel_MAX = ActionChat_Channel_Team;
constexpr int ActionChat_Channel_Channel_ARRAYSIZE = ActionChat_Channel_Channel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionChat_Channel_descriptor();
template<typename T>
inline const std::string& ActionChat_Channel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionChat_Channel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionChat_Channel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionChat_Channel_descriptor(), enum_t_value);
}
inline bool ActionChat_Channel_Parse(
    const std::string& name, ActionChat_Channel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionChat_Channel>(
    ActionChat_Channel_descriptor(), name, value);
}
enum Status : int {
  launched = 1,
  init_game = 2,
  in_game = 3,
  in_replay = 4,
  ended = 5,
  quit = 6,
  unknown = 99
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = launched;
constexpr Status Status_MAX = unknown;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    const std::string& name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum Difficulty : int {
  VeryEasy = 1,
  Easy = 2,
  Medium = 3,
  MediumHard = 4,
  Hard = 5,
  Harder = 6,
  VeryHard = 7,
  CheatVision = 8,
  CheatMoney = 9,
  CheatInsane = 10
};
bool Difficulty_IsValid(int value);
constexpr Difficulty Difficulty_MIN = VeryEasy;
constexpr Difficulty Difficulty_MAX = CheatInsane;
constexpr int Difficulty_ARRAYSIZE = Difficulty_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Difficulty_descriptor();
template<typename T>
inline const std::string& Difficulty_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Difficulty>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Difficulty_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Difficulty_descriptor(), enum_t_value);
}
inline bool Difficulty_Parse(
    const std::string& name, Difficulty* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Difficulty>(
    Difficulty_descriptor(), name, value);
}
enum PlayerType : int {
  Participant = 1,
  Computer = 2,
  Observer = 3
};
bool PlayerType_IsValid(int value);
constexpr PlayerType PlayerType_MIN = Participant;
constexpr PlayerType PlayerType_MAX = Observer;
constexpr int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerType_descriptor();
template<typename T>
inline const std::string& PlayerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerType_descriptor(), enum_t_value);
}
inline bool PlayerType_Parse(
    const std::string& name, PlayerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum AIBuild : int {
  RandomBuild = 1,
  Rush = 2,
  Timing = 3,
  Power = 4,
  Macro = 5,
  Air = 6
};
bool AIBuild_IsValid(int value);
constexpr AIBuild AIBuild_MIN = RandomBuild;
constexpr AIBuild AIBuild_MAX = Air;
constexpr int AIBuild_ARRAYSIZE = AIBuild_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AIBuild_descriptor();
template<typename T>
inline const std::string& AIBuild_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AIBuild>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AIBuild_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AIBuild_descriptor(), enum_t_value);
}
inline bool AIBuild_Parse(
    const std::string& name, AIBuild* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AIBuild>(
    AIBuild_descriptor(), name, value);
}
enum Alert : int {
  AlertError = 3,
  AddOnComplete = 4,
  BuildingComplete = 5,
  BuildingUnderAttack = 6,
  LarvaHatched = 7,
  MergeComplete = 8,
  MineralsExhausted = 9,
  MorphComplete = 10,
  MothershipComplete = 11,
  MULEExpired = 12,
  NuclearLaunchDetected = 1,
  NukeComplete = 13,
  NydusWormDetected = 2,
  ResearchComplete = 14,
  TrainError = 15,
  TrainUnitComplete = 16,
  TrainWorkerComplete = 17,
  TransformationComplete = 18,
  UnitUnderAttack = 19,
  UpgradeComplete = 20,
  VespeneExhausted = 21,
  WarpInComplete = 22
};
bool Alert_IsValid(int value);
constexpr Alert Alert_MIN = NuclearLaunchDetected;
constexpr Alert Alert_MAX = WarpInComplete;
constexpr int Alert_ARRAYSIZE = Alert_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_descriptor();
template<typename T>
inline const std::string& Alert_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Alert>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Alert_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Alert_descriptor(), enum_t_value);
}
inline bool Alert_Parse(
    const std::string& name, Alert* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Alert>(
    Alert_descriptor(), name, value);
}
enum Result : int {
  Victory = 1,
  Defeat = 2,
  Tie = 3,
  Undecided = 4
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = Victory;
constexpr Result Result_MAX = Undecided;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    const std::string& name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class Request :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  enum RequestCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kObsAction = 21,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kMapCommand = 22,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kPing = 19,
    kDebug = 20,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Request";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 97,
    kCreateGameFieldNumber = 1,
    kJoinGameFieldNumber = 2,
    kRestartGameFieldNumber = 3,
    kStartReplayFieldNumber = 4,
    kLeaveGameFieldNumber = 5,
    kQuickSaveFieldNumber = 6,
    kQuickLoadFieldNumber = 7,
    kQuitFieldNumber = 8,
    kGameInfoFieldNumber = 9,
    kObservationFieldNumber = 10,
    kActionFieldNumber = 11,
    kObsActionFieldNumber = 21,
    kStepFieldNumber = 12,
    kDataFieldNumber = 13,
    kQueryFieldNumber = 14,
    kSaveReplayFieldNumber = 15,
    kMapCommandFieldNumber = 22,
    kReplayInfoFieldNumber = 16,
    kAvailableMapsFieldNumber = 17,
    kSaveMapFieldNumber = 18,
    kPingFieldNumber = 19,
    kDebugFieldNumber = 20,
  };
  // optional uint32 id = 97;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SC2APIProtocol.RequestCreateGame create_game = 1;
  bool has_create_game() const;
  private:
  bool _internal_has_create_game() const;
  public:
  void clear_create_game();
  const ::SC2APIProtocol::RequestCreateGame& create_game() const;
  ::SC2APIProtocol::RequestCreateGame* release_create_game();
  ::SC2APIProtocol::RequestCreateGame* mutable_create_game();
  void set_allocated_create_game(::SC2APIProtocol::RequestCreateGame* create_game);
  private:
  const ::SC2APIProtocol::RequestCreateGame& _internal_create_game() const;
  ::SC2APIProtocol::RequestCreateGame* _internal_mutable_create_game();
  public:

  // optional .SC2APIProtocol.RequestJoinGame join_game = 2;
  bool has_join_game() const;
  private:
  bool _internal_has_join_game() const;
  public:
  void clear_join_game();
  const ::SC2APIProtocol::RequestJoinGame& join_game() const;
  ::SC2APIProtocol::RequestJoinGame* release_join_game();
  ::SC2APIProtocol::RequestJoinGame* mutable_join_game();
  void set_allocated_join_game(::SC2APIProtocol::RequestJoinGame* join_game);
  private:
  const ::SC2APIProtocol::RequestJoinGame& _internal_join_game() const;
  ::SC2APIProtocol::RequestJoinGame* _internal_mutable_join_game();
  public:

  // optional .SC2APIProtocol.RequestRestartGame restart_game = 3;
  bool has_restart_game() const;
  private:
  bool _internal_has_restart_game() const;
  public:
  void clear_restart_game();
  const ::SC2APIProtocol::RequestRestartGame& restart_game() const;
  ::SC2APIProtocol::RequestRestartGame* release_restart_game();
  ::SC2APIProtocol::RequestRestartGame* mutable_restart_game();
  void set_allocated_restart_game(::SC2APIProtocol::RequestRestartGame* restart_game);
  private:
  const ::SC2APIProtocol::RequestRestartGame& _internal_restart_game() const;
  ::SC2APIProtocol::RequestRestartGame* _internal_mutable_restart_game();
  public:

  // optional .SC2APIProtocol.RequestStartReplay start_replay = 4;
  bool has_start_replay() const;
  private:
  bool _internal_has_start_replay() const;
  public:
  void clear_start_replay();
  const ::SC2APIProtocol::RequestStartReplay& start_replay() const;
  ::SC2APIProtocol::RequestStartReplay* release_start_replay();
  ::SC2APIProtocol::RequestStartReplay* mutable_start_replay();
  void set_allocated_start_replay(::SC2APIProtocol::RequestStartReplay* start_replay);
  private:
  const ::SC2APIProtocol::RequestStartReplay& _internal_start_replay() const;
  ::SC2APIProtocol::RequestStartReplay* _internal_mutable_start_replay();
  public:

  // optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;
  bool has_leave_game() const;
  private:
  bool _internal_has_leave_game() const;
  public:
  void clear_leave_game();
  const ::SC2APIProtocol::RequestLeaveGame& leave_game() const;
  ::SC2APIProtocol::RequestLeaveGame* release_leave_game();
  ::SC2APIProtocol::RequestLeaveGame* mutable_leave_game();
  void set_allocated_leave_game(::SC2APIProtocol::RequestLeaveGame* leave_game);
  private:
  const ::SC2APIProtocol::RequestLeaveGame& _internal_leave_game() const;
  ::SC2APIProtocol::RequestLeaveGame* _internal_mutable_leave_game();
  public:

  // optional .SC2APIProtocol.RequestQuickSave quick_save = 6;
  bool has_quick_save() const;
  private:
  bool _internal_has_quick_save() const;
  public:
  void clear_quick_save();
  const ::SC2APIProtocol::RequestQuickSave& quick_save() const;
  ::SC2APIProtocol::RequestQuickSave* release_quick_save();
  ::SC2APIProtocol::RequestQuickSave* mutable_quick_save();
  void set_allocated_quick_save(::SC2APIProtocol::RequestQuickSave* quick_save);
  private:
  const ::SC2APIProtocol::RequestQuickSave& _internal_quick_save() const;
  ::SC2APIProtocol::RequestQuickSave* _internal_mutable_quick_save();
  public:

  // optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;
  bool has_quick_load() const;
  private:
  bool _internal_has_quick_load() const;
  public:
  void clear_quick_load();
  const ::SC2APIProtocol::RequestQuickLoad& quick_load() const;
  ::SC2APIProtocol::RequestQuickLoad* release_quick_load();
  ::SC2APIProtocol::RequestQuickLoad* mutable_quick_load();
  void set_allocated_quick_load(::SC2APIProtocol::RequestQuickLoad* quick_load);
  private:
  const ::SC2APIProtocol::RequestQuickLoad& _internal_quick_load() const;
  ::SC2APIProtocol::RequestQuickLoad* _internal_mutable_quick_load();
  public:

  // optional .SC2APIProtocol.RequestQuit quit = 8;
  bool has_quit() const;
  private:
  bool _internal_has_quit() const;
  public:
  void clear_quit();
  const ::SC2APIProtocol::RequestQuit& quit() const;
  ::SC2APIProtocol::RequestQuit* release_quit();
  ::SC2APIProtocol::RequestQuit* mutable_quit();
  void set_allocated_quit(::SC2APIProtocol::RequestQuit* quit);
  private:
  const ::SC2APIProtocol::RequestQuit& _internal_quit() const;
  ::SC2APIProtocol::RequestQuit* _internal_mutable_quit();
  public:

  // optional .SC2APIProtocol.RequestGameInfo game_info = 9;
  bool has_game_info() const;
  private:
  bool _internal_has_game_info() const;
  public:
  void clear_game_info();
  const ::SC2APIProtocol::RequestGameInfo& game_info() const;
  ::SC2APIProtocol::RequestGameInfo* release_game_info();
  ::SC2APIProtocol::RequestGameInfo* mutable_game_info();
  void set_allocated_game_info(::SC2APIProtocol::RequestGameInfo* game_info);
  private:
  const ::SC2APIProtocol::RequestGameInfo& _internal_game_info() const;
  ::SC2APIProtocol::RequestGameInfo* _internal_mutable_game_info();
  public:

  // optional .SC2APIProtocol.RequestObservation observation = 10;
  bool has_observation() const;
  private:
  bool _internal_has_observation() const;
  public:
  void clear_observation();
  const ::SC2APIProtocol::RequestObservation& observation() const;
  ::SC2APIProtocol::RequestObservation* release_observation();
  ::SC2APIProtocol::RequestObservation* mutable_observation();
  void set_allocated_observation(::SC2APIProtocol::RequestObservation* observation);
  private:
  const ::SC2APIProtocol::RequestObservation& _internal_observation() const;
  ::SC2APIProtocol::RequestObservation* _internal_mutable_observation();
  public:

  // optional .SC2APIProtocol.RequestAction action = 11;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::SC2APIProtocol::RequestAction& action() const;
  ::SC2APIProtocol::RequestAction* release_action();
  ::SC2APIProtocol::RequestAction* mutable_action();
  void set_allocated_action(::SC2APIProtocol::RequestAction* action);
  private:
  const ::SC2APIProtocol::RequestAction& _internal_action() const;
  ::SC2APIProtocol::RequestAction* _internal_mutable_action();
  public:

  // optional .SC2APIProtocol.RequestObserverAction obs_action = 21;
  bool has_obs_action() const;
  private:
  bool _internal_has_obs_action() const;
  public:
  void clear_obs_action();
  const ::SC2APIProtocol::RequestObserverAction& obs_action() const;
  ::SC2APIProtocol::RequestObserverAction* release_obs_action();
  ::SC2APIProtocol::RequestObserverAction* mutable_obs_action();
  void set_allocated_obs_action(::SC2APIProtocol::RequestObserverAction* obs_action);
  private:
  const ::SC2APIProtocol::RequestObserverAction& _internal_obs_action() const;
  ::SC2APIProtocol::RequestObserverAction* _internal_mutable_obs_action();
  public:

  // optional .SC2APIProtocol.RequestStep step = 12;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  const ::SC2APIProtocol::RequestStep& step() const;
  ::SC2APIProtocol::RequestStep* release_step();
  ::SC2APIProtocol::RequestStep* mutable_step();
  void set_allocated_step(::SC2APIProtocol::RequestStep* step);
  private:
  const ::SC2APIProtocol::RequestStep& _internal_step() const;
  ::SC2APIProtocol::RequestStep* _internal_mutable_step();
  public:

  // optional .SC2APIProtocol.RequestData data = 13;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::SC2APIProtocol::RequestData& data() const;
  ::SC2APIProtocol::RequestData* release_data();
  ::SC2APIProtocol::RequestData* mutable_data();
  void set_allocated_data(::SC2APIProtocol::RequestData* data);
  private:
  const ::SC2APIProtocol::RequestData& _internal_data() const;
  ::SC2APIProtocol::RequestData* _internal_mutable_data();
  public:

  // optional .SC2APIProtocol.RequestQuery query = 14;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::SC2APIProtocol::RequestQuery& query() const;
  ::SC2APIProtocol::RequestQuery* release_query();
  ::SC2APIProtocol::RequestQuery* mutable_query();
  void set_allocated_query(::SC2APIProtocol::RequestQuery* query);
  private:
  const ::SC2APIProtocol::RequestQuery& _internal_query() const;
  ::SC2APIProtocol::RequestQuery* _internal_mutable_query();
  public:

  // optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;
  bool has_save_replay() const;
  private:
  bool _internal_has_save_replay() const;
  public:
  void clear_save_replay();
  const ::SC2APIProtocol::RequestSaveReplay& save_replay() const;
  ::SC2APIProtocol::RequestSaveReplay* release_save_replay();
  ::SC2APIProtocol::RequestSaveReplay* mutable_save_replay();
  void set_allocated_save_replay(::SC2APIProtocol::RequestSaveReplay* save_replay);
  private:
  const ::SC2APIProtocol::RequestSaveReplay& _internal_save_replay() const;
  ::SC2APIProtocol::RequestSaveReplay* _internal_mutable_save_replay();
  public:

  // optional .SC2APIProtocol.RequestMapCommand map_command = 22;
  bool has_map_command() const;
  private:
  bool _internal_has_map_command() const;
  public:
  void clear_map_command();
  const ::SC2APIProtocol::RequestMapCommand& map_command() const;
  ::SC2APIProtocol::RequestMapCommand* release_map_command();
  ::SC2APIProtocol::RequestMapCommand* mutable_map_command();
  void set_allocated_map_command(::SC2APIProtocol::RequestMapCommand* map_command);
  private:
  const ::SC2APIProtocol::RequestMapCommand& _internal_map_command() const;
  ::SC2APIProtocol::RequestMapCommand* _internal_mutable_map_command();
  public:

  // optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;
  bool has_replay_info() const;
  private:
  bool _internal_has_replay_info() const;
  public:
  void clear_replay_info();
  const ::SC2APIProtocol::RequestReplayInfo& replay_info() const;
  ::SC2APIProtocol::RequestReplayInfo* release_replay_info();
  ::SC2APIProtocol::RequestReplayInfo* mutable_replay_info();
  void set_allocated_replay_info(::SC2APIProtocol::RequestReplayInfo* replay_info);
  private:
  const ::SC2APIProtocol::RequestReplayInfo& _internal_replay_info() const;
  ::SC2APIProtocol::RequestReplayInfo* _internal_mutable_replay_info();
  public:

  // optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  private:
  bool _internal_has_available_maps() const;
  public:
  void clear_available_maps();
  const ::SC2APIProtocol::RequestAvailableMaps& available_maps() const;
  ::SC2APIProtocol::RequestAvailableMaps* release_available_maps();
  ::SC2APIProtocol::RequestAvailableMaps* mutable_available_maps();
  void set_allocated_available_maps(::SC2APIProtocol::RequestAvailableMaps* available_maps);
  private:
  const ::SC2APIProtocol::RequestAvailableMaps& _internal_available_maps() const;
  ::SC2APIProtocol::RequestAvailableMaps* _internal_mutable_available_maps();
  public:

  // optional .SC2APIProtocol.RequestSaveMap save_map = 18;
  bool has_save_map() const;
  private:
  bool _internal_has_save_map() const;
  public:
  void clear_save_map();
  const ::SC2APIProtocol::RequestSaveMap& save_map() const;
  ::SC2APIProtocol::RequestSaveMap* release_save_map();
  ::SC2APIProtocol::RequestSaveMap* mutable_save_map();
  void set_allocated_save_map(::SC2APIProtocol::RequestSaveMap* save_map);
  private:
  const ::SC2APIProtocol::RequestSaveMap& _internal_save_map() const;
  ::SC2APIProtocol::RequestSaveMap* _internal_mutable_save_map();
  public:

  // optional .SC2APIProtocol.RequestPing ping = 19;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::SC2APIProtocol::RequestPing& ping() const;
  ::SC2APIProtocol::RequestPing* release_ping();
  ::SC2APIProtocol::RequestPing* mutable_ping();
  void set_allocated_ping(::SC2APIProtocol::RequestPing* ping);
  private:
  const ::SC2APIProtocol::RequestPing& _internal_ping() const;
  ::SC2APIProtocol::RequestPing* _internal_mutable_ping();
  public:

  // optional .SC2APIProtocol.RequestDebug debug = 20;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  const ::SC2APIProtocol::RequestDebug& debug() const;
  ::SC2APIProtocol::RequestDebug* release_debug();
  ::SC2APIProtocol::RequestDebug* mutable_debug();
  void set_allocated_debug(::SC2APIProtocol::RequestDebug* debug);
  private:
  const ::SC2APIProtocol::RequestDebug& _internal_debug() const;
  ::SC2APIProtocol::RequestDebug* _internal_mutable_debug();
  public:

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Request)
 private:
  class _Internal;
  void set_has_create_game();
  void set_has_join_game();
  void set_has_restart_game();
  void set_has_start_replay();
  void set_has_leave_game();
  void set_has_quick_save();
  void set_has_quick_load();
  void set_has_quit();
  void set_has_game_info();
  void set_has_observation();
  void set_has_action();
  void set_has_obs_action();
  void set_has_step();
  void set_has_data();
  void set_has_query();
  void set_has_save_replay();
  void set_has_map_command();
  void set_has_replay_info();
  void set_has_available_maps();
  void set_has_save_map();
  void set_has_ping();
  void set_has_debug();

  inline bool has_request() const;
  inline void clear_has_request();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  union RequestUnion {
    RequestUnion() {}
    ::SC2APIProtocol::RequestCreateGame* create_game_;
    ::SC2APIProtocol::RequestJoinGame* join_game_;
    ::SC2APIProtocol::RequestRestartGame* restart_game_;
    ::SC2APIProtocol::RequestStartReplay* start_replay_;
    ::SC2APIProtocol::RequestLeaveGame* leave_game_;
    ::SC2APIProtocol::RequestQuickSave* quick_save_;
    ::SC2APIProtocol::RequestQuickLoad* quick_load_;
    ::SC2APIProtocol::RequestQuit* quit_;
    ::SC2APIProtocol::RequestGameInfo* game_info_;
    ::SC2APIProtocol::RequestObservation* observation_;
    ::SC2APIProtocol::RequestAction* action_;
    ::SC2APIProtocol::RequestObserverAction* obs_action_;
    ::SC2APIProtocol::RequestStep* step_;
    ::SC2APIProtocol::RequestData* data_;
    ::SC2APIProtocol::RequestQuery* query_;
    ::SC2APIProtocol::RequestSaveReplay* save_replay_;
    ::SC2APIProtocol::RequestMapCommand* map_command_;
    ::SC2APIProtocol::RequestReplayInfo* replay_info_;
    ::SC2APIProtocol::RequestAvailableMaps* available_maps_;
    ::SC2APIProtocol::RequestSaveMap* save_map_;
    ::SC2APIProtocol::RequestPing* ping_;
    ::SC2APIProtocol::RequestDebug* debug_;
  } request_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class Response :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Response& default_instance();

  enum ResponseCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kObsAction = 21,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kMapCommand = 22,
    kPing = 19,
    kDebug = 20,
    RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Response";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 98,
    kIdFieldNumber = 97,
    kStatusFieldNumber = 99,
    kCreateGameFieldNumber = 1,
    kJoinGameFieldNumber = 2,
    kRestartGameFieldNumber = 3,
    kStartReplayFieldNumber = 4,
    kLeaveGameFieldNumber = 5,
    kQuickSaveFieldNumber = 6,
    kQuickLoadFieldNumber = 7,
    kQuitFieldNumber = 8,
    kGameInfoFieldNumber = 9,
    kObservationFieldNumber = 10,
    kActionFieldNumber = 11,
    kObsActionFieldNumber = 21,
    kStepFieldNumber = 12,
    kDataFieldNumber = 13,
    kQueryFieldNumber = 14,
    kSaveReplayFieldNumber = 15,
    kReplayInfoFieldNumber = 16,
    kAvailableMapsFieldNumber = 17,
    kSaveMapFieldNumber = 18,
    kMapCommandFieldNumber = 22,
    kPingFieldNumber = 19,
    kDebugFieldNumber = 20,
  };
  // repeated string error = 98;
  int error_size() const;
  private:
  int _internal_error_size() const;
  public:
  void clear_error();
  const std::string& error(int index) const;
  std::string* mutable_error(int index);
  void set_error(int index, const std::string& value);
  void set_error(int index, std::string&& value);
  void set_error(int index, const char* value);
  void set_error(int index, const char* value, size_t size);
  std::string* add_error();
  void add_error(const std::string& value);
  void add_error(std::string&& value);
  void add_error(const char* value);
  void add_error(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& error() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_error();
  private:
  const std::string& _internal_error(int index) const;
  std::string* _internal_add_error();
  public:

  // optional uint32 id = 97;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SC2APIProtocol.Status status = 99;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::SC2APIProtocol::Status status() const;
  void set_status(::SC2APIProtocol::Status value);
  private:
  ::SC2APIProtocol::Status _internal_status() const;
  void _internal_set_status(::SC2APIProtocol::Status value);
  public:

  // optional .SC2APIProtocol.ResponseCreateGame create_game = 1;
  bool has_create_game() const;
  private:
  bool _internal_has_create_game() const;
  public:
  void clear_create_game();
  const ::SC2APIProtocol::ResponseCreateGame& create_game() const;
  ::SC2APIProtocol::ResponseCreateGame* release_create_game();
  ::SC2APIProtocol::ResponseCreateGame* mutable_create_game();
  void set_allocated_create_game(::SC2APIProtocol::ResponseCreateGame* create_game);
  private:
  const ::SC2APIProtocol::ResponseCreateGame& _internal_create_game() const;
  ::SC2APIProtocol::ResponseCreateGame* _internal_mutable_create_game();
  public:

  // optional .SC2APIProtocol.ResponseJoinGame join_game = 2;
  bool has_join_game() const;
  private:
  bool _internal_has_join_game() const;
  public:
  void clear_join_game();
  const ::SC2APIProtocol::ResponseJoinGame& join_game() const;
  ::SC2APIProtocol::ResponseJoinGame* release_join_game();
  ::SC2APIProtocol::ResponseJoinGame* mutable_join_game();
  void set_allocated_join_game(::SC2APIProtocol::ResponseJoinGame* join_game);
  private:
  const ::SC2APIProtocol::ResponseJoinGame& _internal_join_game() const;
  ::SC2APIProtocol::ResponseJoinGame* _internal_mutable_join_game();
  public:

  // optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;
  bool has_restart_game() const;
  private:
  bool _internal_has_restart_game() const;
  public:
  void clear_restart_game();
  const ::SC2APIProtocol::ResponseRestartGame& restart_game() const;
  ::SC2APIProtocol::ResponseRestartGame* release_restart_game();
  ::SC2APIProtocol::ResponseRestartGame* mutable_restart_game();
  void set_allocated_restart_game(::SC2APIProtocol::ResponseRestartGame* restart_game);
  private:
  const ::SC2APIProtocol::ResponseRestartGame& _internal_restart_game() const;
  ::SC2APIProtocol::ResponseRestartGame* _internal_mutable_restart_game();
  public:

  // optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;
  bool has_start_replay() const;
  private:
  bool _internal_has_start_replay() const;
  public:
  void clear_start_replay();
  const ::SC2APIProtocol::ResponseStartReplay& start_replay() const;
  ::SC2APIProtocol::ResponseStartReplay* release_start_replay();
  ::SC2APIProtocol::ResponseStartReplay* mutable_start_replay();
  void set_allocated_start_replay(::SC2APIProtocol::ResponseStartReplay* start_replay);
  private:
  const ::SC2APIProtocol::ResponseStartReplay& _internal_start_replay() const;
  ::SC2APIProtocol::ResponseStartReplay* _internal_mutable_start_replay();
  public:

  // optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;
  bool has_leave_game() const;
  private:
  bool _internal_has_leave_game() const;
  public:
  void clear_leave_game();
  const ::SC2APIProtocol::ResponseLeaveGame& leave_game() const;
  ::SC2APIProtocol::ResponseLeaveGame* release_leave_game();
  ::SC2APIProtocol::ResponseLeaveGame* mutable_leave_game();
  void set_allocated_leave_game(::SC2APIProtocol::ResponseLeaveGame* leave_game);
  private:
  const ::SC2APIProtocol::ResponseLeaveGame& _internal_leave_game() const;
  ::SC2APIProtocol::ResponseLeaveGame* _internal_mutable_leave_game();
  public:

  // optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;
  bool has_quick_save() const;
  private:
  bool _internal_has_quick_save() const;
  public:
  void clear_quick_save();
  const ::SC2APIProtocol::ResponseQuickSave& quick_save() const;
  ::SC2APIProtocol::ResponseQuickSave* release_quick_save();
  ::SC2APIProtocol::ResponseQuickSave* mutable_quick_save();
  void set_allocated_quick_save(::SC2APIProtocol::ResponseQuickSave* quick_save);
  private:
  const ::SC2APIProtocol::ResponseQuickSave& _internal_quick_save() const;
  ::SC2APIProtocol::ResponseQuickSave* _internal_mutable_quick_save();
  public:

  // optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;
  bool has_quick_load() const;
  private:
  bool _internal_has_quick_load() const;
  public:
  void clear_quick_load();
  const ::SC2APIProtocol::ResponseQuickLoad& quick_load() const;
  ::SC2APIProtocol::ResponseQuickLoad* release_quick_load();
  ::SC2APIProtocol::ResponseQuickLoad* mutable_quick_load();
  void set_allocated_quick_load(::SC2APIProtocol::ResponseQuickLoad* quick_load);
  private:
  const ::SC2APIProtocol::ResponseQuickLoad& _internal_quick_load() const;
  ::SC2APIProtocol::ResponseQuickLoad* _internal_mutable_quick_load();
  public:

  // optional .SC2APIProtocol.ResponseQuit quit = 8;
  bool has_quit() const;
  private:
  bool _internal_has_quit() const;
  public:
  void clear_quit();
  const ::SC2APIProtocol::ResponseQuit& quit() const;
  ::SC2APIProtocol::ResponseQuit* release_quit();
  ::SC2APIProtocol::ResponseQuit* mutable_quit();
  void set_allocated_quit(::SC2APIProtocol::ResponseQuit* quit);
  private:
  const ::SC2APIProtocol::ResponseQuit& _internal_quit() const;
  ::SC2APIProtocol::ResponseQuit* _internal_mutable_quit();
  public:

  // optional .SC2APIProtocol.ResponseGameInfo game_info = 9;
  bool has_game_info() const;
  private:
  bool _internal_has_game_info() const;
  public:
  void clear_game_info();
  const ::SC2APIProtocol::ResponseGameInfo& game_info() const;
  ::SC2APIProtocol::ResponseGameInfo* release_game_info();
  ::SC2APIProtocol::ResponseGameInfo* mutable_game_info();
  void set_allocated_game_info(::SC2APIProtocol::ResponseGameInfo* game_info);
  private:
  const ::SC2APIProtocol::ResponseGameInfo& _internal_game_info() const;
  ::SC2APIProtocol::ResponseGameInfo* _internal_mutable_game_info();
  public:

  // optional .SC2APIProtocol.ResponseObservation observation = 10;
  bool has_observation() const;
  private:
  bool _internal_has_observation() const;
  public:
  void clear_observation();
  const ::SC2APIProtocol::ResponseObservation& observation() const;
  ::SC2APIProtocol::ResponseObservation* release_observation();
  ::SC2APIProtocol::ResponseObservation* mutable_observation();
  void set_allocated_observation(::SC2APIProtocol::ResponseObservation* observation);
  private:
  const ::SC2APIProtocol::ResponseObservation& _internal_observation() const;
  ::SC2APIProtocol::ResponseObservation* _internal_mutable_observation();
  public:

  // optional .SC2APIProtocol.ResponseAction action = 11;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::SC2APIProtocol::ResponseAction& action() const;
  ::SC2APIProtocol::ResponseAction* release_action();
  ::SC2APIProtocol::ResponseAction* mutable_action();
  void set_allocated_action(::SC2APIProtocol::ResponseAction* action);
  private:
  const ::SC2APIProtocol::ResponseAction& _internal_action() const;
  ::SC2APIProtocol::ResponseAction* _internal_mutable_action();
  public:

  // optional .SC2APIProtocol.ResponseObserverAction obs_action = 21;
  bool has_obs_action() const;
  private:
  bool _internal_has_obs_action() const;
  public:
  void clear_obs_action();
  const ::SC2APIProtocol::ResponseObserverAction& obs_action() const;
  ::SC2APIProtocol::ResponseObserverAction* release_obs_action();
  ::SC2APIProtocol::ResponseObserverAction* mutable_obs_action();
  void set_allocated_obs_action(::SC2APIProtocol::ResponseObserverAction* obs_action);
  private:
  const ::SC2APIProtocol::ResponseObserverAction& _internal_obs_action() const;
  ::SC2APIProtocol::ResponseObserverAction* _internal_mutable_obs_action();
  public:

  // optional .SC2APIProtocol.ResponseStep step = 12;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  const ::SC2APIProtocol::ResponseStep& step() const;
  ::SC2APIProtocol::ResponseStep* release_step();
  ::SC2APIProtocol::ResponseStep* mutable_step();
  void set_allocated_step(::SC2APIProtocol::ResponseStep* step);
  private:
  const ::SC2APIProtocol::ResponseStep& _internal_step() const;
  ::SC2APIProtocol::ResponseStep* _internal_mutable_step();
  public:

  // optional .SC2APIProtocol.ResponseData data = 13;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::SC2APIProtocol::ResponseData& data() const;
  ::SC2APIProtocol::ResponseData* release_data();
  ::SC2APIProtocol::ResponseData* mutable_data();
  void set_allocated_data(::SC2APIProtocol::ResponseData* data);
  private:
  const ::SC2APIProtocol::ResponseData& _internal_data() const;
  ::SC2APIProtocol::ResponseData* _internal_mutable_data();
  public:

  // optional .SC2APIProtocol.ResponseQuery query = 14;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::SC2APIProtocol::ResponseQuery& query() const;
  ::SC2APIProtocol::ResponseQuery* release_query();
  ::SC2APIProtocol::ResponseQuery* mutable_query();
  void set_allocated_query(::SC2APIProtocol::ResponseQuery* query);
  private:
  const ::SC2APIProtocol::ResponseQuery& _internal_query() const;
  ::SC2APIProtocol::ResponseQuery* _internal_mutable_query();
  public:

  // optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;
  bool has_save_replay() const;
  private:
  bool _internal_has_save_replay() const;
  public:
  void clear_save_replay();
  const ::SC2APIProtocol::ResponseSaveReplay& save_replay() const;
  ::SC2APIProtocol::ResponseSaveReplay* release_save_replay();
  ::SC2APIProtocol::ResponseSaveReplay* mutable_save_replay();
  void set_allocated_save_replay(::SC2APIProtocol::ResponseSaveReplay* save_replay);
  private:
  const ::SC2APIProtocol::ResponseSaveReplay& _internal_save_replay() const;
  ::SC2APIProtocol::ResponseSaveReplay* _internal_mutable_save_replay();
  public:

  // optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;
  bool has_replay_info() const;
  private:
  bool _internal_has_replay_info() const;
  public:
  void clear_replay_info();
  const ::SC2APIProtocol::ResponseReplayInfo& replay_info() const;
  ::SC2APIProtocol::ResponseReplayInfo* release_replay_info();
  ::SC2APIProtocol::ResponseReplayInfo* mutable_replay_info();
  void set_allocated_replay_info(::SC2APIProtocol::ResponseReplayInfo* replay_info);
  private:
  const ::SC2APIProtocol::ResponseReplayInfo& _internal_replay_info() const;
  ::SC2APIProtocol::ResponseReplayInfo* _internal_mutable_replay_info();
  public:

  // optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  private:
  bool _internal_has_available_maps() const;
  public:
  void clear_available_maps();
  const ::SC2APIProtocol::ResponseAvailableMaps& available_maps() const;
  ::SC2APIProtocol::ResponseAvailableMaps* release_available_maps();
  ::SC2APIProtocol::ResponseAvailableMaps* mutable_available_maps();
  void set_allocated_available_maps(::SC2APIProtocol::ResponseAvailableMaps* available_maps);
  private:
  const ::SC2APIProtocol::ResponseAvailableMaps& _internal_available_maps() const;
  ::SC2APIProtocol::ResponseAvailableMaps* _internal_mutable_available_maps();
  public:

  // optional .SC2APIProtocol.ResponseSaveMap save_map = 18;
  bool has_save_map() const;
  private:
  bool _internal_has_save_map() const;
  public:
  void clear_save_map();
  const ::SC2APIProtocol::ResponseSaveMap& save_map() const;
  ::SC2APIProtocol::ResponseSaveMap* release_save_map();
  ::SC2APIProtocol::ResponseSaveMap* mutable_save_map();
  void set_allocated_save_map(::SC2APIProtocol::ResponseSaveMap* save_map);
  private:
  const ::SC2APIProtocol::ResponseSaveMap& _internal_save_map() const;
  ::SC2APIProtocol::ResponseSaveMap* _internal_mutable_save_map();
  public:

  // optional .SC2APIProtocol.ResponseMapCommand map_command = 22;
  bool has_map_command() const;
  private:
  bool _internal_has_map_command() const;
  public:
  void clear_map_command();
  const ::SC2APIProtocol::ResponseMapCommand& map_command() const;
  ::SC2APIProtocol::ResponseMapCommand* release_map_command();
  ::SC2APIProtocol::ResponseMapCommand* mutable_map_command();
  void set_allocated_map_command(::SC2APIProtocol::ResponseMapCommand* map_command);
  private:
  const ::SC2APIProtocol::ResponseMapCommand& _internal_map_command() const;
  ::SC2APIProtocol::ResponseMapCommand* _internal_mutable_map_command();
  public:

  // optional .SC2APIProtocol.ResponsePing ping = 19;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::SC2APIProtocol::ResponsePing& ping() const;
  ::SC2APIProtocol::ResponsePing* release_ping();
  ::SC2APIProtocol::ResponsePing* mutable_ping();
  void set_allocated_ping(::SC2APIProtocol::ResponsePing* ping);
  private:
  const ::SC2APIProtocol::ResponsePing& _internal_ping() const;
  ::SC2APIProtocol::ResponsePing* _internal_mutable_ping();
  public:

  // optional .SC2APIProtocol.ResponseDebug debug = 20;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  const ::SC2APIProtocol::ResponseDebug& debug() const;
  ::SC2APIProtocol::ResponseDebug* release_debug();
  ::SC2APIProtocol::ResponseDebug* mutable_debug();
  void set_allocated_debug(::SC2APIProtocol::ResponseDebug* debug);
  private:
  const ::SC2APIProtocol::ResponseDebug& _internal_debug() const;
  ::SC2APIProtocol::ResponseDebug* _internal_mutable_debug();
  public:

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Response)
 private:
  class _Internal;
  void set_has_create_game();
  void set_has_join_game();
  void set_has_restart_game();
  void set_has_start_replay();
  void set_has_leave_game();
  void set_has_quick_save();
  void set_has_quick_load();
  void set_has_quit();
  void set_has_game_info();
  void set_has_observation();
  void set_has_action();
  void set_has_obs_action();
  void set_has_step();
  void set_has_data();
  void set_has_query();
  void set_has_save_replay();
  void set_has_replay_info();
  void set_has_available_maps();
  void set_has_save_map();
  void set_has_map_command();
  void set_has_ping();
  void set_has_debug();

  inline bool has_response() const;
  inline void clear_has_response();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  int status_;
  union ResponseUnion {
    ResponseUnion() {}
    ::SC2APIProtocol::ResponseCreateGame* create_game_;
    ::SC2APIProtocol::ResponseJoinGame* join_game_;
    ::SC2APIProtocol::ResponseRestartGame* restart_game_;
    ::SC2APIProtocol::ResponseStartReplay* start_replay_;
    ::SC2APIProtocol::ResponseLeaveGame* leave_game_;
    ::SC2APIProtocol::ResponseQuickSave* quick_save_;
    ::SC2APIProtocol::ResponseQuickLoad* quick_load_;
    ::SC2APIProtocol::ResponseQuit* quit_;
    ::SC2APIProtocol::ResponseGameInfo* game_info_;
    ::SC2APIProtocol::ResponseObservation* observation_;
    ::SC2APIProtocol::ResponseAction* action_;
    ::SC2APIProtocol::ResponseObserverAction* obs_action_;
    ::SC2APIProtocol::ResponseStep* step_;
    ::SC2APIProtocol::ResponseData* data_;
    ::SC2APIProtocol::ResponseQuery* query_;
    ::SC2APIProtocol::ResponseSaveReplay* save_replay_;
    ::SC2APIProtocol::ResponseReplayInfo* replay_info_;
    ::SC2APIProtocol::ResponseAvailableMaps* available_maps_;
    ::SC2APIProtocol::ResponseSaveMap* save_map_;
    ::SC2APIProtocol::ResponseMapCommand* map_command_;
    ::SC2APIProtocol::ResponsePing* ping_;
    ::SC2APIProtocol::ResponseDebug* debug_;
  } response_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestCreateGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestCreateGame) */ {
 public:
  RequestCreateGame();
  virtual ~RequestCreateGame();

  RequestCreateGame(const RequestCreateGame& from);
  RequestCreateGame(RequestCreateGame&& from) noexcept
    : RequestCreateGame() {
    *this = ::std::move(from);
  }

  inline RequestCreateGame& operator=(const RequestCreateGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCreateGame& operator=(RequestCreateGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestCreateGame& default_instance();

  enum MapCase {
    kLocalMap = 1,
    kBattlenetMapName = 2,
    MAP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCreateGame* internal_default_instance() {
    return reinterpret_cast<const RequestCreateGame*>(
               &_RequestCreateGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestCreateGame& a, RequestCreateGame& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCreateGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestCreateGame* New() const final {
    return CreateMaybeMessage<RequestCreateGame>(nullptr);
  }

  RequestCreateGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestCreateGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestCreateGame& from);
  void MergeFrom(const RequestCreateGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCreateGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestCreateGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerSetupFieldNumber = 3,
    kRandomSeedFieldNumber = 5,
    kDisableFogFieldNumber = 4,
    kRealtimeFieldNumber = 6,
    kLocalMapFieldNumber = 1,
    kBattlenetMapNameFieldNumber = 2,
  };
  // repeated .SC2APIProtocol.PlayerSetup player_setup = 3;
  int player_setup_size() const;
  private:
  int _internal_player_setup_size() const;
  public:
  void clear_player_setup();
  ::SC2APIProtocol::PlayerSetup* mutable_player_setup(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >*
      mutable_player_setup();
  private:
  const ::SC2APIProtocol::PlayerSetup& _internal_player_setup(int index) const;
  ::SC2APIProtocol::PlayerSetup* _internal_add_player_setup();
  public:
  const ::SC2APIProtocol::PlayerSetup& player_setup(int index) const;
  ::SC2APIProtocol::PlayerSetup* add_player_setup();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >&
      player_setup() const;

  // optional uint32 random_seed = 5;
  bool has_random_seed() const;
  private:
  bool _internal_has_random_seed() const;
  public:
  void clear_random_seed();
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed() const;
  void set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_random_seed() const;
  void _internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  private:
  bool _internal_has_disable_fog() const;
  public:
  void clear_disable_fog();
  bool disable_fog() const;
  void set_disable_fog(bool value);
  private:
  bool _internal_disable_fog() const;
  void _internal_set_disable_fog(bool value);
  public:

  // optional bool realtime = 6;
  bool has_realtime() const;
  private:
  bool _internal_has_realtime() const;
  public:
  void clear_realtime();
  bool realtime() const;
  void set_realtime(bool value);
  private:
  bool _internal_realtime() const;
  void _internal_set_realtime(bool value);
  public:

  // optional .SC2APIProtocol.LocalMap local_map = 1;
  bool has_local_map() const;
  private:
  bool _internal_has_local_map() const;
  public:
  void clear_local_map();
  const ::SC2APIProtocol::LocalMap& local_map() const;
  ::SC2APIProtocol::LocalMap* release_local_map();
  ::SC2APIProtocol::LocalMap* mutable_local_map();
  void set_allocated_local_map(::SC2APIProtocol::LocalMap* local_map);
  private:
  const ::SC2APIProtocol::LocalMap& _internal_local_map() const;
  ::SC2APIProtocol::LocalMap* _internal_mutable_local_map();
  public:

  // optional string battlenet_map_name = 2;
  bool has_battlenet_map_name() const;
  private:
  bool _internal_has_battlenet_map_name() const;
  public:
  void clear_battlenet_map_name();
  const std::string& battlenet_map_name() const;
  void set_battlenet_map_name(const std::string& value);
  void set_battlenet_map_name(std::string&& value);
  void set_battlenet_map_name(const char* value);
  void set_battlenet_map_name(const char* value, size_t size);
  std::string* mutable_battlenet_map_name();
  std::string* release_battlenet_map_name();
  void set_allocated_battlenet_map_name(std::string* battlenet_map_name);
  private:
  const std::string& _internal_battlenet_map_name() const;
  void _internal_set_battlenet_map_name(const std::string& value);
  std::string* _internal_mutable_battlenet_map_name();
  public:

  void clear_Map();
  MapCase Map_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestCreateGame)
 private:
  class _Internal;
  void set_has_local_map();
  void set_has_battlenet_map_name();

  inline bool has_Map() const;
  inline void clear_has_Map();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup > player_setup_;
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed_;
  bool disable_fog_;
  bool realtime_;
  union MapUnion {
    MapUnion() {}
    ::SC2APIProtocol::LocalMap* local_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr battlenet_map_name_;
  } Map_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class LocalMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.LocalMap) */ {
 public:
  LocalMap();
  virtual ~LocalMap();

  LocalMap(const LocalMap& from);
  LocalMap(LocalMap&& from) noexcept
    : LocalMap() {
    *this = ::std::move(from);
  }

  inline LocalMap& operator=(const LocalMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalMap& operator=(LocalMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocalMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalMap* internal_default_instance() {
    return reinterpret_cast<const LocalMap*>(
               &_LocalMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LocalMap& a, LocalMap& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocalMap* New() const final {
    return CreateMaybeMessage<LocalMap>(nullptr);
  }

  LocalMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocalMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocalMap& from);
  void MergeFrom(const LocalMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.LocalMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapPathFieldNumber = 1,
    kMapDataFieldNumber = 7,
  };
  // optional string map_path = 1;
  bool has_map_path() const;
  private:
  bool _internal_has_map_path() const;
  public:
  void clear_map_path();
  const std::string& map_path() const;
  void set_map_path(const std::string& value);
  void set_map_path(std::string&& value);
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  std::string* mutable_map_path();
  std::string* release_map_path();
  void set_allocated_map_path(std::string* map_path);
  private:
  const std::string& _internal_map_path() const;
  void _internal_set_map_path(const std::string& value);
  std::string* _internal_mutable_map_path();
  public:

  // optional bytes map_data = 7;
  bool has_map_data() const;
  private:
  bool _internal_has_map_data() const;
  public:
  void clear_map_data();
  const std::string& map_data() const;
  void set_map_data(const std::string& value);
  void set_map_data(std::string&& value);
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  std::string* mutable_map_data();
  std::string* release_map_data();
  void set_allocated_map_data(std::string* map_data);
  private:
  const std::string& _internal_map_data() const;
  void _internal_set_map_data(const std::string& value);
  std::string* _internal_mutable_map_data();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.LocalMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_data_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseCreateGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseCreateGame) */ {
 public:
  ResponseCreateGame();
  virtual ~ResponseCreateGame();

  ResponseCreateGame(const ResponseCreateGame& from);
  ResponseCreateGame(ResponseCreateGame&& from) noexcept
    : ResponseCreateGame() {
    *this = ::std::move(from);
  }

  inline ResponseCreateGame& operator=(const ResponseCreateGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseCreateGame& operator=(ResponseCreateGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseCreateGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCreateGame* internal_default_instance() {
    return reinterpret_cast<const ResponseCreateGame*>(
               &_ResponseCreateGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResponseCreateGame& a, ResponseCreateGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseCreateGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseCreateGame* New() const final {
    return CreateMaybeMessage<ResponseCreateGame>(nullptr);
  }

  ResponseCreateGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseCreateGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseCreateGame& from);
  void MergeFrom(const ResponseCreateGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCreateGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseCreateGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponseCreateGame_Error Error;
  static constexpr Error MissingMap =
    ResponseCreateGame_Error_MissingMap;
  static constexpr Error InvalidMapPath =
    ResponseCreateGame_Error_InvalidMapPath;
  static constexpr Error InvalidMapData =
    ResponseCreateGame_Error_InvalidMapData;
  static constexpr Error InvalidMapName =
    ResponseCreateGame_Error_InvalidMapName;
  static constexpr Error InvalidMapHandle =
    ResponseCreateGame_Error_InvalidMapHandle;
  static constexpr Error MissingPlayerSetup =
    ResponseCreateGame_Error_MissingPlayerSetup;
  static constexpr Error InvalidPlayerSetup =
    ResponseCreateGame_Error_InvalidPlayerSetup;
  static constexpr Error MultiplayerUnsupported =
    ResponseCreateGame_Error_MultiplayerUnsupported;
  static inline bool Error_IsValid(int value) {
    return ResponseCreateGame_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseCreateGame_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseCreateGame_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseCreateGame_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseCreateGame_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseCreateGame_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(const std::string& name,
      Error* value) {
    return ResponseCreateGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDetailsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // optional string error_details = 2;
  bool has_error_details() const;
  private:
  bool _internal_has_error_details() const;
  public:
  void clear_error_details();
  const std::string& error_details() const;
  void set_error_details(const std::string& value);
  void set_error_details(std::string&& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  std::string* mutable_error_details();
  std::string* release_error_details();
  void set_allocated_error_details(std::string* error_details);
  private:
  const std::string& _internal_error_details() const;
  void _internal_set_error_details(const std::string& value);
  std::string* _internal_mutable_error_details();
  public:

  // optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::SC2APIProtocol::ResponseCreateGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseCreateGame_Error value);
  private:
  ::SC2APIProtocol::ResponseCreateGame_Error _internal_error() const;
  void _internal_set_error(::SC2APIProtocol::ResponseCreateGame_Error value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseCreateGame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestJoinGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestJoinGame) */ {
 public:
  RequestJoinGame();
  virtual ~RequestJoinGame();

  RequestJoinGame(const RequestJoinGame& from);
  RequestJoinGame(RequestJoinGame&& from) noexcept
    : RequestJoinGame() {
    *this = ::std::move(from);
  }

  inline RequestJoinGame& operator=(const RequestJoinGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestJoinGame& operator=(RequestJoinGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestJoinGame& default_instance();

  enum ParticipationCase {
    kRace = 1,
    kObservedPlayerId = 2,
    PARTICIPATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestJoinGame* internal_default_instance() {
    return reinterpret_cast<const RequestJoinGame*>(
               &_RequestJoinGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestJoinGame& a, RequestJoinGame& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestJoinGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestJoinGame* New() const final {
    return CreateMaybeMessage<RequestJoinGame>(nullptr);
  }

  RequestJoinGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestJoinGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestJoinGame& from);
  void MergeFrom(const RequestJoinGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestJoinGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestJoinGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientPortsFieldNumber = 5,
    kPlayerNameFieldNumber = 7,
    kHostIpFieldNumber = 8,
    kOptionsFieldNumber = 3,
    kServerPortsFieldNumber = 4,
    kSharedPortFieldNumber = 6,
    kRaceFieldNumber = 1,
    kObservedPlayerIdFieldNumber = 2,
  };
  // repeated .SC2APIProtocol.PortSet client_ports = 5;
  int client_ports_size() const;
  private:
  int _internal_client_ports_size() const;
  public:
  void clear_client_ports();
  ::SC2APIProtocol::PortSet* mutable_client_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PortSet >*
      mutable_client_ports();
  private:
  const ::SC2APIProtocol::PortSet& _internal_client_ports(int index) const;
  ::SC2APIProtocol::PortSet* _internal_add_client_ports();
  public:
  const ::SC2APIProtocol::PortSet& client_ports(int index) const;
  ::SC2APIProtocol::PortSet* add_client_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PortSet >&
      client_ports() const;

  // optional string player_name = 7;
  bool has_player_name() const;
  private:
  bool _internal_has_player_name() const;
  public:
  void clear_player_name();
  const std::string& player_name() const;
  void set_player_name(const std::string& value);
  void set_player_name(std::string&& value);
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  std::string* mutable_player_name();
  std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // optional string host_ip = 8;
  bool has_host_ip() const;
  private:
  bool _internal_has_host_ip() const;
  public:
  void clear_host_ip();
  const std::string& host_ip() const;
  void set_host_ip(const std::string& value);
  void set_host_ip(std::string&& value);
  void set_host_ip(const char* value);
  void set_host_ip(const char* value, size_t size);
  std::string* mutable_host_ip();
  std::string* release_host_ip();
  void set_allocated_host_ip(std::string* host_ip);
  private:
  const std::string& _internal_host_ip() const;
  void _internal_set_host_ip(const std::string& value);
  std::string* _internal_mutable_host_ip();
  public:

  // optional .SC2APIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* release_options();
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);
  private:
  const ::SC2APIProtocol::InterfaceOptions& _internal_options() const;
  ::SC2APIProtocol::InterfaceOptions* _internal_mutable_options();
  public:

  // optional .SC2APIProtocol.PortSet server_ports = 4;
  bool has_server_ports() const;
  private:
  bool _internal_has_server_ports() const;
  public:
  void clear_server_ports();
  const ::SC2APIProtocol::PortSet& server_ports() const;
  ::SC2APIProtocol::PortSet* release_server_ports();
  ::SC2APIProtocol::PortSet* mutable_server_ports();
  void set_allocated_server_ports(::SC2APIProtocol::PortSet* server_ports);
  private:
  const ::SC2APIProtocol::PortSet& _internal_server_ports() const;
  ::SC2APIProtocol::PortSet* _internal_mutable_server_ports();
  public:

  // optional int32 shared_port = 6;
  bool has_shared_port() const;
  private:
  bool _internal_has_shared_port() const;
  public:
  void clear_shared_port();
  ::PROTOBUF_NAMESPACE_ID::int32 shared_port() const;
  void set_shared_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_shared_port() const;
  void _internal_set_shared_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .SC2APIProtocol.Race race = 1;
  bool has_race() const;
  private:
  bool _internal_has_race() const;
  public:
  void clear_race();
  ::SC2APIProtocol::Race race() const;
  void set_race(::SC2APIProtocol::Race value);
  private:
  ::SC2APIProtocol::Race _internal_race() const;
  void _internal_set_race(::SC2APIProtocol::Race value);
  public:

  // optional uint32 observed_player_id = 2;
  bool has_observed_player_id() const;
  private:
  bool _internal_has_observed_player_id() const;
  public:
  void clear_observed_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 observed_player_id() const;
  void set_observed_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_observed_player_id() const;
  void _internal_set_observed_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  void clear_participation();
  ParticipationCase participation_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestJoinGame)
 private:
  class _Internal;
  void set_has_race();
  void set_has_observed_player_id();

  inline bool has_participation() const;
  inline void clear_has_participation();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PortSet > client_ports_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_ip_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  ::SC2APIProtocol::PortSet* server_ports_;
  ::PROTOBUF_NAMESPACE_ID::int32 shared_port_;
  union ParticipationUnion {
    ParticipationUnion() {}
    int race_;
    ::PROTOBUF_NAMESPACE_ID::uint32 observed_player_id_;
  } participation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class PortSet :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PortSet) */ {
 public:
  PortSet();
  virtual ~PortSet();

  PortSet(const PortSet& from);
  PortSet(PortSet&& from) noexcept
    : PortSet() {
    *this = ::std::move(from);
  }

  inline PortSet& operator=(const PortSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortSet& operator=(PortSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PortSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortSet* internal_default_instance() {
    return reinterpret_cast<const PortSet*>(
               &_PortSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PortSet& a, PortSet& b) {
    a.Swap(&b);
  }
  inline void Swap(PortSet* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortSet* New() const final {
    return CreateMaybeMessage<PortSet>(nullptr);
  }

  PortSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortSet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PortSet& from);
  void MergeFrom(const PortSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PortSet";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGamePortFieldNumber = 1,
    kBasePortFieldNumber = 2,
  };
  // optional int32 game_port = 1;
  bool has_game_port() const;
  private:
  bool _internal_has_game_port() const;
  public:
  void clear_game_port();
  ::PROTOBUF_NAMESPACE_ID::int32 game_port() const;
  void set_game_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_game_port() const;
  void _internal_set_game_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 base_port = 2;
  bool has_base_port() const;
  private:
  bool _internal_has_base_port() const;
  public:
  void clear_base_port();
  ::PROTOBUF_NAMESPACE_ID::int32 base_port() const;
  void set_base_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_base_port() const;
  void _internal_set_base_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PortSet)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 game_port_;
  ::PROTOBUF_NAMESPACE_ID::int32 base_port_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseJoinGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseJoinGame) */ {
 public:
  ResponseJoinGame();
  virtual ~ResponseJoinGame();

  ResponseJoinGame(const ResponseJoinGame& from);
  ResponseJoinGame(ResponseJoinGame&& from) noexcept
    : ResponseJoinGame() {
    *this = ::std::move(from);
  }

  inline ResponseJoinGame& operator=(const ResponseJoinGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseJoinGame& operator=(ResponseJoinGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseJoinGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseJoinGame* internal_default_instance() {
    return reinterpret_cast<const ResponseJoinGame*>(
               &_ResponseJoinGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResponseJoinGame& a, ResponseJoinGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseJoinGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseJoinGame* New() const final {
    return CreateMaybeMessage<ResponseJoinGame>(nullptr);
  }

  ResponseJoinGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseJoinGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseJoinGame& from);
  void MergeFrom(const ResponseJoinGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseJoinGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseJoinGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponseJoinGame_Error Error;
  static constexpr Error MissingParticipation =
    ResponseJoinGame_Error_MissingParticipation;
  static constexpr Error InvalidObservedPlayerId =
    ResponseJoinGame_Error_InvalidObservedPlayerId;
  static constexpr Error MissingOptions =
    ResponseJoinGame_Error_MissingOptions;
  static constexpr Error MissingPorts =
    ResponseJoinGame_Error_MissingPorts;
  static constexpr Error GameFull =
    ResponseJoinGame_Error_GameFull;
  static constexpr Error LaunchError =
    ResponseJoinGame_Error_LaunchError;
  static constexpr Error FeatureUnsupported =
    ResponseJoinGame_Error_FeatureUnsupported;
  static constexpr Error NoSpaceForUser =
    ResponseJoinGame_Error_NoSpaceForUser;
  static constexpr Error MapDoesNotExist =
    ResponseJoinGame_Error_MapDoesNotExist;
  static constexpr Error CannotOpenMap =
    ResponseJoinGame_Error_CannotOpenMap;
  static constexpr Error ChecksumError =
    ResponseJoinGame_Error_ChecksumError;
  static constexpr Error NetworkError =
    ResponseJoinGame_Error_NetworkError;
  static constexpr Error OtherError =
    ResponseJoinGame_Error_OtherError;
  static inline bool Error_IsValid(int value) {
    return ResponseJoinGame_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseJoinGame_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseJoinGame_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseJoinGame_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseJoinGame_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseJoinGame_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(const std::string& name,
      Error* value) {
    return ResponseJoinGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDetailsFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional string error_details = 3;
  bool has_error_details() const;
  private:
  bool _internal_has_error_details() const;
  public:
  void clear_error_details();
  const std::string& error_details() const;
  void set_error_details(const std::string& value);
  void set_error_details(std::string&& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  std::string* mutable_error_details();
  std::string* release_error_details();
  void set_allocated_error_details(std::string* error_details);
  private:
  const std::string& _internal_error_details() const;
  void _internal_set_error_details(const std::string& value);
  std::string* _internal_mutable_error_details();
  public:

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::SC2APIProtocol::ResponseJoinGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseJoinGame_Error value);
  private:
  ::SC2APIProtocol::ResponseJoinGame_Error _internal_error() const;
  void _internal_set_error(::SC2APIProtocol::ResponseJoinGame_Error value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseJoinGame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_details_;
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id_;
  int error_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestRestartGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestRestartGame) */ {
 public:
  RequestRestartGame();
  virtual ~RequestRestartGame();

  RequestRestartGame(const RequestRestartGame& from);
  RequestRestartGame(RequestRestartGame&& from) noexcept
    : RequestRestartGame() {
    *this = ::std::move(from);
  }

  inline RequestRestartGame& operator=(const RequestRestartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestRestartGame& operator=(RequestRestartGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestRestartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestRestartGame* internal_default_instance() {
    return reinterpret_cast<const RequestRestartGame*>(
               &_RequestRestartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestRestartGame& a, RequestRestartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestRestartGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestRestartGame* New() const final {
    return CreateMaybeMessage<RequestRestartGame>(nullptr);
  }

  RequestRestartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestRestartGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestRestartGame& from);
  void MergeFrom(const RequestRestartGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRestartGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestRestartGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestRestartGame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseRestartGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseRestartGame) */ {
 public:
  ResponseRestartGame();
  virtual ~ResponseRestartGame();

  ResponseRestartGame(const ResponseRestartGame& from);
  ResponseRestartGame(ResponseRestartGame&& from) noexcept
    : ResponseRestartGame() {
    *this = ::std::move(from);
  }

  inline ResponseRestartGame& operator=(const ResponseRestartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseRestartGame& operator=(ResponseRestartGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseRestartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseRestartGame* internal_default_instance() {
    return reinterpret_cast<const ResponseRestartGame*>(
               &_ResponseRestartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ResponseRestartGame& a, ResponseRestartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseRestartGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseRestartGame* New() const final {
    return CreateMaybeMessage<ResponseRestartGame>(nullptr);
  }

  ResponseRestartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseRestartGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseRestartGame& from);
  void MergeFrom(const ResponseRestartGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseRestartGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseRestartGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponseRestartGame_Error Error;
  static constexpr Error LaunchError =
    ResponseRestartGame_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseRestartGame_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseRestartGame_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseRestartGame_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseRestartGame_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseRestartGame_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseRestartGame_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(const std::string& name,
      Error* value) {
    return ResponseRestartGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDetailsFieldNumber = 2,
    kNeedHardResetFieldNumber = 3,
    kErrorFieldNumber = 1,
  };
  // optional string error_details = 2;
  bool has_error_details() const;
  private:
  bool _internal_has_error_details() const;
  public:
  void clear_error_details();
  const std::string& error_details() const;
  void set_error_details(const std::string& value);
  void set_error_details(std::string&& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  std::string* mutable_error_details();
  std::string* release_error_details();
  void set_allocated_error_details(std::string* error_details);
  private:
  const std::string& _internal_error_details() const;
  void _internal_set_error_details(const std::string& value);
  std::string* _internal_mutable_error_details();
  public:

  // optional bool need_hard_reset = 3;
  bool has_need_hard_reset() const;
  private:
  bool _internal_has_need_hard_reset() const;
  public:
  void clear_need_hard_reset();
  bool need_hard_reset() const;
  void set_need_hard_reset(bool value);
  private:
  bool _internal_need_hard_reset() const;
  void _internal_set_need_hard_reset(bool value);
  public:

  // optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::SC2APIProtocol::ResponseRestartGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseRestartGame_Error value);
  private:
  ::SC2APIProtocol::ResponseRestartGame_Error _internal_error() const;
  void _internal_set_error(::SC2APIProtocol::ResponseRestartGame_Error value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseRestartGame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_details_;
  bool need_hard_reset_;
  int error_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestStartReplay :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestStartReplay) */ {
 public:
  RequestStartReplay();
  virtual ~RequestStartReplay();

  RequestStartReplay(const RequestStartReplay& from);
  RequestStartReplay(RequestStartReplay&& from) noexcept
    : RequestStartReplay() {
    *this = ::std::move(from);
  }

  inline RequestStartReplay& operator=(const RequestStartReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestStartReplay& operator=(RequestStartReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestStartReplay& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 5,
    REPLAY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestStartReplay* internal_default_instance() {
    return reinterpret_cast<const RequestStartReplay*>(
               &_RequestStartReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RequestStartReplay& a, RequestStartReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestStartReplay* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestStartReplay* New() const final {
    return CreateMaybeMessage<RequestStartReplay>(nullptr);
  }

  RequestStartReplay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestStartReplay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestStartReplay& from);
  void MergeFrom(const RequestStartReplay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStartReplay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestStartReplay";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapDataFieldNumber = 6,
    kOptionsFieldNumber = 3,
    kObservedPlayerIdFieldNumber = 2,
    kDisableFogFieldNumber = 4,
    kRealtimeFieldNumber = 7,
    kRecordReplayFieldNumber = 8,
    kReplayPathFieldNumber = 1,
    kReplayDataFieldNumber = 5,
  };
  // optional bytes map_data = 6;
  bool has_map_data() const;
  private:
  bool _internal_has_map_data() const;
  public:
  void clear_map_data();
  const std::string& map_data() const;
  void set_map_data(const std::string& value);
  void set_map_data(std::string&& value);
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  std::string* mutable_map_data();
  std::string* release_map_data();
  void set_allocated_map_data(std::string* map_data);
  private:
  const std::string& _internal_map_data() const;
  void _internal_set_map_data(const std::string& value);
  std::string* _internal_mutable_map_data();
  public:

  // optional .SC2APIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* release_options();
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);
  private:
  const ::SC2APIProtocol::InterfaceOptions& _internal_options() const;
  ::SC2APIProtocol::InterfaceOptions* _internal_mutable_options();
  public:

  // optional int32 observed_player_id = 2;
  bool has_observed_player_id() const;
  private:
  bool _internal_has_observed_player_id() const;
  public:
  void clear_observed_player_id();
  ::PROTOBUF_NAMESPACE_ID::int32 observed_player_id() const;
  void set_observed_player_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_observed_player_id() const;
  void _internal_set_observed_player_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  private:
  bool _internal_has_disable_fog() const;
  public:
  void clear_disable_fog();
  bool disable_fog() const;
  void set_disable_fog(bool value);
  private:
  bool _internal_disable_fog() const;
  void _internal_set_disable_fog(bool value);
  public:

  // optional bool realtime = 7;
  bool has_realtime() const;
  private:
  bool _internal_has_realtime() const;
  public:
  void clear_realtime();
  bool realtime() const;
  void set_realtime(bool value);
  private:
  bool _internal_realtime() const;
  void _internal_set_realtime(bool value);
  public:

  // optional bool record_replay = 8;
  bool has_record_replay() const;
  private:
  bool _internal_has_record_replay() const;
  public:
  void clear_record_replay();
  bool record_replay() const;
  void set_record_replay(bool value);
  private:
  bool _internal_record_replay() const;
  void _internal_set_record_replay(bool value);
  public:

  // optional string replay_path = 1;
  bool has_replay_path() const;
  private:
  bool _internal_has_replay_path() const;
  public:
  void clear_replay_path();
  const std::string& replay_path() const;
  void set_replay_path(const std::string& value);
  void set_replay_path(std::string&& value);
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  std::string* mutable_replay_path();
  std::string* release_replay_path();
  void set_allocated_replay_path(std::string* replay_path);
  private:
  const std::string& _internal_replay_path() const;
  void _internal_set_replay_path(const std::string& value);
  std::string* _internal_mutable_replay_path();
  public:

  // optional bytes replay_data = 5;
  bool has_replay_data() const;
  private:
  bool _internal_has_replay_data() const;
  public:
  void clear_replay_data();
  const std::string& replay_data() const;
  void set_replay_data(const std::string& value);
  void set_replay_data(std::string&& value);
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  std::string* mutable_replay_data();
  std::string* release_replay_data();
  void set_allocated_replay_data(std::string* replay_data);
  private:
  const std::string& _internal_replay_data() const;
  void _internal_set_replay_data(const std::string& value);
  std::string* _internal_mutable_replay_data();
  public:

  void clear_replay();
  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestStartReplay)
 private:
  class _Internal;
  void set_has_replay_path();
  void set_has_replay_data();

  inline bool has_replay() const;
  inline void clear_has_replay();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_data_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  ::PROTOBUF_NAMESPACE_ID::int32 observed_player_id_;
  bool disable_fog_;
  bool realtime_;
  bool record_replay_;
  union ReplayUnion {
    ReplayUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replay_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseStartReplay :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseStartReplay) */ {
 public:
  ResponseStartReplay();
  virtual ~ResponseStartReplay();

  ResponseStartReplay(const ResponseStartReplay& from);
  ResponseStartReplay(ResponseStartReplay&& from) noexcept
    : ResponseStartReplay() {
    *this = ::std::move(from);
  }

  inline ResponseStartReplay& operator=(const ResponseStartReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseStartReplay& operator=(ResponseStartReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseStartReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStartReplay* internal_default_instance() {
    return reinterpret_cast<const ResponseStartReplay*>(
               &_ResponseStartReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResponseStartReplay& a, ResponseStartReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseStartReplay* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseStartReplay* New() const final {
    return CreateMaybeMessage<ResponseStartReplay>(nullptr);
  }

  ResponseStartReplay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStartReplay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseStartReplay& from);
  void MergeFrom(const ResponseStartReplay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStartReplay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseStartReplay";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponseStartReplay_Error Error;
  static constexpr Error MissingReplay =
    ResponseStartReplay_Error_MissingReplay;
  static constexpr Error InvalidReplayPath =
    ResponseStartReplay_Error_InvalidReplayPath;
  static constexpr Error InvalidReplayData =
    ResponseStartReplay_Error_InvalidReplayData;
  static constexpr Error InvalidMapData =
    ResponseStartReplay_Error_InvalidMapData;
  static constexpr Error InvalidObservedPlayerId =
    ResponseStartReplay_Error_InvalidObservedPlayerId;
  static constexpr Error MissingOptions =
    ResponseStartReplay_Error_MissingOptions;
  static constexpr Error LaunchError =
    ResponseStartReplay_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseStartReplay_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseStartReplay_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseStartReplay_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseStartReplay_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseStartReplay_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseStartReplay_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(const std::string& name,
      Error* value) {
    return ResponseStartReplay_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDetailsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // optional string error_details = 2;
  bool has_error_details() const;
  private:
  bool _internal_has_error_details() const;
  public:
  void clear_error_details();
  const std::string& error_details() const;
  void set_error_details(const std::string& value);
  void set_error_details(std::string&& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  std::string* mutable_error_details();
  std::string* release_error_details();
  void set_allocated_error_details(std::string* error_details);
  private:
  const std::string& _internal_error_details() const;
  void _internal_set_error_details(const std::string& value);
  std::string* _internal_mutable_error_details();
  public:

  // optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::SC2APIProtocol::ResponseStartReplay_Error error() const;
  void set_error(::SC2APIProtocol::ResponseStartReplay_Error value);
  private:
  ::SC2APIProtocol::ResponseStartReplay_Error _internal_error() const;
  void _internal_set_error(::SC2APIProtocol::ResponseStartReplay_Error value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseStartReplay)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestMapCommand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestMapCommand) */ {
 public:
  RequestMapCommand();
  virtual ~RequestMapCommand();

  RequestMapCommand(const RequestMapCommand& from);
  RequestMapCommand(RequestMapCommand&& from) noexcept
    : RequestMapCommand() {
    *this = ::std::move(from);
  }

  inline RequestMapCommand& operator=(const RequestMapCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestMapCommand& operator=(RequestMapCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestMapCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestMapCommand* internal_default_instance() {
    return reinterpret_cast<const RequestMapCommand*>(
               &_RequestMapCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RequestMapCommand& a, RequestMapCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestMapCommand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestMapCommand* New() const final {
    return CreateMaybeMessage<RequestMapCommand>(nullptr);
  }

  RequestMapCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestMapCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestMapCommand& from);
  void MergeFrom(const RequestMapCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestMapCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestMapCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerCmdFieldNumber = 1,
  };
  // optional string trigger_cmd = 1;
  bool has_trigger_cmd() const;
  private:
  bool _internal_has_trigger_cmd() const;
  public:
  void clear_trigger_cmd();
  const std::string& trigger_cmd() const;
  void set_trigger_cmd(const std::string& value);
  void set_trigger_cmd(std::string&& value);
  void set_trigger_cmd(const char* value);
  void set_trigger_cmd(const char* value, size_t size);
  std::string* mutable_trigger_cmd();
  std::string* release_trigger_cmd();
  void set_allocated_trigger_cmd(std::string* trigger_cmd);
  private:
  const std::string& _internal_trigger_cmd() const;
  void _internal_set_trigger_cmd(const std::string& value);
  std::string* _internal_mutable_trigger_cmd();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestMapCommand)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_cmd_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseMapCommand :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseMapCommand) */ {
 public:
  ResponseMapCommand();
  virtual ~ResponseMapCommand();

  ResponseMapCommand(const ResponseMapCommand& from);
  ResponseMapCommand(ResponseMapCommand&& from) noexcept
    : ResponseMapCommand() {
    *this = ::std::move(from);
  }

  inline ResponseMapCommand& operator=(const ResponseMapCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseMapCommand& operator=(ResponseMapCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseMapCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseMapCommand* internal_default_instance() {
    return reinterpret_cast<const ResponseMapCommand*>(
               &_ResponseMapCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ResponseMapCommand& a, ResponseMapCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseMapCommand* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseMapCommand* New() const final {
    return CreateMaybeMessage<ResponseMapCommand>(nullptr);
  }

  ResponseMapCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseMapCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseMapCommand& from);
  void MergeFrom(const ResponseMapCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseMapCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseMapCommand";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponseMapCommand_Error Error;
  static constexpr Error NoTriggerError =
    ResponseMapCommand_Error_NoTriggerError;
  static inline bool Error_IsValid(int value) {
    return ResponseMapCommand_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseMapCommand_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseMapCommand_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseMapCommand_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseMapCommand_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseMapCommand_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(const std::string& name,
      Error* value) {
    return ResponseMapCommand_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDetailsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // optional string error_details = 2;
  bool has_error_details() const;
  private:
  bool _internal_has_error_details() const;
  public:
  void clear_error_details();
  const std::string& error_details() const;
  void set_error_details(const std::string& value);
  void set_error_details(std::string&& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  std::string* mutable_error_details();
  std::string* release_error_details();
  void set_allocated_error_details(std::string* error_details);
  private:
  const std::string& _internal_error_details() const;
  void _internal_set_error_details(const std::string& value);
  std::string* _internal_mutable_error_details();
  public:

  // optional .SC2APIProtocol.ResponseMapCommand.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::SC2APIProtocol::ResponseMapCommand_Error error() const;
  void set_error(::SC2APIProtocol::ResponseMapCommand_Error value);
  private:
  ::SC2APIProtocol::ResponseMapCommand_Error _internal_error() const;
  void _internal_set_error(::SC2APIProtocol::ResponseMapCommand_Error value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseMapCommand)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestLeaveGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestLeaveGame) */ {
 public:
  RequestLeaveGame();
  virtual ~RequestLeaveGame();

  RequestLeaveGame(const RequestLeaveGame& from);
  RequestLeaveGame(RequestLeaveGame&& from) noexcept
    : RequestLeaveGame() {
    *this = ::std::move(from);
  }

  inline RequestLeaveGame& operator=(const RequestLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLeaveGame& operator=(RequestLeaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestLeaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestLeaveGame* internal_default_instance() {
    return reinterpret_cast<const RequestLeaveGame*>(
               &_RequestLeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RequestLeaveGame& a, RequestLeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLeaveGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestLeaveGame* New() const final {
    return CreateMaybeMessage<RequestLeaveGame>(nullptr);
  }

  RequestLeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestLeaveGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestLeaveGame& from);
  void MergeFrom(const RequestLeaveGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLeaveGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestLeaveGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestLeaveGame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseLeaveGame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseLeaveGame) */ {
 public:
  ResponseLeaveGame();
  virtual ~ResponseLeaveGame();

  ResponseLeaveGame(const ResponseLeaveGame& from);
  ResponseLeaveGame(ResponseLeaveGame&& from) noexcept
    : ResponseLeaveGame() {
    *this = ::std::move(from);
  }

  inline ResponseLeaveGame& operator=(const ResponseLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseLeaveGame& operator=(ResponseLeaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseLeaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseLeaveGame* internal_default_instance() {
    return reinterpret_cast<const ResponseLeaveGame*>(
               &_ResponseLeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResponseLeaveGame& a, ResponseLeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseLeaveGame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseLeaveGame* New() const final {
    return CreateMaybeMessage<ResponseLeaveGame>(nullptr);
  }

  ResponseLeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseLeaveGame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseLeaveGame& from);
  void MergeFrom(const ResponseLeaveGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLeaveGame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseLeaveGame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseLeaveGame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestQuickSave :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuickSave) */ {
 public:
  RequestQuickSave();
  virtual ~RequestQuickSave();

  RequestQuickSave(const RequestQuickSave& from);
  RequestQuickSave(RequestQuickSave&& from) noexcept
    : RequestQuickSave() {
    *this = ::std::move(from);
  }

  inline RequestQuickSave& operator=(const RequestQuickSave& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestQuickSave& operator=(RequestQuickSave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestQuickSave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuickSave* internal_default_instance() {
    return reinterpret_cast<const RequestQuickSave*>(
               &_RequestQuickSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RequestQuickSave& a, RequestQuickSave& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestQuickSave* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestQuickSave* New() const final {
    return CreateMaybeMessage<RequestQuickSave>(nullptr);
  }

  RequestQuickSave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuickSave>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestQuickSave& from);
  void MergeFrom(const RequestQuickSave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuickSave* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestQuickSave";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuickSave)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseQuickSave :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuickSave) */ {
 public:
  ResponseQuickSave();
  virtual ~ResponseQuickSave();

  ResponseQuickSave(const ResponseQuickSave& from);
  ResponseQuickSave(ResponseQuickSave&& from) noexcept
    : ResponseQuickSave() {
    *this = ::std::move(from);
  }

  inline ResponseQuickSave& operator=(const ResponseQuickSave& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseQuickSave& operator=(ResponseQuickSave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseQuickSave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuickSave* internal_default_instance() {
    return reinterpret_cast<const ResponseQuickSave*>(
               &_ResponseQuickSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ResponseQuickSave& a, ResponseQuickSave& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseQuickSave* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuickSave* New() const final {
    return CreateMaybeMessage<ResponseQuickSave>(nullptr);
  }

  ResponseQuickSave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuickSave>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseQuickSave& from);
  void MergeFrom(const ResponseQuickSave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuickSave* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseQuickSave";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuickSave)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestQuickLoad :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuickLoad) */ {
 public:
  RequestQuickLoad();
  virtual ~RequestQuickLoad();

  RequestQuickLoad(const RequestQuickLoad& from);
  RequestQuickLoad(RequestQuickLoad&& from) noexcept
    : RequestQuickLoad() {
    *this = ::std::move(from);
  }

  inline RequestQuickLoad& operator=(const RequestQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestQuickLoad& operator=(RequestQuickLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestQuickLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuickLoad* internal_default_instance() {
    return reinterpret_cast<const RequestQuickLoad*>(
               &_RequestQuickLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RequestQuickLoad& a, RequestQuickLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestQuickLoad* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestQuickLoad* New() const final {
    return CreateMaybeMessage<RequestQuickLoad>(nullptr);
  }

  RequestQuickLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuickLoad>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestQuickLoad& from);
  void MergeFrom(const RequestQuickLoad& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuickLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestQuickLoad";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuickLoad)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseQuickLoad :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuickLoad) */ {
 public:
  ResponseQuickLoad();
  virtual ~ResponseQuickLoad();

  ResponseQuickLoad(const ResponseQuickLoad& from);
  ResponseQuickLoad(ResponseQuickLoad&& from) noexcept
    : ResponseQuickLoad() {
    *this = ::std::move(from);
  }

  inline ResponseQuickLoad& operator=(const ResponseQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseQuickLoad& operator=(ResponseQuickLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseQuickLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuickLoad* internal_default_instance() {
    return reinterpret_cast<const ResponseQuickLoad*>(
               &_ResponseQuickLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResponseQuickLoad& a, ResponseQuickLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseQuickLoad* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuickLoad* New() const final {
    return CreateMaybeMessage<ResponseQuickLoad>(nullptr);
  }

  ResponseQuickLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuickLoad>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseQuickLoad& from);
  void MergeFrom(const ResponseQuickLoad& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuickLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseQuickLoad";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuickLoad)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestQuit :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuit) */ {
 public:
  RequestQuit();
  virtual ~RequestQuit();

  RequestQuit(const RequestQuit& from);
  RequestQuit(RequestQuit&& from) noexcept
    : RequestQuit() {
    *this = ::std::move(from);
  }

  inline RequestQuit& operator=(const RequestQuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestQuit& operator=(RequestQuit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestQuit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuit* internal_default_instance() {
    return reinterpret_cast<const RequestQuit*>(
               &_RequestQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RequestQuit& a, RequestQuit& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestQuit* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestQuit* New() const final {
    return CreateMaybeMessage<RequestQuit>(nullptr);
  }

  RequestQuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestQuit& from);
  void MergeFrom(const RequestQuit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestQuit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuit)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseQuit :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuit) */ {
 public:
  ResponseQuit();
  virtual ~ResponseQuit();

  ResponseQuit(const ResponseQuit& from);
  ResponseQuit(ResponseQuit&& from) noexcept
    : ResponseQuit() {
    *this = ::std::move(from);
  }

  inline ResponseQuit& operator=(const ResponseQuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseQuit& operator=(ResponseQuit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseQuit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuit* internal_default_instance() {
    return reinterpret_cast<const ResponseQuit*>(
               &_ResponseQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ResponseQuit& a, ResponseQuit& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseQuit* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuit* New() const final {
    return CreateMaybeMessage<ResponseQuit>(nullptr);
  }

  ResponseQuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseQuit& from);
  void MergeFrom(const ResponseQuit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseQuit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuit)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestGameInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestGameInfo) */ {
 public:
  RequestGameInfo();
  virtual ~RequestGameInfo();

  RequestGameInfo(const RequestGameInfo& from);
  RequestGameInfo(RequestGameInfo&& from) noexcept
    : RequestGameInfo() {
    *this = ::std::move(from);
  }

  inline RequestGameInfo& operator=(const RequestGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestGameInfo& operator=(RequestGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestGameInfo* internal_default_instance() {
    return reinterpret_cast<const RequestGameInfo*>(
               &_RequestGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RequestGameInfo& a, RequestGameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestGameInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestGameInfo* New() const final {
    return CreateMaybeMessage<RequestGameInfo>(nullptr);
  }

  RequestGameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestGameInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestGameInfo& from);
  void MergeFrom(const RequestGameInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestGameInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestGameInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestGameInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseGameInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseGameInfo) */ {
 public:
  ResponseGameInfo();
  virtual ~ResponseGameInfo();

  ResponseGameInfo(const ResponseGameInfo& from);
  ResponseGameInfo(ResponseGameInfo&& from) noexcept
    : ResponseGameInfo() {
    *this = ::std::move(from);
  }

  inline ResponseGameInfo& operator=(const ResponseGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseGameInfo& operator=(ResponseGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseGameInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseGameInfo*>(
               &_ResponseGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ResponseGameInfo& a, ResponseGameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseGameInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseGameInfo* New() const final {
    return CreateMaybeMessage<ResponseGameInfo>(nullptr);
  }

  ResponseGameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseGameInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseGameInfo& from);
  void MergeFrom(const ResponseGameInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseGameInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseGameInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 3,
    kModNamesFieldNumber = 6,
    kMapNameFieldNumber = 1,
    kLocalMapPathFieldNumber = 2,
    kStartRawFieldNumber = 4,
    kOptionsFieldNumber = 5,
  };
  // repeated .SC2APIProtocol.PlayerInfo player_info = 3;
  int player_info_size() const;
  private:
  int _internal_player_info_size() const;
  public:
  void clear_player_info();
  ::SC2APIProtocol::PlayerInfo* mutable_player_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >*
      mutable_player_info();
  private:
  const ::SC2APIProtocol::PlayerInfo& _internal_player_info(int index) const;
  ::SC2APIProtocol::PlayerInfo* _internal_add_player_info();
  public:
  const ::SC2APIProtocol::PlayerInfo& player_info(int index) const;
  ::SC2APIProtocol::PlayerInfo* add_player_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >&
      player_info() const;

  // repeated string mod_names = 6;
  int mod_names_size() const;
  private:
  int _internal_mod_names_size() const;
  public:
  void clear_mod_names();
  const std::string& mod_names(int index) const;
  std::string* mutable_mod_names(int index);
  void set_mod_names(int index, const std::string& value);
  void set_mod_names(int index, std::string&& value);
  void set_mod_names(int index, const char* value);
  void set_mod_names(int index, const char* value, size_t size);
  std::string* add_mod_names();
  void add_mod_names(const std::string& value);
  void add_mod_names(std::string&& value);
  void add_mod_names(const char* value);
  void add_mod_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mod_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mod_names();
  private:
  const std::string& _internal_mod_names(int index) const;
  std::string* _internal_add_mod_names();
  public:

  // optional string map_name = 1;
  bool has_map_name() const;
  private:
  bool _internal_has_map_name() const;
  public:
  void clear_map_name();
  const std::string& map_name() const;
  void set_map_name(const std::string& value);
  void set_map_name(std::string&& value);
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  std::string* mutable_map_name();
  std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  private:
  bool _internal_has_local_map_path() const;
  public:
  void clear_local_map_path();
  const std::string& local_map_path() const;
  void set_local_map_path(const std::string& value);
  void set_local_map_path(std::string&& value);
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  std::string* mutable_local_map_path();
  std::string* release_local_map_path();
  void set_allocated_local_map_path(std::string* local_map_path);
  private:
  const std::string& _internal_local_map_path() const;
  void _internal_set_local_map_path(const std::string& value);
  std::string* _internal_mutable_local_map_path();
  public:

  // optional .SC2APIProtocol.StartRaw start_raw = 4;
  bool has_start_raw() const;
  private:
  bool _internal_has_start_raw() const;
  public:
  void clear_start_raw();
  const ::SC2APIProtocol::StartRaw& start_raw() const;
  ::SC2APIProtocol::StartRaw* release_start_raw();
  ::SC2APIProtocol::StartRaw* mutable_start_raw();
  void set_allocated_start_raw(::SC2APIProtocol::StartRaw* start_raw);
  private:
  const ::SC2APIProtocol::StartRaw& _internal_start_raw() const;
  ::SC2APIProtocol::StartRaw* _internal_mutable_start_raw();
  public:

  // optional .SC2APIProtocol.InterfaceOptions options = 5;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* release_options();
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);
  private:
  const ::SC2APIProtocol::InterfaceOptions& _internal_options() const;
  ::SC2APIProtocol::InterfaceOptions* _internal_mutable_options();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseGameInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo > player_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mod_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_map_path_;
  ::SC2APIProtocol::StartRaw* start_raw_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestObservation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestObservation) */ {
 public:
  RequestObservation();
  virtual ~RequestObservation();

  RequestObservation(const RequestObservation& from);
  RequestObservation(RequestObservation&& from) noexcept
    : RequestObservation() {
    *this = ::std::move(from);
  }

  inline RequestObservation& operator=(const RequestObservation& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestObservation& operator=(RequestObservation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestObservation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestObservation* internal_default_instance() {
    return reinterpret_cast<const RequestObservation*>(
               &_RequestObservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RequestObservation& a, RequestObservation& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestObservation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestObservation* New() const final {
    return CreateMaybeMessage<RequestObservation>(nullptr);
  }

  RequestObservation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestObservation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestObservation& from);
  void MergeFrom(const RequestObservation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestObservation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestObservation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisableFogFieldNumber = 1,
    kGameLoopFieldNumber = 2,
  };
  // optional bool disable_fog = 1;
  bool has_disable_fog() const;
  private:
  bool _internal_has_disable_fog() const;
  public:
  void clear_disable_fog();
  bool disable_fog() const;
  void set_disable_fog(bool value);
  private:
  bool _internal_disable_fog() const;
  void _internal_set_disable_fog(bool value);
  public:

  // optional uint32 game_loop = 2;
  bool has_game_loop() const;
  private:
  bool _internal_has_game_loop() const;
  public:
  void clear_game_loop();
  ::PROTOBUF_NAMESPACE_ID::uint32 game_loop() const;
  void set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_game_loop() const;
  void _internal_set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestObservation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool disable_fog_;
  ::PROTOBUF_NAMESPACE_ID::uint32 game_loop_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseObservation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseObservation) */ {
 public:
  ResponseObservation();
  virtual ~ResponseObservation();

  ResponseObservation(const ResponseObservation& from);
  ResponseObservation(ResponseObservation&& from) noexcept
    : ResponseObservation() {
    *this = ::std::move(from);
  }

  inline ResponseObservation& operator=(const ResponseObservation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseObservation& operator=(ResponseObservation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseObservation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseObservation* internal_default_instance() {
    return reinterpret_cast<const ResponseObservation*>(
               &_ResponseObservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ResponseObservation& a, ResponseObservation& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseObservation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseObservation* New() const final {
    return CreateMaybeMessage<ResponseObservation>(nullptr);
  }

  ResponseObservation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseObservation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseObservation& from);
  void MergeFrom(const ResponseObservation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseObservation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseObservation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
    kActionErrorsFieldNumber = 2,
    kPlayerResultFieldNumber = 4,
    kChatFieldNumber = 5,
    kObservationFieldNumber = 3,
  };
  // repeated .SC2APIProtocol.Action actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::SC2APIProtocol::Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >*
      mutable_actions();
  private:
  const ::SC2APIProtocol::Action& _internal_actions(int index) const;
  ::SC2APIProtocol::Action* _internal_add_actions();
  public:
  const ::SC2APIProtocol::Action& actions(int index) const;
  ::SC2APIProtocol::Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >&
      actions() const;

  // repeated .SC2APIProtocol.ActionError action_errors = 2;
  int action_errors_size() const;
  private:
  int _internal_action_errors_size() const;
  public:
  void clear_action_errors();
  ::SC2APIProtocol::ActionError* mutable_action_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ActionError >*
      mutable_action_errors();
  private:
  const ::SC2APIProtocol::ActionError& _internal_action_errors(int index) const;
  ::SC2APIProtocol::ActionError* _internal_add_action_errors();
  public:
  const ::SC2APIProtocol::ActionError& action_errors(int index) const;
  ::SC2APIProtocol::ActionError* add_action_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ActionError >&
      action_errors() const;

  // repeated .SC2APIProtocol.PlayerResult player_result = 4;
  int player_result_size() const;
  private:
  int _internal_player_result_size() const;
  public:
  void clear_player_result();
  ::SC2APIProtocol::PlayerResult* mutable_player_result(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >*
      mutable_player_result();
  private:
  const ::SC2APIProtocol::PlayerResult& _internal_player_result(int index) const;
  ::SC2APIProtocol::PlayerResult* _internal_add_player_result();
  public:
  const ::SC2APIProtocol::PlayerResult& player_result(int index) const;
  ::SC2APIProtocol::PlayerResult* add_player_result();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >&
      player_result() const;

  // repeated .SC2APIProtocol.ChatReceived chat = 5;
  int chat_size() const;
  private:
  int _internal_chat_size() const;
  public:
  void clear_chat();
  ::SC2APIProtocol::ChatReceived* mutable_chat(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >*
      mutable_chat();
  private:
  const ::SC2APIProtocol::ChatReceived& _internal_chat(int index) const;
  ::SC2APIProtocol::ChatReceived* _internal_add_chat();
  public:
  const ::SC2APIProtocol::ChatReceived& chat(int index) const;
  ::SC2APIProtocol::ChatReceived* add_chat();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >&
      chat() const;

  // optional .SC2APIProtocol.Observation observation = 3;
  bool has_observation() const;
  private:
  bool _internal_has_observation() const;
  public:
  void clear_observation();
  const ::SC2APIProtocol::Observation& observation() const;
  ::SC2APIProtocol::Observation* release_observation();
  ::SC2APIProtocol::Observation* mutable_observation();
  void set_allocated_observation(::SC2APIProtocol::Observation* observation);
  private:
  const ::SC2APIProtocol::Observation& _internal_observation() const;
  ::SC2APIProtocol::Observation* _internal_mutable_observation();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseObservation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action > actions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ActionError > action_errors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerResult > player_result_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ChatReceived > chat_;
  ::SC2APIProtocol::Observation* observation_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ChatReceived :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ChatReceived) */ {
 public:
  ChatReceived();
  virtual ~ChatReceived();

  ChatReceived(const ChatReceived& from);
  ChatReceived(ChatReceived&& from) noexcept
    : ChatReceived() {
    *this = ::std::move(from);
  }

  inline ChatReceived& operator=(const ChatReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatReceived& operator=(ChatReceived&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChatReceived& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatReceived* internal_default_instance() {
    return reinterpret_cast<const ChatReceived*>(
               &_ChatReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ChatReceived& a, ChatReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatReceived* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatReceived* New() const final {
    return CreateMaybeMessage<ChatReceived>(nullptr);
  }

  ChatReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatReceived>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChatReceived& from);
  void MergeFrom(const ChatReceived& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatReceived* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ChatReceived";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ChatReceived)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestAction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestAction) */ {
 public:
  RequestAction();
  virtual ~RequestAction();

  RequestAction(const RequestAction& from);
  RequestAction(RequestAction&& from) noexcept
    : RequestAction() {
    *this = ::std::move(from);
  }

  inline RequestAction& operator=(const RequestAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestAction& operator=(RequestAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestAction* internal_default_instance() {
    return reinterpret_cast<const RequestAction*>(
               &_RequestAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RequestAction& a, RequestAction& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestAction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestAction* New() const final {
    return CreateMaybeMessage<RequestAction>(nullptr);
  }

  RequestAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestAction& from);
  void MergeFrom(const RequestAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestAction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
  };
  // repeated .SC2APIProtocol.Action actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::SC2APIProtocol::Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >*
      mutable_actions();
  private:
  const ::SC2APIProtocol::Action& _internal_actions(int index) const;
  ::SC2APIProtocol::Action* _internal_add_actions();
  public:
  const ::SC2APIProtocol::Action& actions(int index) const;
  ::SC2APIProtocol::Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >&
      actions() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestAction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action > actions_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseAction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseAction) */ {
 public:
  ResponseAction();
  virtual ~ResponseAction();

  ResponseAction(const ResponseAction& from);
  ResponseAction(ResponseAction&& from) noexcept
    : ResponseAction() {
    *this = ::std::move(from);
  }

  inline ResponseAction& operator=(const ResponseAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseAction& operator=(ResponseAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseAction* internal_default_instance() {
    return reinterpret_cast<const ResponseAction*>(
               &_ResponseAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ResponseAction& a, ResponseAction& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseAction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseAction* New() const final {
    return CreateMaybeMessage<ResponseAction>(nullptr);
  }

  ResponseAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseAction& from);
  void MergeFrom(const ResponseAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseAction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // repeated .SC2APIProtocol.ActionResult result = 1;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  ::SC2APIProtocol::ActionResult _internal_result(int index) const;
  void _internal_add_result(::SC2APIProtocol::ActionResult value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_result();
  public:
  ::SC2APIProtocol::ActionResult result(int index) const;
  void set_result(int index, ::SC2APIProtocol::ActionResult value);
  void add_result(::SC2APIProtocol::ActionResult value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& result() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_result();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseAction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> result_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestObserverAction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestObserverAction) */ {
 public:
  RequestObserverAction();
  virtual ~RequestObserverAction();

  RequestObserverAction(const RequestObserverAction& from);
  RequestObserverAction(RequestObserverAction&& from) noexcept
    : RequestObserverAction() {
    *this = ::std::move(from);
  }

  inline RequestObserverAction& operator=(const RequestObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestObserverAction& operator=(RequestObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestObserverAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestObserverAction* internal_default_instance() {
    return reinterpret_cast<const RequestObserverAction*>(
               &_RequestObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RequestObserverAction& a, RequestObserverAction& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestObserverAction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestObserverAction* New() const final {
    return CreateMaybeMessage<RequestObserverAction>(nullptr);
  }

  RequestObserverAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestObserverAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestObserverAction& from);
  void MergeFrom(const RequestObserverAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestObserverAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestObserverAction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 1,
  };
  // repeated .SC2APIProtocol.ObserverAction actions = 1;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::SC2APIProtocol::ObserverAction* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >*
      mutable_actions();
  private:
  const ::SC2APIProtocol::ObserverAction& _internal_actions(int index) const;
  ::SC2APIProtocol::ObserverAction* _internal_add_actions();
  public:
  const ::SC2APIProtocol::ObserverAction& actions(int index) const;
  ::SC2APIProtocol::ObserverAction* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >&
      actions() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestObserverAction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ObserverAction > actions_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseObserverAction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseObserverAction) */ {
 public:
  ResponseObserverAction();
  virtual ~ResponseObserverAction();

  ResponseObserverAction(const ResponseObserverAction& from);
  ResponseObserverAction(ResponseObserverAction&& from) noexcept
    : ResponseObserverAction() {
    *this = ::std::move(from);
  }

  inline ResponseObserverAction& operator=(const ResponseObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseObserverAction& operator=(ResponseObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseObserverAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseObserverAction* internal_default_instance() {
    return reinterpret_cast<const ResponseObserverAction*>(
               &_ResponseObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResponseObserverAction& a, ResponseObserverAction& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseObserverAction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseObserverAction* New() const final {
    return CreateMaybeMessage<ResponseObserverAction>(nullptr);
  }

  ResponseObserverAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseObserverAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseObserverAction& from);
  void MergeFrom(const ResponseObserverAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseObserverAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseObserverAction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseObserverAction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestStep :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestStep) */ {
 public:
  RequestStep();
  virtual ~RequestStep();

  RequestStep(const RequestStep& from);
  RequestStep(RequestStep&& from) noexcept
    : RequestStep() {
    *this = ::std::move(from);
  }

  inline RequestStep& operator=(const RequestStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestStep& operator=(RequestStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestStep* internal_default_instance() {
    return reinterpret_cast<const RequestStep*>(
               &_RequestStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RequestStep& a, RequestStep& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestStep* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestStep* New() const final {
    return CreateMaybeMessage<RequestStep>(nullptr);
  }

  RequestStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestStep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestStep& from);
  void MergeFrom(const RequestStep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestStep";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // optional uint32 count = 1;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestStep)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseStep :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseStep) */ {
 public:
  ResponseStep();
  virtual ~ResponseStep();

  ResponseStep(const ResponseStep& from);
  ResponseStep(ResponseStep&& from) noexcept
    : ResponseStep() {
    *this = ::std::move(from);
  }

  inline ResponseStep& operator=(const ResponseStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseStep& operator=(ResponseStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStep* internal_default_instance() {
    return reinterpret_cast<const ResponseStep*>(
               &_ResponseStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ResponseStep& a, ResponseStep& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseStep* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseStep* New() const final {
    return CreateMaybeMessage<ResponseStep>(nullptr);
  }

  ResponseStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseStep& from);
  void MergeFrom(const ResponseStep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseStep";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationLoopFieldNumber = 1,
  };
  // optional uint32 simulation_loop = 1;
  bool has_simulation_loop() const;
  private:
  bool _internal_has_simulation_loop() const;
  public:
  void clear_simulation_loop();
  ::PROTOBUF_NAMESPACE_ID::uint32 simulation_loop() const;
  void set_simulation_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_simulation_loop() const;
  void _internal_set_simulation_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseStep)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 simulation_loop_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestData) */ {
 public:
  RequestData();
  virtual ~RequestData();

  RequestData(const RequestData& from);
  RequestData(RequestData&& from) noexcept
    : RequestData() {
    *this = ::std::move(from);
  }

  inline RequestData& operator=(const RequestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestData& operator=(RequestData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestData* internal_default_instance() {
    return reinterpret_cast<const RequestData*>(
               &_RequestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RequestData& a, RequestData& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestData* New() const final {
    return CreateMaybeMessage<RequestData>(nullptr);
  }

  RequestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestData& from);
  void MergeFrom(const RequestData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilityIdFieldNumber = 1,
    kUnitTypeIdFieldNumber = 2,
    kUpgradeIdFieldNumber = 3,
    kBuffIdFieldNumber = 4,
    kEffectIdFieldNumber = 5,
  };
  // optional bool ability_id = 1;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  bool ability_id() const;
  void set_ability_id(bool value);
  private:
  bool _internal_ability_id() const;
  void _internal_set_ability_id(bool value);
  public:

  // optional bool unit_type_id = 2;
  bool has_unit_type_id() const;
  private:
  bool _internal_has_unit_type_id() const;
  public:
  void clear_unit_type_id();
  bool unit_type_id() const;
  void set_unit_type_id(bool value);
  private:
  bool _internal_unit_type_id() const;
  void _internal_set_unit_type_id(bool value);
  public:

  // optional bool upgrade_id = 3;
  bool has_upgrade_id() const;
  private:
  bool _internal_has_upgrade_id() const;
  public:
  void clear_upgrade_id();
  bool upgrade_id() const;
  void set_upgrade_id(bool value);
  private:
  bool _internal_upgrade_id() const;
  void _internal_set_upgrade_id(bool value);
  public:

  // optional bool buff_id = 4;
  bool has_buff_id() const;
  private:
  bool _internal_has_buff_id() const;
  public:
  void clear_buff_id();
  bool buff_id() const;
  void set_buff_id(bool value);
  private:
  bool _internal_buff_id() const;
  void _internal_set_buff_id(bool value);
  public:

  // optional bool effect_id = 5;
  bool has_effect_id() const;
  private:
  bool _internal_has_effect_id() const;
  public:
  void clear_effect_id();
  bool effect_id() const;
  void set_effect_id(bool value);
  private:
  bool _internal_effect_id() const;
  void _internal_set_effect_id(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool ability_id_;
  bool unit_type_id_;
  bool upgrade_id_;
  bool buff_id_;
  bool effect_id_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseData) */ {
 public:
  ResponseData();
  virtual ~ResponseData();

  ResponseData(const ResponseData& from);
  ResponseData(ResponseData&& from) noexcept
    : ResponseData() {
    *this = ::std::move(from);
  }

  inline ResponseData& operator=(const ResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseData& operator=(ResponseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseData* internal_default_instance() {
    return reinterpret_cast<const ResponseData*>(
               &_ResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ResponseData& a, ResponseData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseData* New() const final {
    return CreateMaybeMessage<ResponseData>(nullptr);
  }

  ResponseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseData& from);
  void MergeFrom(const ResponseData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilitiesFieldNumber = 1,
    kUnitsFieldNumber = 2,
    kUpgradesFieldNumber = 3,
    kBuffsFieldNumber = 4,
    kEffectsFieldNumber = 5,
  };
  // repeated .SC2APIProtocol.AbilityData abilities = 1;
  int abilities_size() const;
  private:
  int _internal_abilities_size() const;
  public:
  void clear_abilities();
  ::SC2APIProtocol::AbilityData* mutable_abilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AbilityData >*
      mutable_abilities();
  private:
  const ::SC2APIProtocol::AbilityData& _internal_abilities(int index) const;
  ::SC2APIProtocol::AbilityData* _internal_add_abilities();
  public:
  const ::SC2APIProtocol::AbilityData& abilities(int index) const;
  ::SC2APIProtocol::AbilityData* add_abilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AbilityData >&
      abilities() const;

  // repeated .SC2APIProtocol.UnitTypeData units = 2;
  int units_size() const;
  private:
  int _internal_units_size() const;
  public:
  void clear_units();
  ::SC2APIProtocol::UnitTypeData* mutable_units(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >*
      mutable_units();
  private:
  const ::SC2APIProtocol::UnitTypeData& _internal_units(int index) const;
  ::SC2APIProtocol::UnitTypeData* _internal_add_units();
  public:
  const ::SC2APIProtocol::UnitTypeData& units(int index) const;
  ::SC2APIProtocol::UnitTypeData* add_units();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >&
      units() const;

  // repeated .SC2APIProtocol.UpgradeData upgrades = 3;
  int upgrades_size() const;
  private:
  int _internal_upgrades_size() const;
  public:
  void clear_upgrades();
  ::SC2APIProtocol::UpgradeData* mutable_upgrades(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >*
      mutable_upgrades();
  private:
  const ::SC2APIProtocol::UpgradeData& _internal_upgrades(int index) const;
  ::SC2APIProtocol::UpgradeData* _internal_add_upgrades();
  public:
  const ::SC2APIProtocol::UpgradeData& upgrades(int index) const;
  ::SC2APIProtocol::UpgradeData* add_upgrades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >&
      upgrades() const;

  // repeated .SC2APIProtocol.BuffData buffs = 4;
  int buffs_size() const;
  private:
  int _internal_buffs_size() const;
  public:
  void clear_buffs();
  ::SC2APIProtocol::BuffData* mutable_buffs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::BuffData >*
      mutable_buffs();
  private:
  const ::SC2APIProtocol::BuffData& _internal_buffs(int index) const;
  ::SC2APIProtocol::BuffData* _internal_add_buffs();
  public:
  const ::SC2APIProtocol::BuffData& buffs(int index) const;
  ::SC2APIProtocol::BuffData* add_buffs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::BuffData >&
      buffs() const;

  // repeated .SC2APIProtocol.EffectData effects = 5;
  int effects_size() const;
  private:
  int _internal_effects_size() const;
  public:
  void clear_effects();
  ::SC2APIProtocol::EffectData* mutable_effects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::EffectData >*
      mutable_effects();
  private:
  const ::SC2APIProtocol::EffectData& _internal_effects(int index) const;
  ::SC2APIProtocol::EffectData* _internal_add_effects();
  public:
  const ::SC2APIProtocol::EffectData& effects(int index) const;
  ::SC2APIProtocol::EffectData* add_effects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::EffectData >&
      effects() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AbilityData > abilities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData > units_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UpgradeData > upgrades_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::BuffData > buffs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::EffectData > effects_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestSaveReplay :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestSaveReplay) */ {
 public:
  RequestSaveReplay();
  virtual ~RequestSaveReplay();

  RequestSaveReplay(const RequestSaveReplay& from);
  RequestSaveReplay(RequestSaveReplay&& from) noexcept
    : RequestSaveReplay() {
    *this = ::std::move(from);
  }

  inline RequestSaveReplay& operator=(const RequestSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSaveReplay& operator=(RequestSaveReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestSaveReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSaveReplay* internal_default_instance() {
    return reinterpret_cast<const RequestSaveReplay*>(
               &_RequestSaveReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RequestSaveReplay& a, RequestSaveReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSaveReplay* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestSaveReplay* New() const final {
    return CreateMaybeMessage<RequestSaveReplay>(nullptr);
  }

  RequestSaveReplay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestSaveReplay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestSaveReplay& from);
  void MergeFrom(const RequestSaveReplay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSaveReplay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestSaveReplay";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestSaveReplay)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseSaveReplay :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseSaveReplay) */ {
 public:
  ResponseSaveReplay();
  virtual ~ResponseSaveReplay();

  ResponseSaveReplay(const ResponseSaveReplay& from);
  ResponseSaveReplay(ResponseSaveReplay&& from) noexcept
    : ResponseSaveReplay() {
    *this = ::std::move(from);
  }

  inline ResponseSaveReplay& operator=(const ResponseSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseSaveReplay& operator=(ResponseSaveReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseSaveReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSaveReplay* internal_default_instance() {
    return reinterpret_cast<const ResponseSaveReplay*>(
               &_ResponseSaveReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ResponseSaveReplay& a, ResponseSaveReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseSaveReplay* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseSaveReplay* New() const final {
    return CreateMaybeMessage<ResponseSaveReplay>(nullptr);
  }

  ResponseSaveReplay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseSaveReplay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseSaveReplay& from);
  void MergeFrom(const ResponseSaveReplay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSaveReplay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseSaveReplay";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // optional bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseSaveReplay)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestReplayInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestReplayInfo) */ {
 public:
  RequestReplayInfo();
  virtual ~RequestReplayInfo();

  RequestReplayInfo(const RequestReplayInfo& from);
  RequestReplayInfo(RequestReplayInfo&& from) noexcept
    : RequestReplayInfo() {
    *this = ::std::move(from);
  }

  inline RequestReplayInfo& operator=(const RequestReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestReplayInfo& operator=(RequestReplayInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestReplayInfo& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 2,
    REPLAY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestReplayInfo* internal_default_instance() {
    return reinterpret_cast<const RequestReplayInfo*>(
               &_RequestReplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(RequestReplayInfo& a, RequestReplayInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestReplayInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestReplayInfo* New() const final {
    return CreateMaybeMessage<RequestReplayInfo>(nullptr);
  }

  RequestReplayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestReplayInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestReplayInfo& from);
  void MergeFrom(const RequestReplayInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestReplayInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestReplayInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDownloadDataFieldNumber = 3,
    kReplayPathFieldNumber = 1,
    kReplayDataFieldNumber = 2,
  };
  // optional bool download_data = 3;
  bool has_download_data() const;
  private:
  bool _internal_has_download_data() const;
  public:
  void clear_download_data();
  bool download_data() const;
  void set_download_data(bool value);
  private:
  bool _internal_download_data() const;
  void _internal_set_download_data(bool value);
  public:

  // optional string replay_path = 1;
  bool has_replay_path() const;
  private:
  bool _internal_has_replay_path() const;
  public:
  void clear_replay_path();
  const std::string& replay_path() const;
  void set_replay_path(const std::string& value);
  void set_replay_path(std::string&& value);
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  std::string* mutable_replay_path();
  std::string* release_replay_path();
  void set_allocated_replay_path(std::string* replay_path);
  private:
  const std::string& _internal_replay_path() const;
  void _internal_set_replay_path(const std::string& value);
  std::string* _internal_mutable_replay_path();
  public:

  // optional bytes replay_data = 2;
  bool has_replay_data() const;
  private:
  bool _internal_has_replay_data() const;
  public:
  void clear_replay_data();
  const std::string& replay_data() const;
  void set_replay_data(const std::string& value);
  void set_replay_data(std::string&& value);
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  std::string* mutable_replay_data();
  std::string* release_replay_data();
  void set_allocated_replay_data(std::string* replay_data);
  private:
  const std::string& _internal_replay_data() const;
  void _internal_set_replay_data(const std::string& value);
  std::string* _internal_mutable_replay_data();
  public:

  void clear_replay();
  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestReplayInfo)
 private:
  class _Internal;
  void set_has_replay_path();
  void set_has_replay_data();

  inline bool has_replay() const;
  inline void clear_has_replay();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool download_data_;
  union ReplayUnion {
    ReplayUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replay_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoExtra :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerInfoExtra) */ {
 public:
  PlayerInfoExtra();
  virtual ~PlayerInfoExtra();

  PlayerInfoExtra(const PlayerInfoExtra& from);
  PlayerInfoExtra(PlayerInfoExtra&& from) noexcept
    : PlayerInfoExtra() {
    *this = ::std::move(from);
  }

  inline PlayerInfoExtra& operator=(const PlayerInfoExtra& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoExtra& operator=(PlayerInfoExtra&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerInfoExtra& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfoExtra* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoExtra*>(
               &_PlayerInfoExtra_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(PlayerInfoExtra& a, PlayerInfoExtra& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoExtra* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfoExtra* New() const final {
    return CreateMaybeMessage<PlayerInfoExtra>(nullptr);
  }

  PlayerInfoExtra* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfoExtra>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerInfoExtra& from);
  void MergeFrom(const PlayerInfoExtra& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfoExtra* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PlayerInfoExtra";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 1,
    kPlayerResultFieldNumber = 2,
    kPlayerMmrFieldNumber = 3,
    kPlayerApmFieldNumber = 4,
  };
  // optional .SC2APIProtocol.PlayerInfo player_info = 1;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::SC2APIProtocol::PlayerInfo& player_info() const;
  ::SC2APIProtocol::PlayerInfo* release_player_info();
  ::SC2APIProtocol::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::SC2APIProtocol::PlayerInfo* player_info);
  private:
  const ::SC2APIProtocol::PlayerInfo& _internal_player_info() const;
  ::SC2APIProtocol::PlayerInfo* _internal_mutable_player_info();
  public:

  // optional .SC2APIProtocol.PlayerResult player_result = 2;
  bool has_player_result() const;
  private:
  bool _internal_has_player_result() const;
  public:
  void clear_player_result();
  const ::SC2APIProtocol::PlayerResult& player_result() const;
  ::SC2APIProtocol::PlayerResult* release_player_result();
  ::SC2APIProtocol::PlayerResult* mutable_player_result();
  void set_allocated_player_result(::SC2APIProtocol::PlayerResult* player_result);
  private:
  const ::SC2APIProtocol::PlayerResult& _internal_player_result() const;
  ::SC2APIProtocol::PlayerResult* _internal_mutable_player_result();
  public:

  // optional int32 player_mmr = 3;
  bool has_player_mmr() const;
  private:
  bool _internal_has_player_mmr() const;
  public:
  void clear_player_mmr();
  ::PROTOBUF_NAMESPACE_ID::int32 player_mmr() const;
  void set_player_mmr(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_player_mmr() const;
  void _internal_set_player_mmr(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 player_apm = 4;
  bool has_player_apm() const;
  private:
  bool _internal_has_player_apm() const;
  public:
  void clear_player_apm();
  ::PROTOBUF_NAMESPACE_ID::int32 player_apm() const;
  void set_player_apm(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_player_apm() const;
  void _internal_set_player_apm(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerInfoExtra)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::PlayerInfo* player_info_;
  ::SC2APIProtocol::PlayerResult* player_result_;
  ::PROTOBUF_NAMESPACE_ID::int32 player_mmr_;
  ::PROTOBUF_NAMESPACE_ID::int32 player_apm_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseReplayInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseReplayInfo) */ {
 public:
  ResponseReplayInfo();
  virtual ~ResponseReplayInfo();

  ResponseReplayInfo(const ResponseReplayInfo& from);
  ResponseReplayInfo(ResponseReplayInfo&& from) noexcept
    : ResponseReplayInfo() {
    *this = ::std::move(from);
  }

  inline ResponseReplayInfo& operator=(const ResponseReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseReplayInfo& operator=(ResponseReplayInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseReplayInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseReplayInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseReplayInfo*>(
               &_ResponseReplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ResponseReplayInfo& a, ResponseReplayInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseReplayInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseReplayInfo* New() const final {
    return CreateMaybeMessage<ResponseReplayInfo>(nullptr);
  }

  ResponseReplayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseReplayInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseReplayInfo& from);
  void MergeFrom(const ResponseReplayInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseReplayInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseReplayInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponseReplayInfo_Error Error;
  static constexpr Error MissingReplay =
    ResponseReplayInfo_Error_MissingReplay;
  static constexpr Error InvalidReplayPath =
    ResponseReplayInfo_Error_InvalidReplayPath;
  static constexpr Error InvalidReplayData =
    ResponseReplayInfo_Error_InvalidReplayData;
  static constexpr Error ParsingError =
    ResponseReplayInfo_Error_ParsingError;
  static constexpr Error DownloadError =
    ResponseReplayInfo_Error_DownloadError;
  static inline bool Error_IsValid(int value) {
    return ResponseReplayInfo_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseReplayInfo_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseReplayInfo_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseReplayInfo_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseReplayInfo_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseReplayInfo_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(const std::string& name,
      Error* value) {
    return ResponseReplayInfo_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 3,
    kMapNameFieldNumber = 1,
    kLocalMapPathFieldNumber = 2,
    kGameVersionFieldNumber = 6,
    kErrorDetailsFieldNumber = 10,
    kDataVersionFieldNumber = 11,
    kGameDurationLoopsFieldNumber = 4,
    kGameDurationSecondsFieldNumber = 5,
    kDataBuildFieldNumber = 7,
    kBaseBuildFieldNumber = 8,
    kErrorFieldNumber = 9,
  };
  // repeated .SC2APIProtocol.PlayerInfoExtra player_info = 3;
  int player_info_size() const;
  private:
  int _internal_player_info_size() const;
  public:
  void clear_player_info();
  ::SC2APIProtocol::PlayerInfoExtra* mutable_player_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >*
      mutable_player_info();
  private:
  const ::SC2APIProtocol::PlayerInfoExtra& _internal_player_info(int index) const;
  ::SC2APIProtocol::PlayerInfoExtra* _internal_add_player_info();
  public:
  const ::SC2APIProtocol::PlayerInfoExtra& player_info(int index) const;
  ::SC2APIProtocol::PlayerInfoExtra* add_player_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >&
      player_info() const;

  // optional string map_name = 1;
  bool has_map_name() const;
  private:
  bool _internal_has_map_name() const;
  public:
  void clear_map_name();
  const std::string& map_name() const;
  void set_map_name(const std::string& value);
  void set_map_name(std::string&& value);
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  std::string* mutable_map_name();
  std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  private:
  bool _internal_has_local_map_path() const;
  public:
  void clear_local_map_path();
  const std::string& local_map_path() const;
  void set_local_map_path(const std::string& value);
  void set_local_map_path(std::string&& value);
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  std::string* mutable_local_map_path();
  std::string* release_local_map_path();
  void set_allocated_local_map_path(std::string* local_map_path);
  private:
  const std::string& _internal_local_map_path() const;
  void _internal_set_local_map_path(const std::string& value);
  std::string* _internal_mutable_local_map_path();
  public:

  // optional string game_version = 6;
  bool has_game_version() const;
  private:
  bool _internal_has_game_version() const;
  public:
  void clear_game_version();
  const std::string& game_version() const;
  void set_game_version(const std::string& value);
  void set_game_version(std::string&& value);
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  std::string* mutable_game_version();
  std::string* release_game_version();
  void set_allocated_game_version(std::string* game_version);
  private:
  const std::string& _internal_game_version() const;
  void _internal_set_game_version(const std::string& value);
  std::string* _internal_mutable_game_version();
  public:

  // optional string error_details = 10;
  bool has_error_details() const;
  private:
  bool _internal_has_error_details() const;
  public:
  void clear_error_details();
  const std::string& error_details() const;
  void set_error_details(const std::string& value);
  void set_error_details(std::string&& value);
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  std::string* mutable_error_details();
  std::string* release_error_details();
  void set_allocated_error_details(std::string* error_details);
  private:
  const std::string& _internal_error_details() const;
  void _internal_set_error_details(const std::string& value);
  std::string* _internal_mutable_error_details();
  public:

  // optional string data_version = 11;
  bool has_data_version() const;
  private:
  bool _internal_has_data_version() const;
  public:
  void clear_data_version();
  const std::string& data_version() const;
  void set_data_version(const std::string& value);
  void set_data_version(std::string&& value);
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  std::string* mutable_data_version();
  std::string* release_data_version();
  void set_allocated_data_version(std::string* data_version);
  private:
  const std::string& _internal_data_version() const;
  void _internal_set_data_version(const std::string& value);
  std::string* _internal_mutable_data_version();
  public:

  // optional uint32 game_duration_loops = 4;
  bool has_game_duration_loops() const;
  private:
  bool _internal_has_game_duration_loops() const;
  public:
  void clear_game_duration_loops();
  ::PROTOBUF_NAMESPACE_ID::uint32 game_duration_loops() const;
  void set_game_duration_loops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_game_duration_loops() const;
  void _internal_set_game_duration_loops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float game_duration_seconds = 5;
  bool has_game_duration_seconds() const;
  private:
  bool _internal_has_game_duration_seconds() const;
  public:
  void clear_game_duration_seconds();
  float game_duration_seconds() const;
  void set_game_duration_seconds(float value);
  private:
  float _internal_game_duration_seconds() const;
  void _internal_set_game_duration_seconds(float value);
  public:

  // optional uint32 data_build = 7;
  bool has_data_build() const;
  private:
  bool _internal_has_data_build() const;
  public:
  void clear_data_build();
  ::PROTOBUF_NAMESPACE_ID::uint32 data_build() const;
  void set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_data_build() const;
  void _internal_set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 base_build = 8;
  bool has_base_build() const;
  private:
  bool _internal_has_base_build() const;
  public:
  void clear_base_build();
  ::PROTOBUF_NAMESPACE_ID::uint32 base_build() const;
  void set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_base_build() const;
  void _internal_set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::SC2APIProtocol::ResponseReplayInfo_Error error() const;
  void set_error(::SC2APIProtocol::ResponseReplayInfo_Error value);
  private:
  ::SC2APIProtocol::ResponseReplayInfo_Error _internal_error() const;
  void _internal_set_error(::SC2APIProtocol::ResponseReplayInfo_Error value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseReplayInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra > player_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_map_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_details_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 game_duration_loops_;
  float game_duration_seconds_;
  ::PROTOBUF_NAMESPACE_ID::uint32 data_build_;
  ::PROTOBUF_NAMESPACE_ID::uint32 base_build_;
  int error_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestAvailableMaps :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestAvailableMaps) */ {
 public:
  RequestAvailableMaps();
  virtual ~RequestAvailableMaps();

  RequestAvailableMaps(const RequestAvailableMaps& from);
  RequestAvailableMaps(RequestAvailableMaps&& from) noexcept
    : RequestAvailableMaps() {
    *this = ::std::move(from);
  }

  inline RequestAvailableMaps& operator=(const RequestAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestAvailableMaps& operator=(RequestAvailableMaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestAvailableMaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestAvailableMaps* internal_default_instance() {
    return reinterpret_cast<const RequestAvailableMaps*>(
               &_RequestAvailableMaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(RequestAvailableMaps& a, RequestAvailableMaps& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestAvailableMaps* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestAvailableMaps* New() const final {
    return CreateMaybeMessage<RequestAvailableMaps>(nullptr);
  }

  RequestAvailableMaps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestAvailableMaps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestAvailableMaps& from);
  void MergeFrom(const RequestAvailableMaps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAvailableMaps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestAvailableMaps";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestAvailableMaps)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseAvailableMaps :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseAvailableMaps) */ {
 public:
  ResponseAvailableMaps();
  virtual ~ResponseAvailableMaps();

  ResponseAvailableMaps(const ResponseAvailableMaps& from);
  ResponseAvailableMaps(ResponseAvailableMaps&& from) noexcept
    : ResponseAvailableMaps() {
    *this = ::std::move(from);
  }

  inline ResponseAvailableMaps& operator=(const ResponseAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseAvailableMaps& operator=(ResponseAvailableMaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseAvailableMaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseAvailableMaps* internal_default_instance() {
    return reinterpret_cast<const ResponseAvailableMaps*>(
               &_ResponseAvailableMaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ResponseAvailableMaps& a, ResponseAvailableMaps& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseAvailableMaps* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseAvailableMaps* New() const final {
    return CreateMaybeMessage<ResponseAvailableMaps>(nullptr);
  }

  ResponseAvailableMaps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseAvailableMaps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseAvailableMaps& from);
  void MergeFrom(const ResponseAvailableMaps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAvailableMaps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseAvailableMaps";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalMapPathsFieldNumber = 1,
    kBattlenetMapNamesFieldNumber = 2,
  };
  // repeated string local_map_paths = 1;
  int local_map_paths_size() const;
  private:
  int _internal_local_map_paths_size() const;
  public:
  void clear_local_map_paths();
  const std::string& local_map_paths(int index) const;
  std::string* mutable_local_map_paths(int index);
  void set_local_map_paths(int index, const std::string& value);
  void set_local_map_paths(int index, std::string&& value);
  void set_local_map_paths(int index, const char* value);
  void set_local_map_paths(int index, const char* value, size_t size);
  std::string* add_local_map_paths();
  void add_local_map_paths(const std::string& value);
  void add_local_map_paths(std::string&& value);
  void add_local_map_paths(const char* value);
  void add_local_map_paths(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& local_map_paths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_local_map_paths();
  private:
  const std::string& _internal_local_map_paths(int index) const;
  std::string* _internal_add_local_map_paths();
  public:

  // repeated string battlenet_map_names = 2;
  int battlenet_map_names_size() const;
  private:
  int _internal_battlenet_map_names_size() const;
  public:
  void clear_battlenet_map_names();
  const std::string& battlenet_map_names(int index) const;
  std::string* mutable_battlenet_map_names(int index);
  void set_battlenet_map_names(int index, const std::string& value);
  void set_battlenet_map_names(int index, std::string&& value);
  void set_battlenet_map_names(int index, const char* value);
  void set_battlenet_map_names(int index, const char* value, size_t size);
  std::string* add_battlenet_map_names();
  void add_battlenet_map_names(const std::string& value);
  void add_battlenet_map_names(std::string&& value);
  void add_battlenet_map_names(const char* value);
  void add_battlenet_map_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& battlenet_map_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_battlenet_map_names();
  private:
  const std::string& _internal_battlenet_map_names(int index) const;
  std::string* _internal_add_battlenet_map_names();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseAvailableMaps)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> local_map_paths_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> battlenet_map_names_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestSaveMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestSaveMap) */ {
 public:
  RequestSaveMap();
  virtual ~RequestSaveMap();

  RequestSaveMap(const RequestSaveMap& from);
  RequestSaveMap(RequestSaveMap&& from) noexcept
    : RequestSaveMap() {
    *this = ::std::move(from);
  }

  inline RequestSaveMap& operator=(const RequestSaveMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSaveMap& operator=(RequestSaveMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestSaveMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSaveMap* internal_default_instance() {
    return reinterpret_cast<const RequestSaveMap*>(
               &_RequestSaveMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(RequestSaveMap& a, RequestSaveMap& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSaveMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestSaveMap* New() const final {
    return CreateMaybeMessage<RequestSaveMap>(nullptr);
  }

  RequestSaveMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestSaveMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestSaveMap& from);
  void MergeFrom(const RequestSaveMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSaveMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestSaveMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapPathFieldNumber = 1,
    kMapDataFieldNumber = 2,
  };
  // optional string map_path = 1;
  bool has_map_path() const;
  private:
  bool _internal_has_map_path() const;
  public:
  void clear_map_path();
  const std::string& map_path() const;
  void set_map_path(const std::string& value);
  void set_map_path(std::string&& value);
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  std::string* mutable_map_path();
  std::string* release_map_path();
  void set_allocated_map_path(std::string* map_path);
  private:
  const std::string& _internal_map_path() const;
  void _internal_set_map_path(const std::string& value);
  std::string* _internal_mutable_map_path();
  public:

  // optional bytes map_data = 2;
  bool has_map_data() const;
  private:
  bool _internal_has_map_data() const;
  public:
  void clear_map_data();
  const std::string& map_data() const;
  void set_map_data(const std::string& value);
  void set_map_data(std::string&& value);
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  std::string* mutable_map_data();
  std::string* release_map_data();
  void set_allocated_map_data(std::string* map_data);
  private:
  const std::string& _internal_map_data() const;
  void _internal_set_map_data(const std::string& value);
  std::string* _internal_mutable_map_data();
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestSaveMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_data_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseSaveMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseSaveMap) */ {
 public:
  ResponseSaveMap();
  virtual ~ResponseSaveMap();

  ResponseSaveMap(const ResponseSaveMap& from);
  ResponseSaveMap(ResponseSaveMap&& from) noexcept
    : ResponseSaveMap() {
    *this = ::std::move(from);
  }

  inline ResponseSaveMap& operator=(const ResponseSaveMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseSaveMap& operator=(ResponseSaveMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseSaveMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSaveMap* internal_default_instance() {
    return reinterpret_cast<const ResponseSaveMap*>(
               &_ResponseSaveMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ResponseSaveMap& a, ResponseSaveMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseSaveMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseSaveMap* New() const final {
    return CreateMaybeMessage<ResponseSaveMap>(nullptr);
  }

  ResponseSaveMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseSaveMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseSaveMap& from);
  void MergeFrom(const ResponseSaveMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSaveMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseSaveMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ResponseSaveMap_Error Error;
  static constexpr Error InvalidMapData =
    ResponseSaveMap_Error_InvalidMapData;
  static inline bool Error_IsValid(int value) {
    return ResponseSaveMap_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    ResponseSaveMap_Error_Error_MIN;
  static constexpr Error Error_MAX =
    ResponseSaveMap_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    ResponseSaveMap_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return ResponseSaveMap_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return ResponseSaveMap_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(const std::string& name,
      Error* value) {
    return ResponseSaveMap_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::SC2APIProtocol::ResponseSaveMap_Error error() const;
  void set_error(::SC2APIProtocol::ResponseSaveMap_Error value);
  private:
  ::SC2APIProtocol::ResponseSaveMap_Error _internal_error() const;
  void _internal_set_error(::SC2APIProtocol::ResponseSaveMap_Error value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseSaveMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int error_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestPing :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestPing) */ {
 public:
  RequestPing();
  virtual ~RequestPing();

  RequestPing(const RequestPing& from);
  RequestPing(RequestPing&& from) noexcept
    : RequestPing() {
    *this = ::std::move(from);
  }

  inline RequestPing& operator=(const RequestPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestPing& operator=(RequestPing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestPing* internal_default_instance() {
    return reinterpret_cast<const RequestPing*>(
               &_RequestPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(RequestPing& a, RequestPing& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestPing* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestPing* New() const final {
    return CreateMaybeMessage<RequestPing>(nullptr);
  }

  RequestPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestPing>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestPing& from);
  void MergeFrom(const RequestPing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestPing";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestPing)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponsePing :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponsePing) */ {
 public:
  ResponsePing();
  virtual ~ResponsePing();

  ResponsePing(const ResponsePing& from);
  ResponsePing(ResponsePing&& from) noexcept
    : ResponsePing() {
    *this = ::std::move(from);
  }

  inline ResponsePing& operator=(const ResponsePing& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponsePing& operator=(ResponsePing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponsePing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponsePing* internal_default_instance() {
    return reinterpret_cast<const ResponsePing*>(
               &_ResponsePing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ResponsePing& a, ResponsePing& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponsePing* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponsePing* New() const final {
    return CreateMaybeMessage<ResponsePing>(nullptr);
  }

  ResponsePing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponsePing>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponsePing& from);
  void MergeFrom(const ResponsePing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponsePing";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameVersionFieldNumber = 1,
    kDataVersionFieldNumber = 2,
    kDataBuildFieldNumber = 3,
    kBaseBuildFieldNumber = 4,
  };
  // optional string game_version = 1;
  bool has_game_version() const;
  private:
  bool _internal_has_game_version() const;
  public:
  void clear_game_version();
  const std::string& game_version() const;
  void set_game_version(const std::string& value);
  void set_game_version(std::string&& value);
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  std::string* mutable_game_version();
  std::string* release_game_version();
  void set_allocated_game_version(std::string* game_version);
  private:
  const std::string& _internal_game_version() const;
  void _internal_set_game_version(const std::string& value);
  std::string* _internal_mutable_game_version();
  public:

  // optional string data_version = 2;
  bool has_data_version() const;
  private:
  bool _internal_has_data_version() const;
  public:
  void clear_data_version();
  const std::string& data_version() const;
  void set_data_version(const std::string& value);
  void set_data_version(std::string&& value);
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  std::string* mutable_data_version();
  std::string* release_data_version();
  void set_allocated_data_version(std::string* data_version);
  private:
  const std::string& _internal_data_version() const;
  void _internal_set_data_version(const std::string& value);
  std::string* _internal_mutable_data_version();
  public:

  // optional uint32 data_build = 3;
  bool has_data_build() const;
  private:
  bool _internal_has_data_build() const;
  public:
  void clear_data_build();
  ::PROTOBUF_NAMESPACE_ID::uint32 data_build() const;
  void set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_data_build() const;
  void _internal_set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 base_build = 4;
  bool has_base_build() const;
  private:
  bool _internal_has_base_build() const;
  public:
  void clear_base_build();
  ::PROTOBUF_NAMESPACE_ID::uint32 base_build() const;
  void set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_base_build() const;
  void _internal_set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponsePing)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 data_build_;
  ::PROTOBUF_NAMESPACE_ID::uint32 base_build_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class RequestDebug :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestDebug) */ {
 public:
  RequestDebug();
  virtual ~RequestDebug();

  RequestDebug(const RequestDebug& from);
  RequestDebug(RequestDebug&& from) noexcept
    : RequestDebug() {
    *this = ::std::move(from);
  }

  inline RequestDebug& operator=(const RequestDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestDebug& operator=(RequestDebug&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestDebug& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestDebug* internal_default_instance() {
    return reinterpret_cast<const RequestDebug*>(
               &_RequestDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(RequestDebug& a, RequestDebug& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestDebug* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestDebug* New() const final {
    return CreateMaybeMessage<RequestDebug>(nullptr);
  }

  RequestDebug* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestDebug>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestDebug& from);
  void MergeFrom(const RequestDebug& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDebug* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.RequestDebug";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDebugFieldNumber = 1,
  };
  // repeated .SC2APIProtocol.DebugCommand debug = 1;
  int debug_size() const;
  private:
  int _internal_debug_size() const;
  public:
  void clear_debug();
  ::SC2APIProtocol::DebugCommand* mutable_debug(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >*
      mutable_debug();
  private:
  const ::SC2APIProtocol::DebugCommand& _internal_debug(int index) const;
  ::SC2APIProtocol::DebugCommand* _internal_add_debug();
  public:
  const ::SC2APIProtocol::DebugCommand& debug(int index) const;
  ::SC2APIProtocol::DebugCommand* add_debug();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >&
      debug() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestDebug)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugCommand > debug_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ResponseDebug :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseDebug) */ {
 public:
  ResponseDebug();
  virtual ~ResponseDebug();

  ResponseDebug(const ResponseDebug& from);
  ResponseDebug(ResponseDebug&& from) noexcept
    : ResponseDebug() {
    *this = ::std::move(from);
  }

  inline ResponseDebug& operator=(const ResponseDebug& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseDebug& operator=(ResponseDebug&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseDebug& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseDebug* internal_default_instance() {
    return reinterpret_cast<const ResponseDebug*>(
               &_ResponseDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ResponseDebug& a, ResponseDebug& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseDebug* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResponseDebug* New() const final {
    return CreateMaybeMessage<ResponseDebug>(nullptr);
  }

  ResponseDebug* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseDebug>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseDebug& from);
  void MergeFrom(const ResponseDebug& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDebug* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ResponseDebug";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseDebug)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class PlayerSetup :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerSetup) */ {
 public:
  PlayerSetup();
  virtual ~PlayerSetup();

  PlayerSetup(const PlayerSetup& from);
  PlayerSetup(PlayerSetup&& from) noexcept
    : PlayerSetup() {
    *this = ::std::move(from);
  }

  inline PlayerSetup& operator=(const PlayerSetup& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerSetup& operator=(PlayerSetup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerSetup* internal_default_instance() {
    return reinterpret_cast<const PlayerSetup*>(
               &_PlayerSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(PlayerSetup& a, PlayerSetup& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerSetup* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerSetup* New() const final {
    return CreateMaybeMessage<PlayerSetup>(nullptr);
  }

  PlayerSetup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerSetup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerSetup& from);
  void MergeFrom(const PlayerSetup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerSetup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PlayerSetup";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 4,
    kRaceFieldNumber = 2,
    kAiBuildFieldNumber = 5,
    kTypeFieldNumber = 1,
    kDifficultyFieldNumber = 3,
  };
  // optional string player_name = 4;
  bool has_player_name() const;
  private:
  bool _internal_has_player_name() const;
  public:
  void clear_player_name();
  const std::string& player_name() const;
  void set_player_name(const std::string& value);
  void set_player_name(std::string&& value);
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  std::string* mutable_player_name();
  std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // optional .SC2APIProtocol.Race race = 2;
  bool has_race() const;
  private:
  bool _internal_has_race() const;
  public:
  void clear_race();
  ::SC2APIProtocol::Race race() const;
  void set_race(::SC2APIProtocol::Race value);
  private:
  ::SC2APIProtocol::Race _internal_race() const;
  void _internal_set_race(::SC2APIProtocol::Race value);
  public:

  // optional .SC2APIProtocol.AIBuild ai_build = 5;
  bool has_ai_build() const;
  private:
  bool _internal_has_ai_build() const;
  public:
  void clear_ai_build();
  ::SC2APIProtocol::AIBuild ai_build() const;
  void set_ai_build(::SC2APIProtocol::AIBuild value);
  private:
  ::SC2APIProtocol::AIBuild _internal_ai_build() const;
  void _internal_set_ai_build(::SC2APIProtocol::AIBuild value);
  public:

  // optional .SC2APIProtocol.PlayerType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SC2APIProtocol::PlayerType type() const;
  void set_type(::SC2APIProtocol::PlayerType value);
  private:
  ::SC2APIProtocol::PlayerType _internal_type() const;
  void _internal_set_type(::SC2APIProtocol::PlayerType value);
  public:

  // optional .SC2APIProtocol.Difficulty difficulty = 3;
  bool has_difficulty() const;
  private:
  bool _internal_has_difficulty() const;
  public:
  void clear_difficulty();
  ::SC2APIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SC2APIProtocol::Difficulty value);
  private:
  ::SC2APIProtocol::Difficulty _internal_difficulty() const;
  void _internal_set_difficulty(::SC2APIProtocol::Difficulty value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerSetup)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
  int race_;
  int ai_build_;
  int type_;
  int difficulty_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class SpatialCameraSetup :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.SpatialCameraSetup) */ {
 public:
  SpatialCameraSetup();
  virtual ~SpatialCameraSetup();

  SpatialCameraSetup(const SpatialCameraSetup& from);
  SpatialCameraSetup(SpatialCameraSetup&& from) noexcept
    : SpatialCameraSetup() {
    *this = ::std::move(from);
  }

  inline SpatialCameraSetup& operator=(const SpatialCameraSetup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpatialCameraSetup& operator=(SpatialCameraSetup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpatialCameraSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpatialCameraSetup* internal_default_instance() {
    return reinterpret_cast<const SpatialCameraSetup*>(
               &_SpatialCameraSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(SpatialCameraSetup& a, SpatialCameraSetup& b) {
    a.Swap(&b);
  }
  inline void Swap(SpatialCameraSetup* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpatialCameraSetup* New() const final {
    return CreateMaybeMessage<SpatialCameraSetup>(nullptr);
  }

  SpatialCameraSetup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpatialCameraSetup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpatialCameraSetup& from);
  void MergeFrom(const SpatialCameraSetup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatialCameraSetup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.SpatialCameraSetup";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResolutionFieldNumber = 2,
    kMinimapResolutionFieldNumber = 3,
    kWidthFieldNumber = 1,
    kCropToPlayableAreaFieldNumber = 4,
    kAllowCheatingLayersFieldNumber = 5,
  };
  // optional .SC2APIProtocol.Size2DI resolution = 2;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  const ::SC2APIProtocol::Size2DI& resolution() const;
  ::SC2APIProtocol::Size2DI* release_resolution();
  ::SC2APIProtocol::Size2DI* mutable_resolution();
  void set_allocated_resolution(::SC2APIProtocol::Size2DI* resolution);
  private:
  const ::SC2APIProtocol::Size2DI& _internal_resolution() const;
  ::SC2APIProtocol::Size2DI* _internal_mutable_resolution();
  public:

  // optional .SC2APIProtocol.Size2DI minimap_resolution = 3;
  bool has_minimap_resolution() const;
  private:
  bool _internal_has_minimap_resolution() const;
  public:
  void clear_minimap_resolution();
  const ::SC2APIProtocol::Size2DI& minimap_resolution() const;
  ::SC2APIProtocol::Size2DI* release_minimap_resolution();
  ::SC2APIProtocol::Size2DI* mutable_minimap_resolution();
  void set_allocated_minimap_resolution(::SC2APIProtocol::Size2DI* minimap_resolution);
  private:
  const ::SC2APIProtocol::Size2DI& _internal_minimap_resolution() const;
  ::SC2APIProtocol::Size2DI* _internal_mutable_minimap_resolution();
  public:

  // optional float width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // optional bool crop_to_playable_area = 4;
  bool has_crop_to_playable_area() const;
  private:
  bool _internal_has_crop_to_playable_area() const;
  public:
  void clear_crop_to_playable_area();
  bool crop_to_playable_area() const;
  void set_crop_to_playable_area(bool value);
  private:
  bool _internal_crop_to_playable_area() const;
  void _internal_set_crop_to_playable_area(bool value);
  public:

  // optional bool allow_cheating_layers = 5;
  bool has_allow_cheating_layers() const;
  private:
  bool _internal_has_allow_cheating_layers() const;
  public:
  void clear_allow_cheating_layers();
  bool allow_cheating_layers() const;
  void set_allow_cheating_layers(bool value);
  private:
  bool _internal_allow_cheating_layers() const;
  void _internal_set_allow_cheating_layers(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.SpatialCameraSetup)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Size2DI* resolution_;
  ::SC2APIProtocol::Size2DI* minimap_resolution_;
  float width_;
  bool crop_to_playable_area_;
  bool allow_cheating_layers_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class InterfaceOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.InterfaceOptions) */ {
 public:
  InterfaceOptions();
  virtual ~InterfaceOptions();

  InterfaceOptions(const InterfaceOptions& from);
  InterfaceOptions(InterfaceOptions&& from) noexcept
    : InterfaceOptions() {
    *this = ::std::move(from);
  }

  inline InterfaceOptions& operator=(const InterfaceOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceOptions& operator=(InterfaceOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InterfaceOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InterfaceOptions* internal_default_instance() {
    return reinterpret_cast<const InterfaceOptions*>(
               &_InterfaceOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(InterfaceOptions& a, InterfaceOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InterfaceOptions* New() const final {
    return CreateMaybeMessage<InterfaceOptions>(nullptr);
  }

  InterfaceOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InterfaceOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InterfaceOptions& from);
  void MergeFrom(const InterfaceOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.InterfaceOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureLayerFieldNumber = 3,
    kRenderFieldNumber = 4,
    kRawFieldNumber = 1,
    kScoreFieldNumber = 2,
    kShowCloakedFieldNumber = 5,
    kShowBurrowedShadowsFieldNumber = 9,
    kShowPlaceholdersFieldNumber = 8,
    kRawAffectsSelectionFieldNumber = 6,
    kRawCropToPlayableAreaFieldNumber = 7,
  };
  // optional .SC2APIProtocol.SpatialCameraSetup feature_layer = 3;
  bool has_feature_layer() const;
  private:
  bool _internal_has_feature_layer() const;
  public:
  void clear_feature_layer();
  const ::SC2APIProtocol::SpatialCameraSetup& feature_layer() const;
  ::SC2APIProtocol::SpatialCameraSetup* release_feature_layer();
  ::SC2APIProtocol::SpatialCameraSetup* mutable_feature_layer();
  void set_allocated_feature_layer(::SC2APIProtocol::SpatialCameraSetup* feature_layer);
  private:
  const ::SC2APIProtocol::SpatialCameraSetup& _internal_feature_layer() const;
  ::SC2APIProtocol::SpatialCameraSetup* _internal_mutable_feature_layer();
  public:

  // optional .SC2APIProtocol.SpatialCameraSetup render = 4;
  bool has_render() const;
  private:
  bool _internal_has_render() const;
  public:
  void clear_render();
  const ::SC2APIProtocol::SpatialCameraSetup& render() const;
  ::SC2APIProtocol::SpatialCameraSetup* release_render();
  ::SC2APIProtocol::SpatialCameraSetup* mutable_render();
  void set_allocated_render(::SC2APIProtocol::SpatialCameraSetup* render);
  private:
  const ::SC2APIProtocol::SpatialCameraSetup& _internal_render() const;
  ::SC2APIProtocol::SpatialCameraSetup* _internal_mutable_render();
  public:

  // optional bool raw = 1;
  bool has_raw() const;
  private:
  bool _internal_has_raw() const;
  public:
  void clear_raw();
  bool raw() const;
  void set_raw(bool value);
  private:
  bool _internal_raw() const;
  void _internal_set_raw(bool value);
  public:

  // optional bool score = 2;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  bool score() const;
  void set_score(bool value);
  private:
  bool _internal_score() const;
  void _internal_set_score(bool value);
  public:

  // optional bool show_cloaked = 5;
  bool has_show_cloaked() const;
  private:
  bool _internal_has_show_cloaked() const;
  public:
  void clear_show_cloaked();
  bool show_cloaked() const;
  void set_show_cloaked(bool value);
  private:
  bool _internal_show_cloaked() const;
  void _internal_set_show_cloaked(bool value);
  public:

  // optional bool show_burrowed_shadows = 9;
  bool has_show_burrowed_shadows() const;
  private:
  bool _internal_has_show_burrowed_shadows() const;
  public:
  void clear_show_burrowed_shadows();
  bool show_burrowed_shadows() const;
  void set_show_burrowed_shadows(bool value);
  private:
  bool _internal_show_burrowed_shadows() const;
  void _internal_set_show_burrowed_shadows(bool value);
  public:

  // optional bool show_placeholders = 8;
  bool has_show_placeholders() const;
  private:
  bool _internal_has_show_placeholders() const;
  public:
  void clear_show_placeholders();
  bool show_placeholders() const;
  void set_show_placeholders(bool value);
  private:
  bool _internal_show_placeholders() const;
  void _internal_set_show_placeholders(bool value);
  public:

  // optional bool raw_affects_selection = 6;
  bool has_raw_affects_selection() const;
  private:
  bool _internal_has_raw_affects_selection() const;
  public:
  void clear_raw_affects_selection();
  bool raw_affects_selection() const;
  void set_raw_affects_selection(bool value);
  private:
  bool _internal_raw_affects_selection() const;
  void _internal_set_raw_affects_selection(bool value);
  public:

  // optional bool raw_crop_to_playable_area = 7;
  bool has_raw_crop_to_playable_area() const;
  private:
  bool _internal_has_raw_crop_to_playable_area() const;
  public:
  void clear_raw_crop_to_playable_area();
  bool raw_crop_to_playable_area() const;
  void set_raw_crop_to_playable_area(bool value);
  private:
  bool _internal_raw_crop_to_playable_area() const;
  void _internal_set_raw_crop_to_playable_area(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.InterfaceOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::SpatialCameraSetup* feature_layer_;
  ::SC2APIProtocol::SpatialCameraSetup* render_;
  bool raw_;
  bool score_;
  bool show_cloaked_;
  bool show_burrowed_shadows_;
  bool show_placeholders_;
  bool raw_affects_selection_;
  bool raw_crop_to_playable_area_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(nullptr);
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PlayerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 6,
    kPlayerIdFieldNumber = 1,
    kRaceRequestedFieldNumber = 3,
    kRaceActualFieldNumber = 4,
    kAiBuildFieldNumber = 7,
    kTypeFieldNumber = 2,
    kDifficultyFieldNumber = 5,
  };
  // optional string player_name = 6;
  bool has_player_name() const;
  private:
  bool _internal_has_player_name() const;
  public:
  void clear_player_name();
  const std::string& player_name() const;
  void set_player_name(const std::string& value);
  void set_player_name(std::string&& value);
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  std::string* mutable_player_name();
  std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SC2APIProtocol.Race race_requested = 3;
  bool has_race_requested() const;
  private:
  bool _internal_has_race_requested() const;
  public:
  void clear_race_requested();
  ::SC2APIProtocol::Race race_requested() const;
  void set_race_requested(::SC2APIProtocol::Race value);
  private:
  ::SC2APIProtocol::Race _internal_race_requested() const;
  void _internal_set_race_requested(::SC2APIProtocol::Race value);
  public:

  // optional .SC2APIProtocol.Race race_actual = 4;
  bool has_race_actual() const;
  private:
  bool _internal_has_race_actual() const;
  public:
  void clear_race_actual();
  ::SC2APIProtocol::Race race_actual() const;
  void set_race_actual(::SC2APIProtocol::Race value);
  private:
  ::SC2APIProtocol::Race _internal_race_actual() const;
  void _internal_set_race_actual(::SC2APIProtocol::Race value);
  public:

  // optional .SC2APIProtocol.AIBuild ai_build = 7;
  bool has_ai_build() const;
  private:
  bool _internal_has_ai_build() const;
  public:
  void clear_ai_build();
  ::SC2APIProtocol::AIBuild ai_build() const;
  void set_ai_build(::SC2APIProtocol::AIBuild value);
  private:
  ::SC2APIProtocol::AIBuild _internal_ai_build() const;
  void _internal_set_ai_build(::SC2APIProtocol::AIBuild value);
  public:

  // optional .SC2APIProtocol.PlayerType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SC2APIProtocol::PlayerType type() const;
  void set_type(::SC2APIProtocol::PlayerType value);
  private:
  ::SC2APIProtocol::PlayerType _internal_type() const;
  void _internal_set_type(::SC2APIProtocol::PlayerType value);
  public:

  // optional .SC2APIProtocol.Difficulty difficulty = 5;
  bool has_difficulty() const;
  private:
  bool _internal_has_difficulty() const;
  public:
  void clear_difficulty();
  ::SC2APIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SC2APIProtocol::Difficulty value);
  private:
  ::SC2APIProtocol::Difficulty _internal_difficulty() const;
  void _internal_set_difficulty(::SC2APIProtocol::Difficulty value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id_;
  int race_requested_;
  int race_actual_;
  int ai_build_;
  int type_;
  int difficulty_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class PlayerCommon :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerCommon) */ {
 public:
  PlayerCommon();
  virtual ~PlayerCommon();

  PlayerCommon(const PlayerCommon& from);
  PlayerCommon(PlayerCommon&& from) noexcept
    : PlayerCommon() {
    *this = ::std::move(from);
  }

  inline PlayerCommon& operator=(const PlayerCommon& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCommon& operator=(PlayerCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerCommon* internal_default_instance() {
    return reinterpret_cast<const PlayerCommon*>(
               &_PlayerCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(PlayerCommon& a, PlayerCommon& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCommon* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerCommon* New() const final {
    return CreateMaybeMessage<PlayerCommon>(nullptr);
  }

  PlayerCommon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerCommon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerCommon& from);
  void MergeFrom(const PlayerCommon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCommon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PlayerCommon";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kMineralsFieldNumber = 2,
    kVespeneFieldNumber = 3,
    kFoodCapFieldNumber = 4,
    kFoodUsedFieldNumber = 5,
    kFoodArmyFieldNumber = 6,
    kFoodWorkersFieldNumber = 7,
    kIdleWorkerCountFieldNumber = 8,
    kArmyCountFieldNumber = 9,
    kWarpGateCountFieldNumber = 10,
    kLarvaCountFieldNumber = 11,
  };
  // optional uint32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 minerals = 2;
  bool has_minerals() const;
  private:
  bool _internal_has_minerals() const;
  public:
  void clear_minerals();
  ::PROTOBUF_NAMESPACE_ID::uint32 minerals() const;
  void set_minerals(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_minerals() const;
  void _internal_set_minerals(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 vespene = 3;
  bool has_vespene() const;
  private:
  bool _internal_has_vespene() const;
  public:
  void clear_vespene();
  ::PROTOBUF_NAMESPACE_ID::uint32 vespene() const;
  void set_vespene(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_vespene() const;
  void _internal_set_vespene(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 food_cap = 4;
  bool has_food_cap() const;
  private:
  bool _internal_has_food_cap() const;
  public:
  void clear_food_cap();
  ::PROTOBUF_NAMESPACE_ID::uint32 food_cap() const;
  void set_food_cap(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_food_cap() const;
  void _internal_set_food_cap(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 food_used = 5;
  bool has_food_used() const;
  private:
  bool _internal_has_food_used() const;
  public:
  void clear_food_used();
  ::PROTOBUF_NAMESPACE_ID::uint32 food_used() const;
  void set_food_used(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_food_used() const;
  void _internal_set_food_used(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 food_army = 6;
  bool has_food_army() const;
  private:
  bool _internal_has_food_army() const;
  public:
  void clear_food_army();
  ::PROTOBUF_NAMESPACE_ID::uint32 food_army() const;
  void set_food_army(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_food_army() const;
  void _internal_set_food_army(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 food_workers = 7;
  bool has_food_workers() const;
  private:
  bool _internal_has_food_workers() const;
  public:
  void clear_food_workers();
  ::PROTOBUF_NAMESPACE_ID::uint32 food_workers() const;
  void set_food_workers(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_food_workers() const;
  void _internal_set_food_workers(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 idle_worker_count = 8;
  bool has_idle_worker_count() const;
  private:
  bool _internal_has_idle_worker_count() const;
  public:
  void clear_idle_worker_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 idle_worker_count() const;
  void set_idle_worker_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idle_worker_count() const;
  void _internal_set_idle_worker_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 army_count = 9;
  bool has_army_count() const;
  private:
  bool _internal_has_army_count() const;
  public:
  void clear_army_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 army_count() const;
  void set_army_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_army_count() const;
  void _internal_set_army_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 warp_gate_count = 10;
  bool has_warp_gate_count() const;
  private:
  bool _internal_has_warp_gate_count() const;
  public:
  void clear_warp_gate_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 warp_gate_count() const;
  void set_warp_gate_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_warp_gate_count() const;
  void _internal_set_warp_gate_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 larva_count = 11;
  bool has_larva_count() const;
  private:
  bool _internal_has_larva_count() const;
  public:
  void clear_larva_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 larva_count() const;
  void set_larva_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_larva_count() const;
  void _internal_set_larva_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerCommon)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minerals_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vespene_;
  ::PROTOBUF_NAMESPACE_ID::uint32 food_cap_;
  ::PROTOBUF_NAMESPACE_ID::uint32 food_used_;
  ::PROTOBUF_NAMESPACE_ID::uint32 food_army_;
  ::PROTOBUF_NAMESPACE_ID::uint32 food_workers_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idle_worker_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 army_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 warp_gate_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 larva_count_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class Observation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Observation) */ {
 public:
  Observation();
  virtual ~Observation();

  Observation(const Observation& from);
  Observation(Observation&& from) noexcept
    : Observation() {
    *this = ::std::move(from);
  }

  inline Observation& operator=(const Observation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Observation& operator=(Observation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Observation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Observation* internal_default_instance() {
    return reinterpret_cast<const Observation*>(
               &_Observation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(Observation& a, Observation& b) {
    a.Swap(&b);
  }
  inline void Swap(Observation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Observation* New() const final {
    return CreateMaybeMessage<Observation>(nullptr);
  }

  Observation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Observation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Observation& from);
  void MergeFrom(const Observation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Observation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Observation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAbilitiesFieldNumber = 3,
    kAlertsFieldNumber = 10,
    kPlayerCommonFieldNumber = 1,
    kScoreFieldNumber = 4,
    kRawDataFieldNumber = 5,
    kFeatureLayerDataFieldNumber = 6,
    kRenderDataFieldNumber = 7,
    kUiDataFieldNumber = 8,
    kGameLoopFieldNumber = 9,
  };
  // repeated .SC2APIProtocol.AvailableAbility abilities = 3;
  int abilities_size() const;
  private:
  int _internal_abilities_size() const;
  public:
  void clear_abilities();
  ::SC2APIProtocol::AvailableAbility* mutable_abilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >*
      mutable_abilities();
  private:
  const ::SC2APIProtocol::AvailableAbility& _internal_abilities(int index) const;
  ::SC2APIProtocol::AvailableAbility* _internal_add_abilities();
  public:
  const ::SC2APIProtocol::AvailableAbility& abilities(int index) const;
  ::SC2APIProtocol::AvailableAbility* add_abilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >&
      abilities() const;

  // repeated .SC2APIProtocol.Alert alerts = 10;
  int alerts_size() const;
  private:
  int _internal_alerts_size() const;
  public:
  void clear_alerts();
  private:
  ::SC2APIProtocol::Alert _internal_alerts(int index) const;
  void _internal_add_alerts(::SC2APIProtocol::Alert value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_alerts();
  public:
  ::SC2APIProtocol::Alert alerts(int index) const;
  void set_alerts(int index, ::SC2APIProtocol::Alert value);
  void add_alerts(::SC2APIProtocol::Alert value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& alerts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_alerts();

  // optional .SC2APIProtocol.PlayerCommon player_common = 1;
  bool has_player_common() const;
  private:
  bool _internal_has_player_common() const;
  public:
  void clear_player_common();
  const ::SC2APIProtocol::PlayerCommon& player_common() const;
  ::SC2APIProtocol::PlayerCommon* release_player_common();
  ::SC2APIProtocol::PlayerCommon* mutable_player_common();
  void set_allocated_player_common(::SC2APIProtocol::PlayerCommon* player_common);
  private:
  const ::SC2APIProtocol::PlayerCommon& _internal_player_common() const;
  ::SC2APIProtocol::PlayerCommon* _internal_mutable_player_common();
  public:

  // optional .SC2APIProtocol.Score score = 4;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  const ::SC2APIProtocol::Score& score() const;
  ::SC2APIProtocol::Score* release_score();
  ::SC2APIProtocol::Score* mutable_score();
  void set_allocated_score(::SC2APIProtocol::Score* score);
  private:
  const ::SC2APIProtocol::Score& _internal_score() const;
  ::SC2APIProtocol::Score* _internal_mutable_score();
  public:

  // optional .SC2APIProtocol.ObservationRaw raw_data = 5;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const ::SC2APIProtocol::ObservationRaw& raw_data() const;
  ::SC2APIProtocol::ObservationRaw* release_raw_data();
  ::SC2APIProtocol::ObservationRaw* mutable_raw_data();
  void set_allocated_raw_data(::SC2APIProtocol::ObservationRaw* raw_data);
  private:
  const ::SC2APIProtocol::ObservationRaw& _internal_raw_data() const;
  ::SC2APIProtocol::ObservationRaw* _internal_mutable_raw_data();
  public:

  // optional .SC2APIProtocol.ObservationFeatureLayer feature_layer_data = 6;
  bool has_feature_layer_data() const;
  private:
  bool _internal_has_feature_layer_data() const;
  public:
  void clear_feature_layer_data();
  const ::SC2APIProtocol::ObservationFeatureLayer& feature_layer_data() const;
  ::SC2APIProtocol::ObservationFeatureLayer* release_feature_layer_data();
  ::SC2APIProtocol::ObservationFeatureLayer* mutable_feature_layer_data();
  void set_allocated_feature_layer_data(::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data);
  private:
  const ::SC2APIProtocol::ObservationFeatureLayer& _internal_feature_layer_data() const;
  ::SC2APIProtocol::ObservationFeatureLayer* _internal_mutable_feature_layer_data();
  public:

  // optional .SC2APIProtocol.ObservationRender render_data = 7;
  bool has_render_data() const;
  private:
  bool _internal_has_render_data() const;
  public:
  void clear_render_data();
  const ::SC2APIProtocol::ObservationRender& render_data() const;
  ::SC2APIProtocol::ObservationRender* release_render_data();
  ::SC2APIProtocol::ObservationRender* mutable_render_data();
  void set_allocated_render_data(::SC2APIProtocol::ObservationRender* render_data);
  private:
  const ::SC2APIProtocol::ObservationRender& _internal_render_data() const;
  ::SC2APIProtocol::ObservationRender* _internal_mutable_render_data();
  public:

  // optional .SC2APIProtocol.ObservationUI ui_data = 8;
  bool has_ui_data() const;
  private:
  bool _internal_has_ui_data() const;
  public:
  void clear_ui_data();
  const ::SC2APIProtocol::ObservationUI& ui_data() const;
  ::SC2APIProtocol::ObservationUI* release_ui_data();
  ::SC2APIProtocol::ObservationUI* mutable_ui_data();
  void set_allocated_ui_data(::SC2APIProtocol::ObservationUI* ui_data);
  private:
  const ::SC2APIProtocol::ObservationUI& _internal_ui_data() const;
  ::SC2APIProtocol::ObservationUI* _internal_mutable_ui_data();
  public:

  // optional uint32 game_loop = 9;
  bool has_game_loop() const;
  private:
  bool _internal_has_game_loop() const;
  public:
  void clear_game_loop();
  ::PROTOBUF_NAMESPACE_ID::uint32 game_loop() const;
  void set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_game_loop() const;
  void _internal_set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Observation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility > abilities_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> alerts_;
  ::SC2APIProtocol::PlayerCommon* player_common_;
  ::SC2APIProtocol::Score* score_;
  ::SC2APIProtocol::ObservationRaw* raw_data_;
  ::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data_;
  ::SC2APIProtocol::ObservationRender* render_data_;
  ::SC2APIProtocol::ObservationUI* ui_data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 game_loop_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class Action :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(nullptr);
  }

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Action";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionRawFieldNumber = 1,
    kActionFeatureLayerFieldNumber = 2,
    kActionRenderFieldNumber = 3,
    kActionUiFieldNumber = 4,
    kActionChatFieldNumber = 6,
    kGameLoopFieldNumber = 7,
  };
  // optional .SC2APIProtocol.ActionRaw action_raw = 1;
  bool has_action_raw() const;
  private:
  bool _internal_has_action_raw() const;
  public:
  void clear_action_raw();
  const ::SC2APIProtocol::ActionRaw& action_raw() const;
  ::SC2APIProtocol::ActionRaw* release_action_raw();
  ::SC2APIProtocol::ActionRaw* mutable_action_raw();
  void set_allocated_action_raw(::SC2APIProtocol::ActionRaw* action_raw);
  private:
  const ::SC2APIProtocol::ActionRaw& _internal_action_raw() const;
  ::SC2APIProtocol::ActionRaw* _internal_mutable_action_raw();
  public:

  // optional .SC2APIProtocol.ActionSpatial action_feature_layer = 2;
  bool has_action_feature_layer() const;
  private:
  bool _internal_has_action_feature_layer() const;
  public:
  void clear_action_feature_layer();
  const ::SC2APIProtocol::ActionSpatial& action_feature_layer() const;
  ::SC2APIProtocol::ActionSpatial* release_action_feature_layer();
  ::SC2APIProtocol::ActionSpatial* mutable_action_feature_layer();
  void set_allocated_action_feature_layer(::SC2APIProtocol::ActionSpatial* action_feature_layer);
  private:
  const ::SC2APIProtocol::ActionSpatial& _internal_action_feature_layer() const;
  ::SC2APIProtocol::ActionSpatial* _internal_mutable_action_feature_layer();
  public:

  // optional .SC2APIProtocol.ActionSpatial action_render = 3;
  bool has_action_render() const;
  private:
  bool _internal_has_action_render() const;
  public:
  void clear_action_render();
  const ::SC2APIProtocol::ActionSpatial& action_render() const;
  ::SC2APIProtocol::ActionSpatial* release_action_render();
  ::SC2APIProtocol::ActionSpatial* mutable_action_render();
  void set_allocated_action_render(::SC2APIProtocol::ActionSpatial* action_render);
  private:
  const ::SC2APIProtocol::ActionSpatial& _internal_action_render() const;
  ::SC2APIProtocol::ActionSpatial* _internal_mutable_action_render();
  public:

  // optional .SC2APIProtocol.ActionUI action_ui = 4;
  bool has_action_ui() const;
  private:
  bool _internal_has_action_ui() const;
  public:
  void clear_action_ui();
  const ::SC2APIProtocol::ActionUI& action_ui() const;
  ::SC2APIProtocol::ActionUI* release_action_ui();
  ::SC2APIProtocol::ActionUI* mutable_action_ui();
  void set_allocated_action_ui(::SC2APIProtocol::ActionUI* action_ui);
  private:
  const ::SC2APIProtocol::ActionUI& _internal_action_ui() const;
  ::SC2APIProtocol::ActionUI* _internal_mutable_action_ui();
  public:

  // optional .SC2APIProtocol.ActionChat action_chat = 6;
  bool has_action_chat() const;
  private:
  bool _internal_has_action_chat() const;
  public:
  void clear_action_chat();
  const ::SC2APIProtocol::ActionChat& action_chat() const;
  ::SC2APIProtocol::ActionChat* release_action_chat();
  ::SC2APIProtocol::ActionChat* mutable_action_chat();
  void set_allocated_action_chat(::SC2APIProtocol::ActionChat* action_chat);
  private:
  const ::SC2APIProtocol::ActionChat& _internal_action_chat() const;
  ::SC2APIProtocol::ActionChat* _internal_mutable_action_chat();
  public:

  // optional uint32 game_loop = 7;
  bool has_game_loop() const;
  private:
  bool _internal_has_game_loop() const;
  public:
  void clear_game_loop();
  ::PROTOBUF_NAMESPACE_ID::uint32 game_loop() const;
  void set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_game_loop() const;
  void _internal_set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Action)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::ActionRaw* action_raw_;
  ::SC2APIProtocol::ActionSpatial* action_feature_layer_;
  ::SC2APIProtocol::ActionSpatial* action_render_;
  ::SC2APIProtocol::ActionUI* action_ui_;
  ::SC2APIProtocol::ActionChat* action_chat_;
  ::PROTOBUF_NAMESPACE_ID::uint32 game_loop_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ActionChat :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionChat) */ {
 public:
  ActionChat();
  virtual ~ActionChat();

  ActionChat(const ActionChat& from);
  ActionChat(ActionChat&& from) noexcept
    : ActionChat() {
    *this = ::std::move(from);
  }

  inline ActionChat& operator=(const ActionChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionChat& operator=(ActionChat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionChat* internal_default_instance() {
    return reinterpret_cast<const ActionChat*>(
               &_ActionChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ActionChat& a, ActionChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionChat* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionChat* New() const final {
    return CreateMaybeMessage<ActionChat>(nullptr);
  }

  ActionChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionChat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionChat& from);
  void MergeFrom(const ActionChat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionChat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionChat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ActionChat_Channel Channel;
  static constexpr Channel Broadcast =
    ActionChat_Channel_Broadcast;
  static constexpr Channel Team =
    ActionChat_Channel_Team;
  static inline bool Channel_IsValid(int value) {
    return ActionChat_Channel_IsValid(value);
  }
  static constexpr Channel Channel_MIN =
    ActionChat_Channel_Channel_MIN;
  static constexpr Channel Channel_MAX =
    ActionChat_Channel_Channel_MAX;
  static constexpr int Channel_ARRAYSIZE =
    ActionChat_Channel_Channel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Channel_descriptor() {
    return ActionChat_Channel_descriptor();
  }
  template<typename T>
  static inline const std::string& Channel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Channel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Channel_Name.");
    return ActionChat_Channel_Name(enum_t_value);
  }
  static inline bool Channel_Parse(const std::string& name,
      Channel* value) {
    return ActionChat_Channel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kChannelFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional .SC2APIProtocol.ActionChat.Channel channel = 1;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  ::SC2APIProtocol::ActionChat_Channel channel() const;
  void set_channel(::SC2APIProtocol::ActionChat_Channel value);
  private:
  ::SC2APIProtocol::ActionChat_Channel _internal_channel() const;
  void _internal_set_channel(::SC2APIProtocol::ActionChat_Channel value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionChat)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int channel_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ActionError :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionError) */ {
 public:
  ActionError();
  virtual ~ActionError();

  ActionError(const ActionError& from);
  ActionError(ActionError&& from) noexcept
    : ActionError() {
    *this = ::std::move(from);
  }

  inline ActionError& operator=(const ActionError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionError& operator=(ActionError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionError* internal_default_instance() {
    return reinterpret_cast<const ActionError*>(
               &_ActionError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ActionError& a, ActionError& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionError* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionError* New() const final {
    return CreateMaybeMessage<ActionError>(nullptr);
  }

  ActionError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionError& from);
  void MergeFrom(const ActionError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionError";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitTagFieldNumber = 1,
    kAbilityIdFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // optional uint64 unit_tag = 1;
  bool has_unit_tag() const;
  private:
  bool _internal_has_unit_tag() const;
  public:
  void clear_unit_tag();
  ::PROTOBUF_NAMESPACE_ID::uint64 unit_tag() const;
  void set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_unit_tag() const;
  void _internal_set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 ability_id = 2;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 ability_id() const;
  void set_ability_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ability_id() const;
  void _internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .SC2APIProtocol.ActionResult result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::SC2APIProtocol::ActionResult result() const;
  void set_result(::SC2APIProtocol::ActionResult value);
  private:
  ::SC2APIProtocol::ActionResult _internal_result() const;
  void _internal_set_result(::SC2APIProtocol::ActionResult value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionError)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 unit_tag_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ability_id_;
  int result_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ObserverAction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObserverAction) */ {
 public:
  ObserverAction();
  virtual ~ObserverAction();

  ObserverAction(const ObserverAction& from);
  ObserverAction(ObserverAction&& from) noexcept
    : ObserverAction() {
    *this = ::std::move(from);
  }

  inline ObserverAction& operator=(const ObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObserverAction& operator=(ObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObserverAction& default_instance();

  enum ActionCase {
    kPlayerPerspective = 1,
    kCameraMove = 2,
    kCameraFollowPlayer = 3,
    kCameraFollowUnits = 4,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObserverAction* internal_default_instance() {
    return reinterpret_cast<const ObserverAction*>(
               &_ObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ObserverAction& a, ObserverAction& b) {
    a.Swap(&b);
  }
  inline void Swap(ObserverAction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObserverAction* New() const final {
    return CreateMaybeMessage<ObserverAction>(nullptr);
  }

  ObserverAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObserverAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObserverAction& from);
  void MergeFrom(const ObserverAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObserverAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ObserverAction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerPerspectiveFieldNumber = 1,
    kCameraMoveFieldNumber = 2,
    kCameraFollowPlayerFieldNumber = 3,
    kCameraFollowUnitsFieldNumber = 4,
  };
  // optional .SC2APIProtocol.ActionObserverPlayerPerspective player_perspective = 1;
  bool has_player_perspective() const;
  private:
  bool _internal_has_player_perspective() const;
  public:
  void clear_player_perspective();
  const ::SC2APIProtocol::ActionObserverPlayerPerspective& player_perspective() const;
  ::SC2APIProtocol::ActionObserverPlayerPerspective* release_player_perspective();
  ::SC2APIProtocol::ActionObserverPlayerPerspective* mutable_player_perspective();
  void set_allocated_player_perspective(::SC2APIProtocol::ActionObserverPlayerPerspective* player_perspective);
  private:
  const ::SC2APIProtocol::ActionObserverPlayerPerspective& _internal_player_perspective() const;
  ::SC2APIProtocol::ActionObserverPlayerPerspective* _internal_mutable_player_perspective();
  public:

  // optional .SC2APIProtocol.ActionObserverCameraMove camera_move = 2;
  bool has_camera_move() const;
  private:
  bool _internal_has_camera_move() const;
  public:
  void clear_camera_move();
  const ::SC2APIProtocol::ActionObserverCameraMove& camera_move() const;
  ::SC2APIProtocol::ActionObserverCameraMove* release_camera_move();
  ::SC2APIProtocol::ActionObserverCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SC2APIProtocol::ActionObserverCameraMove* camera_move);
  private:
  const ::SC2APIProtocol::ActionObserverCameraMove& _internal_camera_move() const;
  ::SC2APIProtocol::ActionObserverCameraMove* _internal_mutable_camera_move();
  public:

  // optional .SC2APIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;
  bool has_camera_follow_player() const;
  private:
  bool _internal_has_camera_follow_player() const;
  public:
  void clear_camera_follow_player();
  const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& camera_follow_player() const;
  ::SC2APIProtocol::ActionObserverCameraFollowPlayer* release_camera_follow_player();
  ::SC2APIProtocol::ActionObserverCameraFollowPlayer* mutable_camera_follow_player();
  void set_allocated_camera_follow_player(::SC2APIProtocol::ActionObserverCameraFollowPlayer* camera_follow_player);
  private:
  const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& _internal_camera_follow_player() const;
  ::SC2APIProtocol::ActionObserverCameraFollowPlayer* _internal_mutable_camera_follow_player();
  public:

  // optional .SC2APIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;
  bool has_camera_follow_units() const;
  private:
  bool _internal_has_camera_follow_units() const;
  public:
  void clear_camera_follow_units();
  const ::SC2APIProtocol::ActionObserverCameraFollowUnits& camera_follow_units() const;
  ::SC2APIProtocol::ActionObserverCameraFollowUnits* release_camera_follow_units();
  ::SC2APIProtocol::ActionObserverCameraFollowUnits* mutable_camera_follow_units();
  void set_allocated_camera_follow_units(::SC2APIProtocol::ActionObserverCameraFollowUnits* camera_follow_units);
  private:
  const ::SC2APIProtocol::ActionObserverCameraFollowUnits& _internal_camera_follow_units() const;
  ::SC2APIProtocol::ActionObserverCameraFollowUnits* _internal_mutable_camera_follow_units();
  public:

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObserverAction)
 private:
  class _Internal;
  void set_has_player_perspective();
  void set_has_camera_move();
  void set_has_camera_follow_player();
  void set_has_camera_follow_units();

  inline bool has_action() const;
  inline void clear_has_action();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SC2APIProtocol::ActionObserverPlayerPerspective* player_perspective_;
    ::SC2APIProtocol::ActionObserverCameraMove* camera_move_;
    ::SC2APIProtocol::ActionObserverCameraFollowPlayer* camera_follow_player_;
    ::SC2APIProtocol::ActionObserverCameraFollowUnits* camera_follow_units_;
  } action_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ActionObserverPlayerPerspective :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverPlayerPerspective) */ {
 public:
  ActionObserverPlayerPerspective();
  virtual ~ActionObserverPlayerPerspective();

  ActionObserverPlayerPerspective(const ActionObserverPlayerPerspective& from);
  ActionObserverPlayerPerspective(ActionObserverPlayerPerspective&& from) noexcept
    : ActionObserverPlayerPerspective() {
    *this = ::std::move(from);
  }

  inline ActionObserverPlayerPerspective& operator=(const ActionObserverPlayerPerspective& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionObserverPlayerPerspective& operator=(ActionObserverPlayerPerspective&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionObserverPlayerPerspective& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverPlayerPerspective* internal_default_instance() {
    return reinterpret_cast<const ActionObserverPlayerPerspective*>(
               &_ActionObserverPlayerPerspective_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ActionObserverPlayerPerspective& a, ActionObserverPlayerPerspective& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionObserverPlayerPerspective* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverPlayerPerspective* New() const final {
    return CreateMaybeMessage<ActionObserverPlayerPerspective>(nullptr);
  }

  ActionObserverPlayerPerspective* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverPlayerPerspective>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionObserverPlayerPerspective& from);
  void MergeFrom(const ActionObserverPlayerPerspective& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverPlayerPerspective* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionObserverPlayerPerspective";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // optional uint32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverPlayerPerspective)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ActionObserverCameraMove :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverCameraMove) */ {
 public:
  ActionObserverCameraMove();
  virtual ~ActionObserverCameraMove();

  ActionObserverCameraMove(const ActionObserverCameraMove& from);
  ActionObserverCameraMove(ActionObserverCameraMove&& from) noexcept
    : ActionObserverCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraMove& operator=(const ActionObserverCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionObserverCameraMove& operator=(ActionObserverCameraMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionObserverCameraMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraMove*>(
               &_ActionObserverCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ActionObserverCameraMove& a, ActionObserverCameraMove& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionObserverCameraMove* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraMove* New() const final {
    return CreateMaybeMessage<ActionObserverCameraMove>(nullptr);
  }

  ActionObserverCameraMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraMove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionObserverCameraMove& from);
  void MergeFrom(const ActionObserverCameraMove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionObserverCameraMove";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldPosFieldNumber = 1,
    kDistanceFieldNumber = 2,
  };
  // optional .SC2APIProtocol.Point2D world_pos = 1;
  bool has_world_pos() const;
  private:
  bool _internal_has_world_pos() const;
  public:
  void clear_world_pos();
  const ::SC2APIProtocol::Point2D& world_pos() const;
  ::SC2APIProtocol::Point2D* release_world_pos();
  ::SC2APIProtocol::Point2D* mutable_world_pos();
  void set_allocated_world_pos(::SC2APIProtocol::Point2D* world_pos);
  private:
  const ::SC2APIProtocol::Point2D& _internal_world_pos() const;
  ::SC2APIProtocol::Point2D* _internal_mutable_world_pos();
  public:

  // optional float distance = 2;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverCameraMove)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Point2D* world_pos_;
  float distance_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ActionObserverCameraFollowPlayer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverCameraFollowPlayer) */ {
 public:
  ActionObserverCameraFollowPlayer();
  virtual ~ActionObserverCameraFollowPlayer();

  ActionObserverCameraFollowPlayer(const ActionObserverCameraFollowPlayer& from);
  ActionObserverCameraFollowPlayer(ActionObserverCameraFollowPlayer&& from) noexcept
    : ActionObserverCameraFollowPlayer() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraFollowPlayer& operator=(const ActionObserverCameraFollowPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionObserverCameraFollowPlayer& operator=(ActionObserverCameraFollowPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionObserverCameraFollowPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraFollowPlayer* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraFollowPlayer*>(
               &_ActionObserverCameraFollowPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ActionObserverCameraFollowPlayer& a, ActionObserverCameraFollowPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionObserverCameraFollowPlayer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraFollowPlayer* New() const final {
    return CreateMaybeMessage<ActionObserverCameraFollowPlayer>(nullptr);
  }

  ActionObserverCameraFollowPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraFollowPlayer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionObserverCameraFollowPlayer& from);
  void MergeFrom(const ActionObserverCameraFollowPlayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraFollowPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionObserverCameraFollowPlayer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // optional uint32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverCameraFollowPlayer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class ActionObserverCameraFollowUnits :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverCameraFollowUnits) */ {
 public:
  ActionObserverCameraFollowUnits();
  virtual ~ActionObserverCameraFollowUnits();

  ActionObserverCameraFollowUnits(const ActionObserverCameraFollowUnits& from);
  ActionObserverCameraFollowUnits(ActionObserverCameraFollowUnits&& from) noexcept
    : ActionObserverCameraFollowUnits() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraFollowUnits& operator=(const ActionObserverCameraFollowUnits& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionObserverCameraFollowUnits& operator=(ActionObserverCameraFollowUnits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionObserverCameraFollowUnits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraFollowUnits* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraFollowUnits*>(
               &_ActionObserverCameraFollowUnits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(ActionObserverCameraFollowUnits& a, ActionObserverCameraFollowUnits& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionObserverCameraFollowUnits* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraFollowUnits* New() const final {
    return CreateMaybeMessage<ActionObserverCameraFollowUnits>(nullptr);
  }

  ActionObserverCameraFollowUnits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraFollowUnits>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionObserverCameraFollowUnits& from);
  void MergeFrom(const ActionObserverCameraFollowUnits& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraFollowUnits* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.ActionObserverCameraFollowUnits";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitTagsFieldNumber = 1,
  };
  // repeated uint64 unit_tags = 1;
  int unit_tags_size() const;
  private:
  int _internal_unit_tags_size() const;
  public:
  void clear_unit_tags();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_unit_tags(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_unit_tags() const;
  void _internal_add_unit_tags(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_unit_tags();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 unit_tags(int index) const;
  void set_unit_tags(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_unit_tags(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      unit_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_unit_tags();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverCameraFollowUnits)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > unit_tags_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// -------------------------------------------------------------------

class PlayerResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerResult) */ {
 public:
  PlayerResult();
  virtual ~PlayerResult();

  PlayerResult(const PlayerResult& from);
  PlayerResult(PlayerResult&& from) noexcept
    : PlayerResult() {
    *this = ::std::move(from);
  }

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerResult& operator=(PlayerResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerResult* internal_default_instance() {
    return reinterpret_cast<const PlayerResult*>(
               &_PlayerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(PlayerResult& a, PlayerResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerResult* New() const final {
    return CreateMaybeMessage<PlayerResult>(nullptr);
  }

  PlayerResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.PlayerResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fsc2api_2eproto);
    return ::descriptor_table_s2clientprotocol_2fsc2api_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // optional uint32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SC2APIProtocol.Result result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::SC2APIProtocol::Result result() const;
  void set_result(::SC2APIProtocol::Result value);
  private:
  ::SC2APIProtocol::Result _internal_result() const;
  void _internal_set_result(::SC2APIProtocol::Result value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 player_id_;
  int result_;
  friend struct ::TableStruct_s2clientprotocol_2fsc2api_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// optional .SC2APIProtocol.RequestCreateGame create_game = 1;
inline bool Request::_internal_has_create_game() const {
  return request_case() == kCreateGame;
}
inline bool Request::has_create_game() const {
  return _internal_has_create_game();
}
inline void Request::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Request::clear_create_game() {
  if (_internal_has_create_game()) {
    delete request_.create_game_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestCreateGame* Request::release_create_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.create_game)
  if (_internal_has_create_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestCreateGame* temp = request_.create_game_;
    request_.create_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestCreateGame& Request::_internal_create_game() const {
  return _internal_has_create_game()
      ? *request_.create_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestCreateGame*>(&::SC2APIProtocol::_RequestCreateGame_default_instance_);
}
inline const ::SC2APIProtocol::RequestCreateGame& Request::create_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.create_game)
  return _internal_create_game();
}
inline ::SC2APIProtocol::RequestCreateGame* Request::_internal_mutable_create_game() {
  if (!_internal_has_create_game()) {
    clear_request();
    set_has_create_game();
    request_.create_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestCreateGame >(
        GetArenaNoVirtual());
  }
  return request_.create_game_;
}
inline ::SC2APIProtocol::RequestCreateGame* Request::mutable_create_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.create_game)
  return _internal_mutable_create_game();
}

// optional .SC2APIProtocol.RequestJoinGame join_game = 2;
inline bool Request::_internal_has_join_game() const {
  return request_case() == kJoinGame;
}
inline bool Request::has_join_game() const {
  return _internal_has_join_game();
}
inline void Request::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Request::clear_join_game() {
  if (_internal_has_join_game()) {
    delete request_.join_game_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestJoinGame* Request::release_join_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.join_game)
  if (_internal_has_join_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestJoinGame* temp = request_.join_game_;
    request_.join_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestJoinGame& Request::_internal_join_game() const {
  return _internal_has_join_game()
      ? *request_.join_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestJoinGame*>(&::SC2APIProtocol::_RequestJoinGame_default_instance_);
}
inline const ::SC2APIProtocol::RequestJoinGame& Request::join_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.join_game)
  return _internal_join_game();
}
inline ::SC2APIProtocol::RequestJoinGame* Request::_internal_mutable_join_game() {
  if (!_internal_has_join_game()) {
    clear_request();
    set_has_join_game();
    request_.join_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestJoinGame >(
        GetArenaNoVirtual());
  }
  return request_.join_game_;
}
inline ::SC2APIProtocol::RequestJoinGame* Request::mutable_join_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.join_game)
  return _internal_mutable_join_game();
}

// optional .SC2APIProtocol.RequestRestartGame restart_game = 3;
inline bool Request::_internal_has_restart_game() const {
  return request_case() == kRestartGame;
}
inline bool Request::has_restart_game() const {
  return _internal_has_restart_game();
}
inline void Request::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Request::clear_restart_game() {
  if (_internal_has_restart_game()) {
    delete request_.restart_game_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestRestartGame* Request::release_restart_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.restart_game)
  if (_internal_has_restart_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestRestartGame* temp = request_.restart_game_;
    request_.restart_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestRestartGame& Request::_internal_restart_game() const {
  return _internal_has_restart_game()
      ? *request_.restart_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestRestartGame*>(&::SC2APIProtocol::_RequestRestartGame_default_instance_);
}
inline const ::SC2APIProtocol::RequestRestartGame& Request::restart_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.restart_game)
  return _internal_restart_game();
}
inline ::SC2APIProtocol::RequestRestartGame* Request::_internal_mutable_restart_game() {
  if (!_internal_has_restart_game()) {
    clear_request();
    set_has_restart_game();
    request_.restart_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestRestartGame >(
        GetArenaNoVirtual());
  }
  return request_.restart_game_;
}
inline ::SC2APIProtocol::RequestRestartGame* Request::mutable_restart_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.restart_game)
  return _internal_mutable_restart_game();
}

// optional .SC2APIProtocol.RequestStartReplay start_replay = 4;
inline bool Request::_internal_has_start_replay() const {
  return request_case() == kStartReplay;
}
inline bool Request::has_start_replay() const {
  return _internal_has_start_replay();
}
inline void Request::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Request::clear_start_replay() {
  if (_internal_has_start_replay()) {
    delete request_.start_replay_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestStartReplay* Request::release_start_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.start_replay)
  if (_internal_has_start_replay()) {
    clear_has_request();
      ::SC2APIProtocol::RequestStartReplay* temp = request_.start_replay_;
    request_.start_replay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestStartReplay& Request::_internal_start_replay() const {
  return _internal_has_start_replay()
      ? *request_.start_replay_
      : *reinterpret_cast< ::SC2APIProtocol::RequestStartReplay*>(&::SC2APIProtocol::_RequestStartReplay_default_instance_);
}
inline const ::SC2APIProtocol::RequestStartReplay& Request::start_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.start_replay)
  return _internal_start_replay();
}
inline ::SC2APIProtocol::RequestStartReplay* Request::_internal_mutable_start_replay() {
  if (!_internal_has_start_replay()) {
    clear_request();
    set_has_start_replay();
    request_.start_replay_ = CreateMaybeMessage< ::SC2APIProtocol::RequestStartReplay >(
        GetArenaNoVirtual());
  }
  return request_.start_replay_;
}
inline ::SC2APIProtocol::RequestStartReplay* Request::mutable_start_replay() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.start_replay)
  return _internal_mutable_start_replay();
}

// optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;
inline bool Request::_internal_has_leave_game() const {
  return request_case() == kLeaveGame;
}
inline bool Request::has_leave_game() const {
  return _internal_has_leave_game();
}
inline void Request::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Request::clear_leave_game() {
  if (_internal_has_leave_game()) {
    delete request_.leave_game_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestLeaveGame* Request::release_leave_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.leave_game)
  if (_internal_has_leave_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestLeaveGame* temp = request_.leave_game_;
    request_.leave_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestLeaveGame& Request::_internal_leave_game() const {
  return _internal_has_leave_game()
      ? *request_.leave_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestLeaveGame*>(&::SC2APIProtocol::_RequestLeaveGame_default_instance_);
}
inline const ::SC2APIProtocol::RequestLeaveGame& Request::leave_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.leave_game)
  return _internal_leave_game();
}
inline ::SC2APIProtocol::RequestLeaveGame* Request::_internal_mutable_leave_game() {
  if (!_internal_has_leave_game()) {
    clear_request();
    set_has_leave_game();
    request_.leave_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestLeaveGame >(
        GetArenaNoVirtual());
  }
  return request_.leave_game_;
}
inline ::SC2APIProtocol::RequestLeaveGame* Request::mutable_leave_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.leave_game)
  return _internal_mutable_leave_game();
}

// optional .SC2APIProtocol.RequestQuickSave quick_save = 6;
inline bool Request::_internal_has_quick_save() const {
  return request_case() == kQuickSave;
}
inline bool Request::has_quick_save() const {
  return _internal_has_quick_save();
}
inline void Request::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Request::clear_quick_save() {
  if (_internal_has_quick_save()) {
    delete request_.quick_save_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestQuickSave* Request::release_quick_save() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quick_save)
  if (_internal_has_quick_save()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuickSave* temp = request_.quick_save_;
    request_.quick_save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestQuickSave& Request::_internal_quick_save() const {
  return _internal_has_quick_save()
      ? *request_.quick_save_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuickSave*>(&::SC2APIProtocol::_RequestQuickSave_default_instance_);
}
inline const ::SC2APIProtocol::RequestQuickSave& Request::quick_save() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quick_save)
  return _internal_quick_save();
}
inline ::SC2APIProtocol::RequestQuickSave* Request::_internal_mutable_quick_save() {
  if (!_internal_has_quick_save()) {
    clear_request();
    set_has_quick_save();
    request_.quick_save_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuickSave >(
        GetArenaNoVirtual());
  }
  return request_.quick_save_;
}
inline ::SC2APIProtocol::RequestQuickSave* Request::mutable_quick_save() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quick_save)
  return _internal_mutable_quick_save();
}

// optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;
inline bool Request::_internal_has_quick_load() const {
  return request_case() == kQuickLoad;
}
inline bool Request::has_quick_load() const {
  return _internal_has_quick_load();
}
inline void Request::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Request::clear_quick_load() {
  if (_internal_has_quick_load()) {
    delete request_.quick_load_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestQuickLoad* Request::release_quick_load() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quick_load)
  if (_internal_has_quick_load()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuickLoad* temp = request_.quick_load_;
    request_.quick_load_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestQuickLoad& Request::_internal_quick_load() const {
  return _internal_has_quick_load()
      ? *request_.quick_load_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuickLoad*>(&::SC2APIProtocol::_RequestQuickLoad_default_instance_);
}
inline const ::SC2APIProtocol::RequestQuickLoad& Request::quick_load() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quick_load)
  return _internal_quick_load();
}
inline ::SC2APIProtocol::RequestQuickLoad* Request::_internal_mutable_quick_load() {
  if (!_internal_has_quick_load()) {
    clear_request();
    set_has_quick_load();
    request_.quick_load_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuickLoad >(
        GetArenaNoVirtual());
  }
  return request_.quick_load_;
}
inline ::SC2APIProtocol::RequestQuickLoad* Request::mutable_quick_load() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quick_load)
  return _internal_mutable_quick_load();
}

// optional .SC2APIProtocol.RequestQuit quit = 8;
inline bool Request::_internal_has_quit() const {
  return request_case() == kQuit;
}
inline bool Request::has_quit() const {
  return _internal_has_quit();
}
inline void Request::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Request::clear_quit() {
  if (_internal_has_quit()) {
    delete request_.quit_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestQuit* Request::release_quit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quit)
  if (_internal_has_quit()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuit* temp = request_.quit_;
    request_.quit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestQuit& Request::_internal_quit() const {
  return _internal_has_quit()
      ? *request_.quit_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuit*>(&::SC2APIProtocol::_RequestQuit_default_instance_);
}
inline const ::SC2APIProtocol::RequestQuit& Request::quit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quit)
  return _internal_quit();
}
inline ::SC2APIProtocol::RequestQuit* Request::_internal_mutable_quit() {
  if (!_internal_has_quit()) {
    clear_request();
    set_has_quit();
    request_.quit_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuit >(
        GetArenaNoVirtual());
  }
  return request_.quit_;
}
inline ::SC2APIProtocol::RequestQuit* Request::mutable_quit() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quit)
  return _internal_mutable_quit();
}

// optional .SC2APIProtocol.RequestGameInfo game_info = 9;
inline bool Request::_internal_has_game_info() const {
  return request_case() == kGameInfo;
}
inline bool Request::has_game_info() const {
  return _internal_has_game_info();
}
inline void Request::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Request::clear_game_info() {
  if (_internal_has_game_info()) {
    delete request_.game_info_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestGameInfo* Request::release_game_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.game_info)
  if (_internal_has_game_info()) {
    clear_has_request();
      ::SC2APIProtocol::RequestGameInfo* temp = request_.game_info_;
    request_.game_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestGameInfo& Request::_internal_game_info() const {
  return _internal_has_game_info()
      ? *request_.game_info_
      : *reinterpret_cast< ::SC2APIProtocol::RequestGameInfo*>(&::SC2APIProtocol::_RequestGameInfo_default_instance_);
}
inline const ::SC2APIProtocol::RequestGameInfo& Request::game_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.game_info)
  return _internal_game_info();
}
inline ::SC2APIProtocol::RequestGameInfo* Request::_internal_mutable_game_info() {
  if (!_internal_has_game_info()) {
    clear_request();
    set_has_game_info();
    request_.game_info_ = CreateMaybeMessage< ::SC2APIProtocol::RequestGameInfo >(
        GetArenaNoVirtual());
  }
  return request_.game_info_;
}
inline ::SC2APIProtocol::RequestGameInfo* Request::mutable_game_info() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.game_info)
  return _internal_mutable_game_info();
}

// optional .SC2APIProtocol.RequestObservation observation = 10;
inline bool Request::_internal_has_observation() const {
  return request_case() == kObservation;
}
inline bool Request::has_observation() const {
  return _internal_has_observation();
}
inline void Request::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Request::clear_observation() {
  if (_internal_has_observation()) {
    delete request_.observation_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestObservation* Request::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.observation)
  if (_internal_has_observation()) {
    clear_has_request();
      ::SC2APIProtocol::RequestObservation* temp = request_.observation_;
    request_.observation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestObservation& Request::_internal_observation() const {
  return _internal_has_observation()
      ? *request_.observation_
      : *reinterpret_cast< ::SC2APIProtocol::RequestObservation*>(&::SC2APIProtocol::_RequestObservation_default_instance_);
}
inline const ::SC2APIProtocol::RequestObservation& Request::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.observation)
  return _internal_observation();
}
inline ::SC2APIProtocol::RequestObservation* Request::_internal_mutable_observation() {
  if (!_internal_has_observation()) {
    clear_request();
    set_has_observation();
    request_.observation_ = CreateMaybeMessage< ::SC2APIProtocol::RequestObservation >(
        GetArenaNoVirtual());
  }
  return request_.observation_;
}
inline ::SC2APIProtocol::RequestObservation* Request::mutable_observation() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.observation)
  return _internal_mutable_observation();
}

// optional .SC2APIProtocol.RequestAction action = 11;
inline bool Request::_internal_has_action() const {
  return request_case() == kAction;
}
inline bool Request::has_action() const {
  return _internal_has_action();
}
inline void Request::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Request::clear_action() {
  if (_internal_has_action()) {
    delete request_.action_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestAction* Request::release_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.action)
  if (_internal_has_action()) {
    clear_has_request();
      ::SC2APIProtocol::RequestAction* temp = request_.action_;
    request_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestAction& Request::_internal_action() const {
  return _internal_has_action()
      ? *request_.action_
      : *reinterpret_cast< ::SC2APIProtocol::RequestAction*>(&::SC2APIProtocol::_RequestAction_default_instance_);
}
inline const ::SC2APIProtocol::RequestAction& Request::action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.action)
  return _internal_action();
}
inline ::SC2APIProtocol::RequestAction* Request::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_request();
    set_has_action();
    request_.action_ = CreateMaybeMessage< ::SC2APIProtocol::RequestAction >(
        GetArenaNoVirtual());
  }
  return request_.action_;
}
inline ::SC2APIProtocol::RequestAction* Request::mutable_action() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.action)
  return _internal_mutable_action();
}

// optional .SC2APIProtocol.RequestObserverAction obs_action = 21;
inline bool Request::_internal_has_obs_action() const {
  return request_case() == kObsAction;
}
inline bool Request::has_obs_action() const {
  return _internal_has_obs_action();
}
inline void Request::set_has_obs_action() {
  _oneof_case_[0] = kObsAction;
}
inline void Request::clear_obs_action() {
  if (_internal_has_obs_action()) {
    delete request_.obs_action_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestObserverAction* Request::release_obs_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.obs_action)
  if (_internal_has_obs_action()) {
    clear_has_request();
      ::SC2APIProtocol::RequestObserverAction* temp = request_.obs_action_;
    request_.obs_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestObserverAction& Request::_internal_obs_action() const {
  return _internal_has_obs_action()
      ? *request_.obs_action_
      : *reinterpret_cast< ::SC2APIProtocol::RequestObserverAction*>(&::SC2APIProtocol::_RequestObserverAction_default_instance_);
}
inline const ::SC2APIProtocol::RequestObserverAction& Request::obs_action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.obs_action)
  return _internal_obs_action();
}
inline ::SC2APIProtocol::RequestObserverAction* Request::_internal_mutable_obs_action() {
  if (!_internal_has_obs_action()) {
    clear_request();
    set_has_obs_action();
    request_.obs_action_ = CreateMaybeMessage< ::SC2APIProtocol::RequestObserverAction >(
        GetArenaNoVirtual());
  }
  return request_.obs_action_;
}
inline ::SC2APIProtocol::RequestObserverAction* Request::mutable_obs_action() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.obs_action)
  return _internal_mutable_obs_action();
}

// optional .SC2APIProtocol.RequestStep step = 12;
inline bool Request::_internal_has_step() const {
  return request_case() == kStep;
}
inline bool Request::has_step() const {
  return _internal_has_step();
}
inline void Request::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Request::clear_step() {
  if (_internal_has_step()) {
    delete request_.step_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestStep* Request::release_step() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.step)
  if (_internal_has_step()) {
    clear_has_request();
      ::SC2APIProtocol::RequestStep* temp = request_.step_;
    request_.step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestStep& Request::_internal_step() const {
  return _internal_has_step()
      ? *request_.step_
      : *reinterpret_cast< ::SC2APIProtocol::RequestStep*>(&::SC2APIProtocol::_RequestStep_default_instance_);
}
inline const ::SC2APIProtocol::RequestStep& Request::step() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.step)
  return _internal_step();
}
inline ::SC2APIProtocol::RequestStep* Request::_internal_mutable_step() {
  if (!_internal_has_step()) {
    clear_request();
    set_has_step();
    request_.step_ = CreateMaybeMessage< ::SC2APIProtocol::RequestStep >(
        GetArenaNoVirtual());
  }
  return request_.step_;
}
inline ::SC2APIProtocol::RequestStep* Request::mutable_step() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.step)
  return _internal_mutable_step();
}

// optional .SC2APIProtocol.RequestData data = 13;
inline bool Request::_internal_has_data() const {
  return request_case() == kData;
}
inline bool Request::has_data() const {
  return _internal_has_data();
}
inline void Request::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Request::clear_data() {
  if (_internal_has_data()) {
    delete request_.data_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestData* Request::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.data)
  if (_internal_has_data()) {
    clear_has_request();
      ::SC2APIProtocol::RequestData* temp = request_.data_;
    request_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestData& Request::_internal_data() const {
  return _internal_has_data()
      ? *request_.data_
      : *reinterpret_cast< ::SC2APIProtocol::RequestData*>(&::SC2APIProtocol::_RequestData_default_instance_);
}
inline const ::SC2APIProtocol::RequestData& Request::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.data)
  return _internal_data();
}
inline ::SC2APIProtocol::RequestData* Request::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_request();
    set_has_data();
    request_.data_ = CreateMaybeMessage< ::SC2APIProtocol::RequestData >(
        GetArenaNoVirtual());
  }
  return request_.data_;
}
inline ::SC2APIProtocol::RequestData* Request::mutable_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.data)
  return _internal_mutable_data();
}

// optional .SC2APIProtocol.RequestQuery query = 14;
inline bool Request::_internal_has_query() const {
  return request_case() == kQuery;
}
inline bool Request::has_query() const {
  return _internal_has_query();
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline ::SC2APIProtocol::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.query)
  if (_internal_has_query()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuery* temp = request_.query_;
    request_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestQuery& Request::_internal_query() const {
  return _internal_has_query()
      ? *request_.query_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuery*>(&::SC2APIProtocol::_RequestQuery_default_instance_);
}
inline const ::SC2APIProtocol::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.query)
  return _internal_query();
}
inline ::SC2APIProtocol::RequestQuery* Request::_internal_mutable_query() {
  if (!_internal_has_query()) {
    clear_request();
    set_has_query();
    request_.query_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuery >(
        GetArenaNoVirtual());
  }
  return request_.query_;
}
inline ::SC2APIProtocol::RequestQuery* Request::mutable_query() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.query)
  return _internal_mutable_query();
}

// optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;
inline bool Request::_internal_has_save_replay() const {
  return request_case() == kSaveReplay;
}
inline bool Request::has_save_replay() const {
  return _internal_has_save_replay();
}
inline void Request::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Request::clear_save_replay() {
  if (_internal_has_save_replay()) {
    delete request_.save_replay_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestSaveReplay* Request::release_save_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.save_replay)
  if (_internal_has_save_replay()) {
    clear_has_request();
      ::SC2APIProtocol::RequestSaveReplay* temp = request_.save_replay_;
    request_.save_replay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestSaveReplay& Request::_internal_save_replay() const {
  return _internal_has_save_replay()
      ? *request_.save_replay_
      : *reinterpret_cast< ::SC2APIProtocol::RequestSaveReplay*>(&::SC2APIProtocol::_RequestSaveReplay_default_instance_);
}
inline const ::SC2APIProtocol::RequestSaveReplay& Request::save_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.save_replay)
  return _internal_save_replay();
}
inline ::SC2APIProtocol::RequestSaveReplay* Request::_internal_mutable_save_replay() {
  if (!_internal_has_save_replay()) {
    clear_request();
    set_has_save_replay();
    request_.save_replay_ = CreateMaybeMessage< ::SC2APIProtocol::RequestSaveReplay >(
        GetArenaNoVirtual());
  }
  return request_.save_replay_;
}
inline ::SC2APIProtocol::RequestSaveReplay* Request::mutable_save_replay() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.save_replay)
  return _internal_mutable_save_replay();
}

// optional .SC2APIProtocol.RequestMapCommand map_command = 22;
inline bool Request::_internal_has_map_command() const {
  return request_case() == kMapCommand;
}
inline bool Request::has_map_command() const {
  return _internal_has_map_command();
}
inline void Request::set_has_map_command() {
  _oneof_case_[0] = kMapCommand;
}
inline void Request::clear_map_command() {
  if (_internal_has_map_command()) {
    delete request_.map_command_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestMapCommand* Request::release_map_command() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.map_command)
  if (_internal_has_map_command()) {
    clear_has_request();
      ::SC2APIProtocol::RequestMapCommand* temp = request_.map_command_;
    request_.map_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestMapCommand& Request::_internal_map_command() const {
  return _internal_has_map_command()
      ? *request_.map_command_
      : *reinterpret_cast< ::SC2APIProtocol::RequestMapCommand*>(&::SC2APIProtocol::_RequestMapCommand_default_instance_);
}
inline const ::SC2APIProtocol::RequestMapCommand& Request::map_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.map_command)
  return _internal_map_command();
}
inline ::SC2APIProtocol::RequestMapCommand* Request::_internal_mutable_map_command() {
  if (!_internal_has_map_command()) {
    clear_request();
    set_has_map_command();
    request_.map_command_ = CreateMaybeMessage< ::SC2APIProtocol::RequestMapCommand >(
        GetArenaNoVirtual());
  }
  return request_.map_command_;
}
inline ::SC2APIProtocol::RequestMapCommand* Request::mutable_map_command() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.map_command)
  return _internal_mutable_map_command();
}

// optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;
inline bool Request::_internal_has_replay_info() const {
  return request_case() == kReplayInfo;
}
inline bool Request::has_replay_info() const {
  return _internal_has_replay_info();
}
inline void Request::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Request::clear_replay_info() {
  if (_internal_has_replay_info()) {
    delete request_.replay_info_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestReplayInfo* Request::release_replay_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.replay_info)
  if (_internal_has_replay_info()) {
    clear_has_request();
      ::SC2APIProtocol::RequestReplayInfo* temp = request_.replay_info_;
    request_.replay_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestReplayInfo& Request::_internal_replay_info() const {
  return _internal_has_replay_info()
      ? *request_.replay_info_
      : *reinterpret_cast< ::SC2APIProtocol::RequestReplayInfo*>(&::SC2APIProtocol::_RequestReplayInfo_default_instance_);
}
inline const ::SC2APIProtocol::RequestReplayInfo& Request::replay_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.replay_info)
  return _internal_replay_info();
}
inline ::SC2APIProtocol::RequestReplayInfo* Request::_internal_mutable_replay_info() {
  if (!_internal_has_replay_info()) {
    clear_request();
    set_has_replay_info();
    request_.replay_info_ = CreateMaybeMessage< ::SC2APIProtocol::RequestReplayInfo >(
        GetArenaNoVirtual());
  }
  return request_.replay_info_;
}
inline ::SC2APIProtocol::RequestReplayInfo* Request::mutable_replay_info() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.replay_info)
  return _internal_mutable_replay_info();
}

// optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;
inline bool Request::_internal_has_available_maps() const {
  return request_case() == kAvailableMaps;
}
inline bool Request::has_available_maps() const {
  return _internal_has_available_maps();
}
inline void Request::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Request::clear_available_maps() {
  if (_internal_has_available_maps()) {
    delete request_.available_maps_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestAvailableMaps* Request::release_available_maps() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.available_maps)
  if (_internal_has_available_maps()) {
    clear_has_request();
      ::SC2APIProtocol::RequestAvailableMaps* temp = request_.available_maps_;
    request_.available_maps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestAvailableMaps& Request::_internal_available_maps() const {
  return _internal_has_available_maps()
      ? *request_.available_maps_
      : *reinterpret_cast< ::SC2APIProtocol::RequestAvailableMaps*>(&::SC2APIProtocol::_RequestAvailableMaps_default_instance_);
}
inline const ::SC2APIProtocol::RequestAvailableMaps& Request::available_maps() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.available_maps)
  return _internal_available_maps();
}
inline ::SC2APIProtocol::RequestAvailableMaps* Request::_internal_mutable_available_maps() {
  if (!_internal_has_available_maps()) {
    clear_request();
    set_has_available_maps();
    request_.available_maps_ = CreateMaybeMessage< ::SC2APIProtocol::RequestAvailableMaps >(
        GetArenaNoVirtual());
  }
  return request_.available_maps_;
}
inline ::SC2APIProtocol::RequestAvailableMaps* Request::mutable_available_maps() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.available_maps)
  return _internal_mutable_available_maps();
}

// optional .SC2APIProtocol.RequestSaveMap save_map = 18;
inline bool Request::_internal_has_save_map() const {
  return request_case() == kSaveMap;
}
inline bool Request::has_save_map() const {
  return _internal_has_save_map();
}
inline void Request::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Request::clear_save_map() {
  if (_internal_has_save_map()) {
    delete request_.save_map_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestSaveMap* Request::release_save_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.save_map)
  if (_internal_has_save_map()) {
    clear_has_request();
      ::SC2APIProtocol::RequestSaveMap* temp = request_.save_map_;
    request_.save_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestSaveMap& Request::_internal_save_map() const {
  return _internal_has_save_map()
      ? *request_.save_map_
      : *reinterpret_cast< ::SC2APIProtocol::RequestSaveMap*>(&::SC2APIProtocol::_RequestSaveMap_default_instance_);
}
inline const ::SC2APIProtocol::RequestSaveMap& Request::save_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.save_map)
  return _internal_save_map();
}
inline ::SC2APIProtocol::RequestSaveMap* Request::_internal_mutable_save_map() {
  if (!_internal_has_save_map()) {
    clear_request();
    set_has_save_map();
    request_.save_map_ = CreateMaybeMessage< ::SC2APIProtocol::RequestSaveMap >(
        GetArenaNoVirtual());
  }
  return request_.save_map_;
}
inline ::SC2APIProtocol::RequestSaveMap* Request::mutable_save_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.save_map)
  return _internal_mutable_save_map();
}

// optional .SC2APIProtocol.RequestPing ping = 19;
inline bool Request::_internal_has_ping() const {
  return request_case() == kPing;
}
inline bool Request::has_ping() const {
  return _internal_has_ping();
}
inline void Request::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Request::clear_ping() {
  if (_internal_has_ping()) {
    delete request_.ping_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestPing* Request::release_ping() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.ping)
  if (_internal_has_ping()) {
    clear_has_request();
      ::SC2APIProtocol::RequestPing* temp = request_.ping_;
    request_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestPing& Request::_internal_ping() const {
  return _internal_has_ping()
      ? *request_.ping_
      : *reinterpret_cast< ::SC2APIProtocol::RequestPing*>(&::SC2APIProtocol::_RequestPing_default_instance_);
}
inline const ::SC2APIProtocol::RequestPing& Request::ping() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.ping)
  return _internal_ping();
}
inline ::SC2APIProtocol::RequestPing* Request::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_request();
    set_has_ping();
    request_.ping_ = CreateMaybeMessage< ::SC2APIProtocol::RequestPing >(
        GetArenaNoVirtual());
  }
  return request_.ping_;
}
inline ::SC2APIProtocol::RequestPing* Request::mutable_ping() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.ping)
  return _internal_mutable_ping();
}

// optional .SC2APIProtocol.RequestDebug debug = 20;
inline bool Request::_internal_has_debug() const {
  return request_case() == kDebug;
}
inline bool Request::has_debug() const {
  return _internal_has_debug();
}
inline void Request::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Request::clear_debug() {
  if (_internal_has_debug()) {
    delete request_.debug_;
    clear_has_request();
  }
}
inline ::SC2APIProtocol::RequestDebug* Request::release_debug() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.debug)
  if (_internal_has_debug()) {
    clear_has_request();
      ::SC2APIProtocol::RequestDebug* temp = request_.debug_;
    request_.debug_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::RequestDebug& Request::_internal_debug() const {
  return _internal_has_debug()
      ? *request_.debug_
      : *reinterpret_cast< ::SC2APIProtocol::RequestDebug*>(&::SC2APIProtocol::_RequestDebug_default_instance_);
}
inline const ::SC2APIProtocol::RequestDebug& Request::debug() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.debug)
  return _internal_debug();
}
inline ::SC2APIProtocol::RequestDebug* Request::_internal_mutable_debug() {
  if (!_internal_has_debug()) {
    clear_request();
    set_has_debug();
    request_.debug_ = CreateMaybeMessage< ::SC2APIProtocol::RequestDebug >(
        GetArenaNoVirtual());
  }
  return request_.debug_;
}
inline ::SC2APIProtocol::RequestDebug* Request::mutable_debug() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.debug)
  return _internal_mutable_debug();
}

// optional uint32 id = 97;
inline bool Request::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Request::has_id() const {
  return _internal_has_id();
}
inline void Request::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Request::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Request::id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.id)
  return _internal_id();
}
inline void Request::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void Request::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Request.id)
}

inline bool Request::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void Request::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline Request::RequestCase Request::request_case() const {
  return Request::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// optional .SC2APIProtocol.ResponseCreateGame create_game = 1;
inline bool Response::_internal_has_create_game() const {
  return response_case() == kCreateGame;
}
inline bool Response::has_create_game() const {
  return _internal_has_create_game();
}
inline void Response::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Response::clear_create_game() {
  if (_internal_has_create_game()) {
    delete response_.create_game_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseCreateGame* Response::release_create_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.create_game)
  if (_internal_has_create_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseCreateGame* temp = response_.create_game_;
    response_.create_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseCreateGame& Response::_internal_create_game() const {
  return _internal_has_create_game()
      ? *response_.create_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseCreateGame*>(&::SC2APIProtocol::_ResponseCreateGame_default_instance_);
}
inline const ::SC2APIProtocol::ResponseCreateGame& Response::create_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.create_game)
  return _internal_create_game();
}
inline ::SC2APIProtocol::ResponseCreateGame* Response::_internal_mutable_create_game() {
  if (!_internal_has_create_game()) {
    clear_response();
    set_has_create_game();
    response_.create_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseCreateGame >(
        GetArenaNoVirtual());
  }
  return response_.create_game_;
}
inline ::SC2APIProtocol::ResponseCreateGame* Response::mutable_create_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.create_game)
  return _internal_mutable_create_game();
}

// optional .SC2APIProtocol.ResponseJoinGame join_game = 2;
inline bool Response::_internal_has_join_game() const {
  return response_case() == kJoinGame;
}
inline bool Response::has_join_game() const {
  return _internal_has_join_game();
}
inline void Response::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Response::clear_join_game() {
  if (_internal_has_join_game()) {
    delete response_.join_game_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseJoinGame* Response::release_join_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.join_game)
  if (_internal_has_join_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseJoinGame* temp = response_.join_game_;
    response_.join_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseJoinGame& Response::_internal_join_game() const {
  return _internal_has_join_game()
      ? *response_.join_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseJoinGame*>(&::SC2APIProtocol::_ResponseJoinGame_default_instance_);
}
inline const ::SC2APIProtocol::ResponseJoinGame& Response::join_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.join_game)
  return _internal_join_game();
}
inline ::SC2APIProtocol::ResponseJoinGame* Response::_internal_mutable_join_game() {
  if (!_internal_has_join_game()) {
    clear_response();
    set_has_join_game();
    response_.join_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseJoinGame >(
        GetArenaNoVirtual());
  }
  return response_.join_game_;
}
inline ::SC2APIProtocol::ResponseJoinGame* Response::mutable_join_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.join_game)
  return _internal_mutable_join_game();
}

// optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;
inline bool Response::_internal_has_restart_game() const {
  return response_case() == kRestartGame;
}
inline bool Response::has_restart_game() const {
  return _internal_has_restart_game();
}
inline void Response::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Response::clear_restart_game() {
  if (_internal_has_restart_game()) {
    delete response_.restart_game_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseRestartGame* Response::release_restart_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.restart_game)
  if (_internal_has_restart_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseRestartGame* temp = response_.restart_game_;
    response_.restart_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseRestartGame& Response::_internal_restart_game() const {
  return _internal_has_restart_game()
      ? *response_.restart_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseRestartGame*>(&::SC2APIProtocol::_ResponseRestartGame_default_instance_);
}
inline const ::SC2APIProtocol::ResponseRestartGame& Response::restart_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.restart_game)
  return _internal_restart_game();
}
inline ::SC2APIProtocol::ResponseRestartGame* Response::_internal_mutable_restart_game() {
  if (!_internal_has_restart_game()) {
    clear_response();
    set_has_restart_game();
    response_.restart_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseRestartGame >(
        GetArenaNoVirtual());
  }
  return response_.restart_game_;
}
inline ::SC2APIProtocol::ResponseRestartGame* Response::mutable_restart_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.restart_game)
  return _internal_mutable_restart_game();
}

// optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;
inline bool Response::_internal_has_start_replay() const {
  return response_case() == kStartReplay;
}
inline bool Response::has_start_replay() const {
  return _internal_has_start_replay();
}
inline void Response::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Response::clear_start_replay() {
  if (_internal_has_start_replay()) {
    delete response_.start_replay_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseStartReplay* Response::release_start_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.start_replay)
  if (_internal_has_start_replay()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseStartReplay* temp = response_.start_replay_;
    response_.start_replay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseStartReplay& Response::_internal_start_replay() const {
  return _internal_has_start_replay()
      ? *response_.start_replay_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseStartReplay*>(&::SC2APIProtocol::_ResponseStartReplay_default_instance_);
}
inline const ::SC2APIProtocol::ResponseStartReplay& Response::start_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.start_replay)
  return _internal_start_replay();
}
inline ::SC2APIProtocol::ResponseStartReplay* Response::_internal_mutable_start_replay() {
  if (!_internal_has_start_replay()) {
    clear_response();
    set_has_start_replay();
    response_.start_replay_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseStartReplay >(
        GetArenaNoVirtual());
  }
  return response_.start_replay_;
}
inline ::SC2APIProtocol::ResponseStartReplay* Response::mutable_start_replay() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.start_replay)
  return _internal_mutable_start_replay();
}

// optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;
inline bool Response::_internal_has_leave_game() const {
  return response_case() == kLeaveGame;
}
inline bool Response::has_leave_game() const {
  return _internal_has_leave_game();
}
inline void Response::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Response::clear_leave_game() {
  if (_internal_has_leave_game()) {
    delete response_.leave_game_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseLeaveGame* Response::release_leave_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.leave_game)
  if (_internal_has_leave_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseLeaveGame* temp = response_.leave_game_;
    response_.leave_game_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseLeaveGame& Response::_internal_leave_game() const {
  return _internal_has_leave_game()
      ? *response_.leave_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseLeaveGame*>(&::SC2APIProtocol::_ResponseLeaveGame_default_instance_);
}
inline const ::SC2APIProtocol::ResponseLeaveGame& Response::leave_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.leave_game)
  return _internal_leave_game();
}
inline ::SC2APIProtocol::ResponseLeaveGame* Response::_internal_mutable_leave_game() {
  if (!_internal_has_leave_game()) {
    clear_response();
    set_has_leave_game();
    response_.leave_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseLeaveGame >(
        GetArenaNoVirtual());
  }
  return response_.leave_game_;
}
inline ::SC2APIProtocol::ResponseLeaveGame* Response::mutable_leave_game() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.leave_game)
  return _internal_mutable_leave_game();
}

// optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;
inline bool Response::_internal_has_quick_save() const {
  return response_case() == kQuickSave;
}
inline bool Response::has_quick_save() const {
  return _internal_has_quick_save();
}
inline void Response::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Response::clear_quick_save() {
  if (_internal_has_quick_save()) {
    delete response_.quick_save_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseQuickSave* Response::release_quick_save() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quick_save)
  if (_internal_has_quick_save()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuickSave* temp = response_.quick_save_;
    response_.quick_save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseQuickSave& Response::_internal_quick_save() const {
  return _internal_has_quick_save()
      ? *response_.quick_save_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuickSave*>(&::SC2APIProtocol::_ResponseQuickSave_default_instance_);
}
inline const ::SC2APIProtocol::ResponseQuickSave& Response::quick_save() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quick_save)
  return _internal_quick_save();
}
inline ::SC2APIProtocol::ResponseQuickSave* Response::_internal_mutable_quick_save() {
  if (!_internal_has_quick_save()) {
    clear_response();
    set_has_quick_save();
    response_.quick_save_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuickSave >(
        GetArenaNoVirtual());
  }
  return response_.quick_save_;
}
inline ::SC2APIProtocol::ResponseQuickSave* Response::mutable_quick_save() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quick_save)
  return _internal_mutable_quick_save();
}

// optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;
inline bool Response::_internal_has_quick_load() const {
  return response_case() == kQuickLoad;
}
inline bool Response::has_quick_load() const {
  return _internal_has_quick_load();
}
inline void Response::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Response::clear_quick_load() {
  if (_internal_has_quick_load()) {
    delete response_.quick_load_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseQuickLoad* Response::release_quick_load() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quick_load)
  if (_internal_has_quick_load()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuickLoad* temp = response_.quick_load_;
    response_.quick_load_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseQuickLoad& Response::_internal_quick_load() const {
  return _internal_has_quick_load()
      ? *response_.quick_load_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuickLoad*>(&::SC2APIProtocol::_ResponseQuickLoad_default_instance_);
}
inline const ::SC2APIProtocol::ResponseQuickLoad& Response::quick_load() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quick_load)
  return _internal_quick_load();
}
inline ::SC2APIProtocol::ResponseQuickLoad* Response::_internal_mutable_quick_load() {
  if (!_internal_has_quick_load()) {
    clear_response();
    set_has_quick_load();
    response_.quick_load_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuickLoad >(
        GetArenaNoVirtual());
  }
  return response_.quick_load_;
}
inline ::SC2APIProtocol::ResponseQuickLoad* Response::mutable_quick_load() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quick_load)
  return _internal_mutable_quick_load();
}

// optional .SC2APIProtocol.ResponseQuit quit = 8;
inline bool Response::_internal_has_quit() const {
  return response_case() == kQuit;
}
inline bool Response::has_quit() const {
  return _internal_has_quit();
}
inline void Response::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Response::clear_quit() {
  if (_internal_has_quit()) {
    delete response_.quit_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseQuit* Response::release_quit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quit)
  if (_internal_has_quit()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuit* temp = response_.quit_;
    response_.quit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseQuit& Response::_internal_quit() const {
  return _internal_has_quit()
      ? *response_.quit_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuit*>(&::SC2APIProtocol::_ResponseQuit_default_instance_);
}
inline const ::SC2APIProtocol::ResponseQuit& Response::quit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quit)
  return _internal_quit();
}
inline ::SC2APIProtocol::ResponseQuit* Response::_internal_mutable_quit() {
  if (!_internal_has_quit()) {
    clear_response();
    set_has_quit();
    response_.quit_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuit >(
        GetArenaNoVirtual());
  }
  return response_.quit_;
}
inline ::SC2APIProtocol::ResponseQuit* Response::mutable_quit() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quit)
  return _internal_mutable_quit();
}

// optional .SC2APIProtocol.ResponseGameInfo game_info = 9;
inline bool Response::_internal_has_game_info() const {
  return response_case() == kGameInfo;
}
inline bool Response::has_game_info() const {
  return _internal_has_game_info();
}
inline void Response::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Response::clear_game_info() {
  if (_internal_has_game_info()) {
    delete response_.game_info_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseGameInfo* Response::release_game_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.game_info)
  if (_internal_has_game_info()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseGameInfo* temp = response_.game_info_;
    response_.game_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseGameInfo& Response::_internal_game_info() const {
  return _internal_has_game_info()
      ? *response_.game_info_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseGameInfo*>(&::SC2APIProtocol::_ResponseGameInfo_default_instance_);
}
inline const ::SC2APIProtocol::ResponseGameInfo& Response::game_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.game_info)
  return _internal_game_info();
}
inline ::SC2APIProtocol::ResponseGameInfo* Response::_internal_mutable_game_info() {
  if (!_internal_has_game_info()) {
    clear_response();
    set_has_game_info();
    response_.game_info_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseGameInfo >(
        GetArenaNoVirtual());
  }
  return response_.game_info_;
}
inline ::SC2APIProtocol::ResponseGameInfo* Response::mutable_game_info() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.game_info)
  return _internal_mutable_game_info();
}

// optional .SC2APIProtocol.ResponseObservation observation = 10;
inline bool Response::_internal_has_observation() const {
  return response_case() == kObservation;
}
inline bool Response::has_observation() const {
  return _internal_has_observation();
}
inline void Response::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Response::clear_observation() {
  if (_internal_has_observation()) {
    delete response_.observation_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseObservation* Response::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.observation)
  if (_internal_has_observation()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseObservation* temp = response_.observation_;
    response_.observation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseObservation& Response::_internal_observation() const {
  return _internal_has_observation()
      ? *response_.observation_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseObservation*>(&::SC2APIProtocol::_ResponseObservation_default_instance_);
}
inline const ::SC2APIProtocol::ResponseObservation& Response::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.observation)
  return _internal_observation();
}
inline ::SC2APIProtocol::ResponseObservation* Response::_internal_mutable_observation() {
  if (!_internal_has_observation()) {
    clear_response();
    set_has_observation();
    response_.observation_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseObservation >(
        GetArenaNoVirtual());
  }
  return response_.observation_;
}
inline ::SC2APIProtocol::ResponseObservation* Response::mutable_observation() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.observation)
  return _internal_mutable_observation();
}

// optional .SC2APIProtocol.ResponseAction action = 11;
inline bool Response::_internal_has_action() const {
  return response_case() == kAction;
}
inline bool Response::has_action() const {
  return _internal_has_action();
}
inline void Response::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Response::clear_action() {
  if (_internal_has_action()) {
    delete response_.action_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseAction* Response::release_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.action)
  if (_internal_has_action()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseAction* temp = response_.action_;
    response_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseAction& Response::_internal_action() const {
  return _internal_has_action()
      ? *response_.action_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseAction*>(&::SC2APIProtocol::_ResponseAction_default_instance_);
}
inline const ::SC2APIProtocol::ResponseAction& Response::action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.action)
  return _internal_action();
}
inline ::SC2APIProtocol::ResponseAction* Response::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_response();
    set_has_action();
    response_.action_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseAction >(
        GetArenaNoVirtual());
  }
  return response_.action_;
}
inline ::SC2APIProtocol::ResponseAction* Response::mutable_action() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.action)
  return _internal_mutable_action();
}

// optional .SC2APIProtocol.ResponseObserverAction obs_action = 21;
inline bool Response::_internal_has_obs_action() const {
  return response_case() == kObsAction;
}
inline bool Response::has_obs_action() const {
  return _internal_has_obs_action();
}
inline void Response::set_has_obs_action() {
  _oneof_case_[0] = kObsAction;
}
inline void Response::clear_obs_action() {
  if (_internal_has_obs_action()) {
    delete response_.obs_action_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseObserverAction* Response::release_obs_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.obs_action)
  if (_internal_has_obs_action()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseObserverAction* temp = response_.obs_action_;
    response_.obs_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseObserverAction& Response::_internal_obs_action() const {
  return _internal_has_obs_action()
      ? *response_.obs_action_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseObserverAction*>(&::SC2APIProtocol::_ResponseObserverAction_default_instance_);
}
inline const ::SC2APIProtocol::ResponseObserverAction& Response::obs_action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.obs_action)
  return _internal_obs_action();
}
inline ::SC2APIProtocol::ResponseObserverAction* Response::_internal_mutable_obs_action() {
  if (!_internal_has_obs_action()) {
    clear_response();
    set_has_obs_action();
    response_.obs_action_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseObserverAction >(
        GetArenaNoVirtual());
  }
  return response_.obs_action_;
}
inline ::SC2APIProtocol::ResponseObserverAction* Response::mutable_obs_action() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.obs_action)
  return _internal_mutable_obs_action();
}

// optional .SC2APIProtocol.ResponseStep step = 12;
inline bool Response::_internal_has_step() const {
  return response_case() == kStep;
}
inline bool Response::has_step() const {
  return _internal_has_step();
}
inline void Response::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Response::clear_step() {
  if (_internal_has_step()) {
    delete response_.step_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseStep* Response::release_step() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.step)
  if (_internal_has_step()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseStep* temp = response_.step_;
    response_.step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseStep& Response::_internal_step() const {
  return _internal_has_step()
      ? *response_.step_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseStep*>(&::SC2APIProtocol::_ResponseStep_default_instance_);
}
inline const ::SC2APIProtocol::ResponseStep& Response::step() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.step)
  return _internal_step();
}
inline ::SC2APIProtocol::ResponseStep* Response::_internal_mutable_step() {
  if (!_internal_has_step()) {
    clear_response();
    set_has_step();
    response_.step_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseStep >(
        GetArenaNoVirtual());
  }
  return response_.step_;
}
inline ::SC2APIProtocol::ResponseStep* Response::mutable_step() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.step)
  return _internal_mutable_step();
}

// optional .SC2APIProtocol.ResponseData data = 13;
inline bool Response::_internal_has_data() const {
  return response_case() == kData;
}
inline bool Response::has_data() const {
  return _internal_has_data();
}
inline void Response::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Response::clear_data() {
  if (_internal_has_data()) {
    delete response_.data_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseData* Response::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.data)
  if (_internal_has_data()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseData* temp = response_.data_;
    response_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseData& Response::_internal_data() const {
  return _internal_has_data()
      ? *response_.data_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseData*>(&::SC2APIProtocol::_ResponseData_default_instance_);
}
inline const ::SC2APIProtocol::ResponseData& Response::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.data)
  return _internal_data();
}
inline ::SC2APIProtocol::ResponseData* Response::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_response();
    set_has_data();
    response_.data_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseData >(
        GetArenaNoVirtual());
  }
  return response_.data_;
}
inline ::SC2APIProtocol::ResponseData* Response::mutable_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.data)
  return _internal_mutable_data();
}

// optional .SC2APIProtocol.ResponseQuery query = 14;
inline bool Response::_internal_has_query() const {
  return response_case() == kQuery;
}
inline bool Response::has_query() const {
  return _internal_has_query();
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline ::SC2APIProtocol::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.query)
  if (_internal_has_query()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuery* temp = response_.query_;
    response_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseQuery& Response::_internal_query() const {
  return _internal_has_query()
      ? *response_.query_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuery*>(&::SC2APIProtocol::_ResponseQuery_default_instance_);
}
inline const ::SC2APIProtocol::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.query)
  return _internal_query();
}
inline ::SC2APIProtocol::ResponseQuery* Response::_internal_mutable_query() {
  if (!_internal_has_query()) {
    clear_response();
    set_has_query();
    response_.query_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuery >(
        GetArenaNoVirtual());
  }
  return response_.query_;
}
inline ::SC2APIProtocol::ResponseQuery* Response::mutable_query() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.query)
  return _internal_mutable_query();
}

// optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;
inline bool Response::_internal_has_save_replay() const {
  return response_case() == kSaveReplay;
}
inline bool Response::has_save_replay() const {
  return _internal_has_save_replay();
}
inline void Response::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Response::clear_save_replay() {
  if (_internal_has_save_replay()) {
    delete response_.save_replay_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseSaveReplay* Response::release_save_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.save_replay)
  if (_internal_has_save_replay()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseSaveReplay* temp = response_.save_replay_;
    response_.save_replay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseSaveReplay& Response::_internal_save_replay() const {
  return _internal_has_save_replay()
      ? *response_.save_replay_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseSaveReplay*>(&::SC2APIProtocol::_ResponseSaveReplay_default_instance_);
}
inline const ::SC2APIProtocol::ResponseSaveReplay& Response::save_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.save_replay)
  return _internal_save_replay();
}
inline ::SC2APIProtocol::ResponseSaveReplay* Response::_internal_mutable_save_replay() {
  if (!_internal_has_save_replay()) {
    clear_response();
    set_has_save_replay();
    response_.save_replay_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseSaveReplay >(
        GetArenaNoVirtual());
  }
  return response_.save_replay_;
}
inline ::SC2APIProtocol::ResponseSaveReplay* Response::mutable_save_replay() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.save_replay)
  return _internal_mutable_save_replay();
}

// optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;
inline bool Response::_internal_has_replay_info() const {
  return response_case() == kReplayInfo;
}
inline bool Response::has_replay_info() const {
  return _internal_has_replay_info();
}
inline void Response::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Response::clear_replay_info() {
  if (_internal_has_replay_info()) {
    delete response_.replay_info_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseReplayInfo* Response::release_replay_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.replay_info)
  if (_internal_has_replay_info()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseReplayInfo* temp = response_.replay_info_;
    response_.replay_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseReplayInfo& Response::_internal_replay_info() const {
  return _internal_has_replay_info()
      ? *response_.replay_info_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseReplayInfo*>(&::SC2APIProtocol::_ResponseReplayInfo_default_instance_);
}
inline const ::SC2APIProtocol::ResponseReplayInfo& Response::replay_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.replay_info)
  return _internal_replay_info();
}
inline ::SC2APIProtocol::ResponseReplayInfo* Response::_internal_mutable_replay_info() {
  if (!_internal_has_replay_info()) {
    clear_response();
    set_has_replay_info();
    response_.replay_info_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseReplayInfo >(
        GetArenaNoVirtual());
  }
  return response_.replay_info_;
}
inline ::SC2APIProtocol::ResponseReplayInfo* Response::mutable_replay_info() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.replay_info)
  return _internal_mutable_replay_info();
}

// optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;
inline bool Response::_internal_has_available_maps() const {
  return response_case() == kAvailableMaps;
}
inline bool Response::has_available_maps() const {
  return _internal_has_available_maps();
}
inline void Response::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Response::clear_available_maps() {
  if (_internal_has_available_maps()) {
    delete response_.available_maps_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseAvailableMaps* Response::release_available_maps() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.available_maps)
  if (_internal_has_available_maps()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseAvailableMaps* temp = response_.available_maps_;
    response_.available_maps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseAvailableMaps& Response::_internal_available_maps() const {
  return _internal_has_available_maps()
      ? *response_.available_maps_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseAvailableMaps*>(&::SC2APIProtocol::_ResponseAvailableMaps_default_instance_);
}
inline const ::SC2APIProtocol::ResponseAvailableMaps& Response::available_maps() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.available_maps)
  return _internal_available_maps();
}
inline ::SC2APIProtocol::ResponseAvailableMaps* Response::_internal_mutable_available_maps() {
  if (!_internal_has_available_maps()) {
    clear_response();
    set_has_available_maps();
    response_.available_maps_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseAvailableMaps >(
        GetArenaNoVirtual());
  }
  return response_.available_maps_;
}
inline ::SC2APIProtocol::ResponseAvailableMaps* Response::mutable_available_maps() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.available_maps)
  return _internal_mutable_available_maps();
}

// optional .SC2APIProtocol.ResponseSaveMap save_map = 18;
inline bool Response::_internal_has_save_map() const {
  return response_case() == kSaveMap;
}
inline bool Response::has_save_map() const {
  return _internal_has_save_map();
}
inline void Response::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Response::clear_save_map() {
  if (_internal_has_save_map()) {
    delete response_.save_map_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseSaveMap* Response::release_save_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.save_map)
  if (_internal_has_save_map()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseSaveMap* temp = response_.save_map_;
    response_.save_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseSaveMap& Response::_internal_save_map() const {
  return _internal_has_save_map()
      ? *response_.save_map_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseSaveMap*>(&::SC2APIProtocol::_ResponseSaveMap_default_instance_);
}
inline const ::SC2APIProtocol::ResponseSaveMap& Response::save_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.save_map)
  return _internal_save_map();
}
inline ::SC2APIProtocol::ResponseSaveMap* Response::_internal_mutable_save_map() {
  if (!_internal_has_save_map()) {
    clear_response();
    set_has_save_map();
    response_.save_map_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseSaveMap >(
        GetArenaNoVirtual());
  }
  return response_.save_map_;
}
inline ::SC2APIProtocol::ResponseSaveMap* Response::mutable_save_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.save_map)
  return _internal_mutable_save_map();
}

// optional .SC2APIProtocol.ResponseMapCommand map_command = 22;
inline bool Response::_internal_has_map_command() const {
  return response_case() == kMapCommand;
}
inline bool Response::has_map_command() const {
  return _internal_has_map_command();
}
inline void Response::set_has_map_command() {
  _oneof_case_[0] = kMapCommand;
}
inline void Response::clear_map_command() {
  if (_internal_has_map_command()) {
    delete response_.map_command_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseMapCommand* Response::release_map_command() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.map_command)
  if (_internal_has_map_command()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseMapCommand* temp = response_.map_command_;
    response_.map_command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseMapCommand& Response::_internal_map_command() const {
  return _internal_has_map_command()
      ? *response_.map_command_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseMapCommand*>(&::SC2APIProtocol::_ResponseMapCommand_default_instance_);
}
inline const ::SC2APIProtocol::ResponseMapCommand& Response::map_command() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.map_command)
  return _internal_map_command();
}
inline ::SC2APIProtocol::ResponseMapCommand* Response::_internal_mutable_map_command() {
  if (!_internal_has_map_command()) {
    clear_response();
    set_has_map_command();
    response_.map_command_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseMapCommand >(
        GetArenaNoVirtual());
  }
  return response_.map_command_;
}
inline ::SC2APIProtocol::ResponseMapCommand* Response::mutable_map_command() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.map_command)
  return _internal_mutable_map_command();
}

// optional .SC2APIProtocol.ResponsePing ping = 19;
inline bool Response::_internal_has_ping() const {
  return response_case() == kPing;
}
inline bool Response::has_ping() const {
  return _internal_has_ping();
}
inline void Response::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Response::clear_ping() {
  if (_internal_has_ping()) {
    delete response_.ping_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponsePing* Response::release_ping() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.ping)
  if (_internal_has_ping()) {
    clear_has_response();
      ::SC2APIProtocol::ResponsePing* temp = response_.ping_;
    response_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponsePing& Response::_internal_ping() const {
  return _internal_has_ping()
      ? *response_.ping_
      : *reinterpret_cast< ::SC2APIProtocol::ResponsePing*>(&::SC2APIProtocol::_ResponsePing_default_instance_);
}
inline const ::SC2APIProtocol::ResponsePing& Response::ping() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.ping)
  return _internal_ping();
}
inline ::SC2APIProtocol::ResponsePing* Response::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_response();
    set_has_ping();
    response_.ping_ = CreateMaybeMessage< ::SC2APIProtocol::ResponsePing >(
        GetArenaNoVirtual());
  }
  return response_.ping_;
}
inline ::SC2APIProtocol::ResponsePing* Response::mutable_ping() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.ping)
  return _internal_mutable_ping();
}

// optional .SC2APIProtocol.ResponseDebug debug = 20;
inline bool Response::_internal_has_debug() const {
  return response_case() == kDebug;
}
inline bool Response::has_debug() const {
  return _internal_has_debug();
}
inline void Response::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Response::clear_debug() {
  if (_internal_has_debug()) {
    delete response_.debug_;
    clear_has_response();
  }
}
inline ::SC2APIProtocol::ResponseDebug* Response::release_debug() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.debug)
  if (_internal_has_debug()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseDebug* temp = response_.debug_;
    response_.debug_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ResponseDebug& Response::_internal_debug() const {
  return _internal_has_debug()
      ? *response_.debug_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseDebug*>(&::SC2APIProtocol::_ResponseDebug_default_instance_);
}
inline const ::SC2APIProtocol::ResponseDebug& Response::debug() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.debug)
  return _internal_debug();
}
inline ::SC2APIProtocol::ResponseDebug* Response::_internal_mutable_debug() {
  if (!_internal_has_debug()) {
    clear_response();
    set_has_debug();
    response_.debug_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseDebug >(
        GetArenaNoVirtual());
  }
  return response_.debug_;
}
inline ::SC2APIProtocol::ResponseDebug* Response::mutable_debug() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.debug)
  return _internal_mutable_debug();
}

// optional uint32 id = 97;
inline bool Response::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Response::has_id() const {
  return _internal_has_id();
}
inline void Response::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Response::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Response::id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.id)
  return _internal_id();
}
inline void Response::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void Response::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.id)
}

// repeated string error = 98;
inline int Response::_internal_error_size() const {
  return error_.size();
}
inline int Response::error_size() const {
  return _internal_error_size();
}
inline void Response::clear_error() {
  error_.Clear();
}
inline std::string* Response::add_error() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.Response.error)
  return _internal_add_error();
}
inline const std::string& Response::_internal_error(int index) const {
  return error_.Get(index);
}
inline const std::string& Response::error(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.error)
  return _internal_error(index);
}
inline std::string* Response::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.error)
  return error_.Mutable(index);
}
inline void Response::set_error(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.error)
  error_.Mutable(index)->assign(value);
}
inline void Response::set_error(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.error)
  error_.Mutable(index)->assign(std::move(value));
}
inline void Response::set_error(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  error_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.Response.error)
}
inline void Response::set_error(int index, const char* value, size_t size) {
  error_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.Response.error)
}
inline std::string* Response::_internal_add_error() {
  return error_.Add();
}
inline void Response::add_error(const std::string& value) {
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Response.error)
}
inline void Response::add_error(std::string&& value) {
  error_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Response.error)
}
inline void Response::add_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.Response.error)
}
inline void Response::add_error(const char* value, size_t size) {
  error_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.Response.error)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Response::error() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Response.error)
  return error_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Response::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Response.error)
  return &error_;
}

// optional .SC2APIProtocol.Status status = 99;
inline bool Response::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Response::has_status() const {
  return _internal_has_status();
}
inline void Response::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::Status Response::_internal_status() const {
  return static_cast< ::SC2APIProtocol::Status >(status_);
}
inline ::SC2APIProtocol::Status Response::status() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.status)
  return _internal_status();
}
inline void Response::_internal_set_status(::SC2APIProtocol::Status value) {
  assert(::SC2APIProtocol::Status_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void Response::set_status(::SC2APIProtocol::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.status)
}

inline bool Response::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void Response::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline Response::ResponseCase Response::response_case() const {
  return Response::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestCreateGame

// optional .SC2APIProtocol.LocalMap local_map = 1;
inline bool RequestCreateGame::_internal_has_local_map() const {
  return Map_case() == kLocalMap;
}
inline bool RequestCreateGame::has_local_map() const {
  return _internal_has_local_map();
}
inline void RequestCreateGame::set_has_local_map() {
  _oneof_case_[0] = kLocalMap;
}
inline void RequestCreateGame::clear_local_map() {
  if (_internal_has_local_map()) {
    delete Map_.local_map_;
    clear_has_Map();
  }
}
inline ::SC2APIProtocol::LocalMap* RequestCreateGame::release_local_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestCreateGame.local_map)
  if (_internal_has_local_map()) {
    clear_has_Map();
      ::SC2APIProtocol::LocalMap* temp = Map_.local_map_;
    Map_.local_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::LocalMap& RequestCreateGame::_internal_local_map() const {
  return _internal_has_local_map()
      ? *Map_.local_map_
      : *reinterpret_cast< ::SC2APIProtocol::LocalMap*>(&::SC2APIProtocol::_LocalMap_default_instance_);
}
inline const ::SC2APIProtocol::LocalMap& RequestCreateGame::local_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.local_map)
  return _internal_local_map();
}
inline ::SC2APIProtocol::LocalMap* RequestCreateGame::_internal_mutable_local_map() {
  if (!_internal_has_local_map()) {
    clear_Map();
    set_has_local_map();
    Map_.local_map_ = CreateMaybeMessage< ::SC2APIProtocol::LocalMap >(
        GetArenaNoVirtual());
  }
  return Map_.local_map_;
}
inline ::SC2APIProtocol::LocalMap* RequestCreateGame::mutable_local_map() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.local_map)
  return _internal_mutable_local_map();
}

// optional string battlenet_map_name = 2;
inline bool RequestCreateGame::_internal_has_battlenet_map_name() const {
  return Map_case() == kBattlenetMapName;
}
inline bool RequestCreateGame::has_battlenet_map_name() const {
  return _internal_has_battlenet_map_name();
}
inline void RequestCreateGame::set_has_battlenet_map_name() {
  _oneof_case_[0] = kBattlenetMapName;
}
inline void RequestCreateGame::clear_battlenet_map_name() {
  if (_internal_has_battlenet_map_name()) {
    Map_.battlenet_map_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_Map();
  }
}
inline const std::string& RequestCreateGame::battlenet_map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  return _internal_battlenet_map_name();
}
inline void RequestCreateGame::set_battlenet_map_name(const std::string& value) {
  _internal_set_battlenet_map_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline std::string* RequestCreateGame::mutable_battlenet_map_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  return _internal_mutable_battlenet_map_name();
}
inline const std::string& RequestCreateGame::_internal_battlenet_map_name() const {
  if (_internal_has_battlenet_map_name()) {
    return Map_.battlenet_map_name_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RequestCreateGame::_internal_set_battlenet_map_name(const std::string& value) {
  if (!_internal_has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestCreateGame::set_battlenet_map_name(std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (!_internal_has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline void RequestCreateGame::set_battlenet_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline void RequestCreateGame::set_battlenet_map_name(const char* value, size_t size) {
  if (!_internal_has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline std::string* RequestCreateGame::_internal_mutable_battlenet_map_name() {
  if (!_internal_has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return Map_.battlenet_map_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestCreateGame::release_battlenet_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (_internal_has_battlenet_map_name()) {
    clear_has_Map();
    return Map_.battlenet_map_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RequestCreateGame::set_allocated_battlenet_map_name(std::string* battlenet_map_name) {
  if (has_Map()) {
    clear_Map();
  }
  if (battlenet_map_name != nullptr) {
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(battlenet_map_name);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}

// repeated .SC2APIProtocol.PlayerSetup player_setup = 3;
inline int RequestCreateGame::_internal_player_setup_size() const {
  return player_setup_.size();
}
inline int RequestCreateGame::player_setup_size() const {
  return _internal_player_setup_size();
}
inline void RequestCreateGame::clear_player_setup() {
  player_setup_.Clear();
}
inline ::SC2APIProtocol::PlayerSetup* RequestCreateGame::mutable_player_setup(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >*
RequestCreateGame::mutable_player_setup() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestCreateGame.player_setup)
  return &player_setup_;
}
inline const ::SC2APIProtocol::PlayerSetup& RequestCreateGame::_internal_player_setup(int index) const {
  return player_setup_.Get(index);
}
inline const ::SC2APIProtocol::PlayerSetup& RequestCreateGame::player_setup(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.player_setup)
  return _internal_player_setup(index);
}
inline ::SC2APIProtocol::PlayerSetup* RequestCreateGame::_internal_add_player_setup() {
  return player_setup_.Add();
}
inline ::SC2APIProtocol::PlayerSetup* RequestCreateGame::add_player_setup() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestCreateGame.player_setup)
  return _internal_add_player_setup();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >&
RequestCreateGame::player_setup() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_;
}

// optional bool disable_fog = 4;
inline bool RequestCreateGame::_internal_has_disable_fog() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestCreateGame::has_disable_fog() const {
  return _internal_has_disable_fog();
}
inline void RequestCreateGame::clear_disable_fog() {
  disable_fog_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool RequestCreateGame::_internal_disable_fog() const {
  return disable_fog_;
}
inline bool RequestCreateGame::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.disable_fog)
  return _internal_disable_fog();
}
inline void RequestCreateGame::_internal_set_disable_fog(bool value) {
  _has_bits_[0] |= 0x00000002u;
  disable_fog_ = value;
}
inline void RequestCreateGame::set_disable_fog(bool value) {
  _internal_set_disable_fog(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.disable_fog)
}

// optional uint32 random_seed = 5;
inline bool RequestCreateGame::_internal_has_random_seed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestCreateGame::has_random_seed() const {
  return _internal_has_random_seed();
}
inline void RequestCreateGame::clear_random_seed() {
  random_seed_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestCreateGame::_internal_random_seed() const {
  return random_seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestCreateGame::random_seed() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.random_seed)
  return _internal_random_seed();
}
inline void RequestCreateGame::_internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  random_seed_ = value;
}
inline void RequestCreateGame::set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.random_seed)
}

// optional bool realtime = 6;
inline bool RequestCreateGame::_internal_has_realtime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestCreateGame::has_realtime() const {
  return _internal_has_realtime();
}
inline void RequestCreateGame::clear_realtime() {
  realtime_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RequestCreateGame::_internal_realtime() const {
  return realtime_;
}
inline bool RequestCreateGame::realtime() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.realtime)
  return _internal_realtime();
}
inline void RequestCreateGame::_internal_set_realtime(bool value) {
  _has_bits_[0] |= 0x00000004u;
  realtime_ = value;
}
inline void RequestCreateGame::set_realtime(bool value) {
  _internal_set_realtime(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.realtime)
}

inline bool RequestCreateGame::has_Map() const {
  return Map_case() != MAP_NOT_SET;
}
inline void RequestCreateGame::clear_has_Map() {
  _oneof_case_[0] = MAP_NOT_SET;
}
inline RequestCreateGame::MapCase RequestCreateGame::Map_case() const {
  return RequestCreateGame::MapCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalMap

// optional string map_path = 1;
inline bool LocalMap::_internal_has_map_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalMap::has_map_path() const {
  return _internal_has_map_path();
}
inline void LocalMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocalMap::map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.LocalMap.map_path)
  return _internal_map_path();
}
inline void LocalMap::set_map_path(const std::string& value) {
  _internal_set_map_path(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.LocalMap.map_path)
}
inline std::string* LocalMap::mutable_map_path() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.LocalMap.map_path)
  return _internal_mutable_map_path();
}
inline const std::string& LocalMap::_internal_map_path() const {
  return map_path_.GetNoArena();
}
inline void LocalMap::_internal_set_map_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LocalMap::set_map_path(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.LocalMap.map_path)
}
inline void LocalMap::set_map_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.LocalMap.map_path)
}
inline void LocalMap::set_map_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.LocalMap.map_path)
}
inline std::string* LocalMap::_internal_mutable_map_path() {
  _has_bits_[0] |= 0x00000001u;
  return map_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LocalMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.LocalMap.map_path)
  if (!_internal_has_map_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return map_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_path(std::string* map_path) {
  if (map_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  map_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.LocalMap.map_path)
}

// optional bytes map_data = 7;
inline bool LocalMap::_internal_has_map_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocalMap::has_map_data() const {
  return _internal_has_map_data();
}
inline void LocalMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LocalMap::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.LocalMap.map_data)
  return _internal_map_data();
}
inline void LocalMap::set_map_data(const std::string& value) {
  _internal_set_map_data(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.LocalMap.map_data)
}
inline std::string* LocalMap::mutable_map_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.LocalMap.map_data)
  return _internal_mutable_map_data();
}
inline const std::string& LocalMap::_internal_map_data() const {
  return map_data_.GetNoArena();
}
inline void LocalMap::_internal_set_map_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LocalMap::set_map_data(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.LocalMap.map_data)
}
inline void LocalMap::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.LocalMap.map_data)
}
inline void LocalMap::set_map_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.LocalMap.map_data)
}
inline std::string* LocalMap::_internal_mutable_map_data() {
  _has_bits_[0] |= 0x00000002u;
  return map_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LocalMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.LocalMap.map_data)
  if (!_internal_has_map_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return map_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_data(std::string* map_data) {
  if (map_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  map_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.LocalMap.map_data)
}

// -------------------------------------------------------------------

// ResponseCreateGame

// optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;
inline bool ResponseCreateGame::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseCreateGame::has_error() const {
  return _internal_has_error();
}
inline void ResponseCreateGame::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::ResponseCreateGame_Error ResponseCreateGame::_internal_error() const {
  return static_cast< ::SC2APIProtocol::ResponseCreateGame_Error >(error_);
}
inline ::SC2APIProtocol::ResponseCreateGame_Error ResponseCreateGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseCreateGame.error)
  return _internal_error();
}
inline void ResponseCreateGame::_internal_set_error(::SC2APIProtocol::ResponseCreateGame_Error value) {
  assert(::SC2APIProtocol::ResponseCreateGame_Error_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  error_ = value;
}
inline void ResponseCreateGame::set_error(::SC2APIProtocol::ResponseCreateGame_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseCreateGame.error)
}

// optional string error_details = 2;
inline bool ResponseCreateGame::_internal_has_error_details() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseCreateGame::has_error_details() const {
  return _internal_has_error_details();
}
inline void ResponseCreateGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseCreateGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseCreateGame.error_details)
  return _internal_error_details();
}
inline void ResponseCreateGame::set_error_details(const std::string& value) {
  _internal_set_error_details(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline std::string* ResponseCreateGame::mutable_error_details() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseCreateGame.error_details)
  return _internal_mutable_error_details();
}
inline const std::string& ResponseCreateGame::_internal_error_details() const {
  return error_details_.GetNoArena();
}
inline void ResponseCreateGame::_internal_set_error_details(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseCreateGame::set_error_details(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline void ResponseCreateGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline void ResponseCreateGame::set_error_details(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline std::string* ResponseCreateGame::_internal_mutable_error_details() {
  _has_bits_[0] |= 0x00000001u;
  return error_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseCreateGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseCreateGame.error_details)
  if (!_internal_has_error_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCreateGame::set_allocated_error_details(std::string* error_details) {
  if (error_details != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseCreateGame.error_details)
}

// -------------------------------------------------------------------

// RequestJoinGame

// optional .SC2APIProtocol.Race race = 1;
inline bool RequestJoinGame::_internal_has_race() const {
  return participation_case() == kRace;
}
inline bool RequestJoinGame::has_race() const {
  return _internal_has_race();
}
inline void RequestJoinGame::set_has_race() {
  _oneof_case_[0] = kRace;
}
inline void RequestJoinGame::clear_race() {
  if (_internal_has_race()) {
    participation_.race_ = 0;
    clear_has_participation();
  }
}
inline ::SC2APIProtocol::Race RequestJoinGame::_internal_race() const {
  if (_internal_has_race()) {
    return static_cast< ::SC2APIProtocol::Race >(participation_.race_);
  }
  return static_cast< ::SC2APIProtocol::Race >(0);
}
inline ::SC2APIProtocol::Race RequestJoinGame::race() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.race)
  return _internal_race();
}
inline void RequestJoinGame::_internal_set_race(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  if (!_internal_has_race()) {
    clear_participation();
    set_has_race();
  }
  participation_.race_ = value;
}
inline void RequestJoinGame::set_race(::SC2APIProtocol::Race value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.race)
  _internal_set_race(value);
}

// optional uint32 observed_player_id = 2;
inline bool RequestJoinGame::_internal_has_observed_player_id() const {
  return participation_case() == kObservedPlayerId;
}
inline bool RequestJoinGame::has_observed_player_id() const {
  return _internal_has_observed_player_id();
}
inline void RequestJoinGame::set_has_observed_player_id() {
  _oneof_case_[0] = kObservedPlayerId;
}
inline void RequestJoinGame::clear_observed_player_id() {
  if (_internal_has_observed_player_id()) {
    participation_.observed_player_id_ = 0u;
    clear_has_participation();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestJoinGame::_internal_observed_player_id() const {
  if (_internal_has_observed_player_id()) {
    return participation_.observed_player_id_;
  }
  return 0u;
}
inline void RequestJoinGame::_internal_set_observed_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  if (!_internal_has_observed_player_id()) {
    clear_participation();
    set_has_observed_player_id();
  }
  participation_.observed_player_id_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestJoinGame::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.observed_player_id)
  return _internal_observed_player_id();
}
inline void RequestJoinGame::set_observed_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_observed_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.observed_player_id)
}

// optional .SC2APIProtocol.InterfaceOptions options = 3;
inline bool RequestJoinGame::_internal_has_options() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || options_ != nullptr);
  return value;
}
inline bool RequestJoinGame::has_options() const {
  return _internal_has_options();
}
inline void RequestJoinGame::clear_options() {
  if (options_ != nullptr) options_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestJoinGame::_internal_options() const {
  const ::SC2APIProtocol::InterfaceOptions* p = options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::InterfaceOptions*>(
      &::SC2APIProtocol::_InterfaceOptions_default_instance_);
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestJoinGame::options() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.options)
  return _internal_options();
}
inline ::SC2APIProtocol::InterfaceOptions* RequestJoinGame::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.options)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestJoinGame::_internal_mutable_options() {
  _has_bits_[0] |= 0x00000004u;
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  return options_;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestJoinGame::mutable_options() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.options)
  return _internal_mutable_options();
}
inline void RequestJoinGame::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.options)
}

// optional .SC2APIProtocol.PortSet server_ports = 4;
inline bool RequestJoinGame::_internal_has_server_ports() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || server_ports_ != nullptr);
  return value;
}
inline bool RequestJoinGame::has_server_ports() const {
  return _internal_has_server_ports();
}
inline void RequestJoinGame::clear_server_ports() {
  if (server_ports_ != nullptr) server_ports_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::_internal_server_ports() const {
  const ::SC2APIProtocol::PortSet* p = server_ports_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::PortSet*>(
      &::SC2APIProtocol::_PortSet_default_instance_);
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::server_ports() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.server_ports)
  return _internal_server_ports();
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::release_server_ports() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.server_ports)
  _has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::PortSet* temp = server_ports_;
  server_ports_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::_internal_mutable_server_ports() {
  _has_bits_[0] |= 0x00000008u;
  if (server_ports_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PortSet>(GetArenaNoVirtual());
    server_ports_ = p;
  }
  return server_ports_;
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::mutable_server_ports() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.server_ports)
  return _internal_mutable_server_ports();
}
inline void RequestJoinGame::set_allocated_server_ports(::SC2APIProtocol::PortSet* server_ports) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete server_ports_;
  }
  if (server_ports) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      server_ports = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_ports, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  server_ports_ = server_ports;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.server_ports)
}

// repeated .SC2APIProtocol.PortSet client_ports = 5;
inline int RequestJoinGame::_internal_client_ports_size() const {
  return client_ports_.size();
}
inline int RequestJoinGame::client_ports_size() const {
  return _internal_client_ports_size();
}
inline void RequestJoinGame::clear_client_ports() {
  client_ports_.Clear();
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::mutable_client_ports(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PortSet >*
RequestJoinGame::mutable_client_ports() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestJoinGame.client_ports)
  return &client_ports_;
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::_internal_client_ports(int index) const {
  return client_ports_.Get(index);
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::client_ports(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.client_ports)
  return _internal_client_ports(index);
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::_internal_add_client_ports() {
  return client_ports_.Add();
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::add_client_ports() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestJoinGame.client_ports)
  return _internal_add_client_ports();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PortSet >&
RequestJoinGame::client_ports() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_;
}

// optional int32 shared_port = 6;
inline bool RequestJoinGame::_internal_has_shared_port() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequestJoinGame::has_shared_port() const {
  return _internal_has_shared_port();
}
inline void RequestJoinGame::clear_shared_port() {
  shared_port_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RequestJoinGame::_internal_shared_port() const {
  return shared_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RequestJoinGame::shared_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.shared_port)
  return _internal_shared_port();
}
inline void RequestJoinGame::_internal_set_shared_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  shared_port_ = value;
}
inline void RequestJoinGame::set_shared_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_shared_port(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.shared_port)
}

// optional string player_name = 7;
inline bool RequestJoinGame::_internal_has_player_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestJoinGame::has_player_name() const {
  return _internal_has_player_name();
}
inline void RequestJoinGame::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestJoinGame::player_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.player_name)
  return _internal_player_name();
}
inline void RequestJoinGame::set_player_name(const std::string& value) {
  _internal_set_player_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.player_name)
}
inline std::string* RequestJoinGame::mutable_player_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.player_name)
  return _internal_mutable_player_name();
}
inline const std::string& RequestJoinGame::_internal_player_name() const {
  return player_name_.GetNoArena();
}
inline void RequestJoinGame::_internal_set_player_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestJoinGame::set_player_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestJoinGame.player_name)
}
inline void RequestJoinGame::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestJoinGame.player_name)
}
inline void RequestJoinGame::set_player_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestJoinGame.player_name)
}
inline std::string* RequestJoinGame::_internal_mutable_player_name() {
  _has_bits_[0] |= 0x00000001u;
  return player_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestJoinGame::release_player_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.player_name)
  if (!_internal_has_player_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RequestJoinGame::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.player_name)
}

// optional string host_ip = 8;
inline bool RequestJoinGame::_internal_has_host_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestJoinGame::has_host_ip() const {
  return _internal_has_host_ip();
}
inline void RequestJoinGame::clear_host_ip() {
  host_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RequestJoinGame::host_ip() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.host_ip)
  return _internal_host_ip();
}
inline void RequestJoinGame::set_host_ip(const std::string& value) {
  _internal_set_host_ip(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.host_ip)
}
inline std::string* RequestJoinGame::mutable_host_ip() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.host_ip)
  return _internal_mutable_host_ip();
}
inline const std::string& RequestJoinGame::_internal_host_ip() const {
  return host_ip_.GetNoArena();
}
inline void RequestJoinGame::_internal_set_host_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  host_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestJoinGame::set_host_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  host_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestJoinGame.host_ip)
}
inline void RequestJoinGame::set_host_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  host_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestJoinGame.host_ip)
}
inline void RequestJoinGame::set_host_ip(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  host_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestJoinGame.host_ip)
}
inline std::string* RequestJoinGame::_internal_mutable_host_ip() {
  _has_bits_[0] |= 0x00000002u;
  return host_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestJoinGame::release_host_ip() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.host_ip)
  if (!_internal_has_host_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return host_ip_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RequestJoinGame::set_allocated_host_ip(std::string* host_ip) {
  if (host_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  host_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_ip);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.host_ip)
}

inline bool RequestJoinGame::has_participation() const {
  return participation_case() != PARTICIPATION_NOT_SET;
}
inline void RequestJoinGame::clear_has_participation() {
  _oneof_case_[0] = PARTICIPATION_NOT_SET;
}
inline RequestJoinGame::ParticipationCase RequestJoinGame::participation_case() const {
  return RequestJoinGame::ParticipationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PortSet

// optional int32 game_port = 1;
inline bool PortSet::_internal_has_game_port() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PortSet::has_game_port() const {
  return _internal_has_game_port();
}
inline void PortSet::clear_game_port() {
  game_port_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortSet::_internal_game_port() const {
  return game_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortSet::game_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PortSet.game_port)
  return _internal_game_port();
}
inline void PortSet::_internal_set_game_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  game_port_ = value;
}
inline void PortSet::set_game_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_game_port(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PortSet.game_port)
}

// optional int32 base_port = 2;
inline bool PortSet::_internal_has_base_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PortSet::has_base_port() const {
  return _internal_has_base_port();
}
inline void PortSet::clear_base_port() {
  base_port_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortSet::_internal_base_port() const {
  return base_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PortSet::base_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PortSet.base_port)
  return _internal_base_port();
}
inline void PortSet::_internal_set_base_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  base_port_ = value;
}
inline void PortSet::set_base_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_base_port(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PortSet.base_port)
}

// -------------------------------------------------------------------

// ResponseJoinGame

// optional uint32 player_id = 1;
inline bool ResponseJoinGame::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseJoinGame::has_player_id() const {
  return _internal_has_player_id();
}
inline void ResponseJoinGame::clear_player_id() {
  player_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseJoinGame::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseJoinGame::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.player_id)
  return _internal_player_id();
}
inline void ResponseJoinGame::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  player_id_ = value;
}
inline void ResponseJoinGame::set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.player_id)
}

// optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;
inline bool ResponseJoinGame::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseJoinGame::has_error() const {
  return _internal_has_error();
}
inline void ResponseJoinGame::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SC2APIProtocol::ResponseJoinGame_Error ResponseJoinGame::_internal_error() const {
  return static_cast< ::SC2APIProtocol::ResponseJoinGame_Error >(error_);
}
inline ::SC2APIProtocol::ResponseJoinGame_Error ResponseJoinGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.error)
  return _internal_error();
}
inline void ResponseJoinGame::_internal_set_error(::SC2APIProtocol::ResponseJoinGame_Error value) {
  assert(::SC2APIProtocol::ResponseJoinGame_Error_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  error_ = value;
}
inline void ResponseJoinGame::set_error(::SC2APIProtocol::ResponseJoinGame_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.error)
}

// optional string error_details = 3;
inline bool ResponseJoinGame::_internal_has_error_details() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseJoinGame::has_error_details() const {
  return _internal_has_error_details();
}
inline void ResponseJoinGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseJoinGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.error_details)
  return _internal_error_details();
}
inline void ResponseJoinGame::set_error_details(const std::string& value) {
  _internal_set_error_details(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline std::string* ResponseJoinGame::mutable_error_details() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseJoinGame.error_details)
  return _internal_mutable_error_details();
}
inline const std::string& ResponseJoinGame::_internal_error_details() const {
  return error_details_.GetNoArena();
}
inline void ResponseJoinGame::_internal_set_error_details(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseJoinGame::set_error_details(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline void ResponseJoinGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline void ResponseJoinGame::set_error_details(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline std::string* ResponseJoinGame::_internal_mutable_error_details() {
  _has_bits_[0] |= 0x00000001u;
  return error_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseJoinGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseJoinGame.error_details)
  if (!_internal_has_error_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseJoinGame::set_allocated_error_details(std::string* error_details) {
  if (error_details != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseJoinGame.error_details)
}

// -------------------------------------------------------------------

// RequestRestartGame

// -------------------------------------------------------------------

// ResponseRestartGame

// optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;
inline bool ResponseRestartGame::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseRestartGame::has_error() const {
  return _internal_has_error();
}
inline void ResponseRestartGame::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SC2APIProtocol::ResponseRestartGame_Error ResponseRestartGame::_internal_error() const {
  return static_cast< ::SC2APIProtocol::ResponseRestartGame_Error >(error_);
}
inline ::SC2APIProtocol::ResponseRestartGame_Error ResponseRestartGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseRestartGame.error)
  return _internal_error();
}
inline void ResponseRestartGame::_internal_set_error(::SC2APIProtocol::ResponseRestartGame_Error value) {
  assert(::SC2APIProtocol::ResponseRestartGame_Error_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  error_ = value;
}
inline void ResponseRestartGame::set_error(::SC2APIProtocol::ResponseRestartGame_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseRestartGame.error)
}

// optional string error_details = 2;
inline bool ResponseRestartGame::_internal_has_error_details() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseRestartGame::has_error_details() const {
  return _internal_has_error_details();
}
inline void ResponseRestartGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseRestartGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseRestartGame.error_details)
  return _internal_error_details();
}
inline void ResponseRestartGame::set_error_details(const std::string& value) {
  _internal_set_error_details(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline std::string* ResponseRestartGame::mutable_error_details() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseRestartGame.error_details)
  return _internal_mutable_error_details();
}
inline const std::string& ResponseRestartGame::_internal_error_details() const {
  return error_details_.GetNoArena();
}
inline void ResponseRestartGame::_internal_set_error_details(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseRestartGame::set_error_details(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline void ResponseRestartGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline void ResponseRestartGame::set_error_details(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline std::string* ResponseRestartGame::_internal_mutable_error_details() {
  _has_bits_[0] |= 0x00000001u;
  return error_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseRestartGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseRestartGame.error_details)
  if (!_internal_has_error_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseRestartGame::set_allocated_error_details(std::string* error_details) {
  if (error_details != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseRestartGame.error_details)
}

// optional bool need_hard_reset = 3;
inline bool ResponseRestartGame::_internal_has_need_hard_reset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseRestartGame::has_need_hard_reset() const {
  return _internal_has_need_hard_reset();
}
inline void ResponseRestartGame::clear_need_hard_reset() {
  need_hard_reset_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ResponseRestartGame::_internal_need_hard_reset() const {
  return need_hard_reset_;
}
inline bool ResponseRestartGame::need_hard_reset() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseRestartGame.need_hard_reset)
  return _internal_need_hard_reset();
}
inline void ResponseRestartGame::_internal_set_need_hard_reset(bool value) {
  _has_bits_[0] |= 0x00000002u;
  need_hard_reset_ = value;
}
inline void ResponseRestartGame::set_need_hard_reset(bool value) {
  _internal_set_need_hard_reset(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseRestartGame.need_hard_reset)
}

// -------------------------------------------------------------------

// RequestStartReplay

// optional string replay_path = 1;
inline bool RequestStartReplay::_internal_has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline bool RequestStartReplay::has_replay_path() const {
  return _internal_has_replay_path();
}
inline void RequestStartReplay::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestStartReplay::clear_replay_path() {
  if (_internal_has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const std::string& RequestStartReplay::replay_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.replay_path)
  return _internal_replay_path();
}
inline void RequestStartReplay::set_replay_path(const std::string& value) {
  _internal_set_replay_path(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline std::string* RequestStartReplay::mutable_replay_path() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.replay_path)
  return _internal_mutable_replay_path();
}
inline const std::string& RequestStartReplay::_internal_replay_path() const {
  if (_internal_has_replay_path()) {
    return replay_.replay_path_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::_internal_set_replay_path(const std::string& value) {
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestStartReplay::set_replay_path(std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_path)
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline void RequestStartReplay::set_replay_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline void RequestStartReplay::set_replay_path(const char* value, size_t size) {
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline std::string* RequestStartReplay::_internal_mutable_replay_path() {
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return replay_.replay_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestStartReplay::release_replay_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.replay_path)
  if (_internal_has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RequestStartReplay::set_allocated_replay_path(std::string* replay_path) {
  if (has_replay()) {
    clear_replay();
  }
  if (replay_path != nullptr) {
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.replay_path)
}

// optional bytes replay_data = 5;
inline bool RequestStartReplay::_internal_has_replay_data() const {
  return replay_case() == kReplayData;
}
inline bool RequestStartReplay::has_replay_data() const {
  return _internal_has_replay_data();
}
inline void RequestStartReplay::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestStartReplay::clear_replay_data() {
  if (_internal_has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const std::string& RequestStartReplay::replay_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.replay_data)
  return _internal_replay_data();
}
inline void RequestStartReplay::set_replay_data(const std::string& value) {
  _internal_set_replay_data(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline std::string* RequestStartReplay::mutable_replay_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.replay_data)
  return _internal_mutable_replay_data();
}
inline const std::string& RequestStartReplay::_internal_replay_data() const {
  if (_internal_has_replay_data()) {
    return replay_.replay_data_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::_internal_set_replay_data(const std::string& value) {
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestStartReplay::set_replay_data(std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_data)
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline void RequestStartReplay::set_replay_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline void RequestStartReplay::set_replay_data(const void* value, size_t size) {
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline std::string* RequestStartReplay::_internal_mutable_replay_data() {
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return replay_.replay_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestStartReplay::release_replay_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.replay_data)
  if (_internal_has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RequestStartReplay::set_allocated_replay_data(std::string* replay_data) {
  if (has_replay()) {
    clear_replay();
  }
  if (replay_data != nullptr) {
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.replay_data)
}

// optional bytes map_data = 6;
inline bool RequestStartReplay::_internal_has_map_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestStartReplay::has_map_data() const {
  return _internal_has_map_data();
}
inline void RequestStartReplay::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestStartReplay::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.map_data)
  return _internal_map_data();
}
inline void RequestStartReplay::set_map_data(const std::string& value) {
  _internal_set_map_data(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.map_data)
}
inline std::string* RequestStartReplay::mutable_map_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.map_data)
  return _internal_mutable_map_data();
}
inline const std::string& RequestStartReplay::_internal_map_data() const {
  return map_data_.GetNoArena();
}
inline void RequestStartReplay::_internal_set_map_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestStartReplay::set_map_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  map_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestStartReplay.map_data)
}
inline void RequestStartReplay::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.map_data)
}
inline void RequestStartReplay::set_map_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.map_data)
}
inline std::string* RequestStartReplay::_internal_mutable_map_data() {
  _has_bits_[0] |= 0x00000001u;
  return map_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestStartReplay::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.map_data)
  if (!_internal_has_map_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return map_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RequestStartReplay::set_allocated_map_data(std::string* map_data) {
  if (map_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  map_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.map_data)
}

// optional int32 observed_player_id = 2;
inline bool RequestStartReplay::_internal_has_observed_player_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestStartReplay::has_observed_player_id() const {
  return _internal_has_observed_player_id();
}
inline void RequestStartReplay::clear_observed_player_id() {
  observed_player_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RequestStartReplay::_internal_observed_player_id() const {
  return observed_player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RequestStartReplay::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.observed_player_id)
  return _internal_observed_player_id();
}
inline void RequestStartReplay::_internal_set_observed_player_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  observed_player_id_ = value;
}
inline void RequestStartReplay::set_observed_player_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_observed_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.observed_player_id)
}

// optional .SC2APIProtocol.InterfaceOptions options = 3;
inline bool RequestStartReplay::_internal_has_options() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || options_ != nullptr);
  return value;
}
inline bool RequestStartReplay::has_options() const {
  return _internal_has_options();
}
inline void RequestStartReplay::clear_options() {
  if (options_ != nullptr) options_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestStartReplay::_internal_options() const {
  const ::SC2APIProtocol::InterfaceOptions* p = options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::InterfaceOptions*>(
      &::SC2APIProtocol::_InterfaceOptions_default_instance_);
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestStartReplay::options() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.options)
  return _internal_options();
}
inline ::SC2APIProtocol::InterfaceOptions* RequestStartReplay::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.options)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestStartReplay::_internal_mutable_options() {
  _has_bits_[0] |= 0x00000002u;
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  return options_;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestStartReplay::mutable_options() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.options)
  return _internal_mutable_options();
}
inline void RequestStartReplay::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.options)
}

// optional bool disable_fog = 4;
inline bool RequestStartReplay::_internal_has_disable_fog() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RequestStartReplay::has_disable_fog() const {
  return _internal_has_disable_fog();
}
inline void RequestStartReplay::clear_disable_fog() {
  disable_fog_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RequestStartReplay::_internal_disable_fog() const {
  return disable_fog_;
}
inline bool RequestStartReplay::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.disable_fog)
  return _internal_disable_fog();
}
inline void RequestStartReplay::_internal_set_disable_fog(bool value) {
  _has_bits_[0] |= 0x00000008u;
  disable_fog_ = value;
}
inline void RequestStartReplay::set_disable_fog(bool value) {
  _internal_set_disable_fog(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.disable_fog)
}

// optional bool realtime = 7;
inline bool RequestStartReplay::_internal_has_realtime() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequestStartReplay::has_realtime() const {
  return _internal_has_realtime();
}
inline void RequestStartReplay::clear_realtime() {
  realtime_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool RequestStartReplay::_internal_realtime() const {
  return realtime_;
}
inline bool RequestStartReplay::realtime() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.realtime)
  return _internal_realtime();
}
inline void RequestStartReplay::_internal_set_realtime(bool value) {
  _has_bits_[0] |= 0x00000010u;
  realtime_ = value;
}
inline void RequestStartReplay::set_realtime(bool value) {
  _internal_set_realtime(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.realtime)
}

// optional bool record_replay = 8;
inline bool RequestStartReplay::_internal_has_record_replay() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RequestStartReplay::has_record_replay() const {
  return _internal_has_record_replay();
}
inline void RequestStartReplay::clear_record_replay() {
  record_replay_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool RequestStartReplay::_internal_record_replay() const {
  return record_replay_;
}
inline bool RequestStartReplay::record_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.record_replay)
  return _internal_record_replay();
}
inline void RequestStartReplay::_internal_set_record_replay(bool value) {
  _has_bits_[0] |= 0x00000020u;
  record_replay_ = value;
}
inline void RequestStartReplay::set_record_replay(bool value) {
  _internal_set_record_replay(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.record_replay)
}

inline bool RequestStartReplay::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestStartReplay::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestStartReplay::ReplayCase RequestStartReplay::replay_case() const {
  return RequestStartReplay::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseStartReplay

// optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;
inline bool ResponseStartReplay::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseStartReplay::has_error() const {
  return _internal_has_error();
}
inline void ResponseStartReplay::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::ResponseStartReplay_Error ResponseStartReplay::_internal_error() const {
  return static_cast< ::SC2APIProtocol::ResponseStartReplay_Error >(error_);
}
inline ::SC2APIProtocol::ResponseStartReplay_Error ResponseStartReplay::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseStartReplay.error)
  return _internal_error();
}
inline void ResponseStartReplay::_internal_set_error(::SC2APIProtocol::ResponseStartReplay_Error value) {
  assert(::SC2APIProtocol::ResponseStartReplay_Error_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  error_ = value;
}
inline void ResponseStartReplay::set_error(::SC2APIProtocol::ResponseStartReplay_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseStartReplay.error)
}

// optional string error_details = 2;
inline bool ResponseStartReplay::_internal_has_error_details() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseStartReplay::has_error_details() const {
  return _internal_has_error_details();
}
inline void ResponseStartReplay::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseStartReplay::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseStartReplay.error_details)
  return _internal_error_details();
}
inline void ResponseStartReplay::set_error_details(const std::string& value) {
  _internal_set_error_details(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline std::string* ResponseStartReplay::mutable_error_details() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseStartReplay.error_details)
  return _internal_mutable_error_details();
}
inline const std::string& ResponseStartReplay::_internal_error_details() const {
  return error_details_.GetNoArena();
}
inline void ResponseStartReplay::_internal_set_error_details(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseStartReplay::set_error_details(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline void ResponseStartReplay::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline void ResponseStartReplay::set_error_details(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline std::string* ResponseStartReplay::_internal_mutable_error_details() {
  _has_bits_[0] |= 0x00000001u;
  return error_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseStartReplay::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseStartReplay.error_details)
  if (!_internal_has_error_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStartReplay::set_allocated_error_details(std::string* error_details) {
  if (error_details != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseStartReplay.error_details)
}

// -------------------------------------------------------------------

// RequestMapCommand

// optional string trigger_cmd = 1;
inline bool RequestMapCommand::_internal_has_trigger_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestMapCommand::has_trigger_cmd() const {
  return _internal_has_trigger_cmd();
}
inline void RequestMapCommand::clear_trigger_cmd() {
  trigger_cmd_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestMapCommand::trigger_cmd() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestMapCommand.trigger_cmd)
  return _internal_trigger_cmd();
}
inline void RequestMapCommand::set_trigger_cmd(const std::string& value) {
  _internal_set_trigger_cmd(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestMapCommand.trigger_cmd)
}
inline std::string* RequestMapCommand::mutable_trigger_cmd() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestMapCommand.trigger_cmd)
  return _internal_mutable_trigger_cmd();
}
inline const std::string& RequestMapCommand::_internal_trigger_cmd() const {
  return trigger_cmd_.GetNoArena();
}
inline void RequestMapCommand::_internal_set_trigger_cmd(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  trigger_cmd_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestMapCommand::set_trigger_cmd(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  trigger_cmd_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestMapCommand.trigger_cmd)
}
inline void RequestMapCommand::set_trigger_cmd(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  trigger_cmd_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestMapCommand.trigger_cmd)
}
inline void RequestMapCommand::set_trigger_cmd(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  trigger_cmd_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestMapCommand.trigger_cmd)
}
inline std::string* RequestMapCommand::_internal_mutable_trigger_cmd() {
  _has_bits_[0] |= 0x00000001u;
  return trigger_cmd_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestMapCommand::release_trigger_cmd() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestMapCommand.trigger_cmd)
  if (!_internal_has_trigger_cmd()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return trigger_cmd_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RequestMapCommand::set_allocated_trigger_cmd(std::string* trigger_cmd) {
  if (trigger_cmd != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trigger_cmd_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trigger_cmd);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestMapCommand.trigger_cmd)
}

// -------------------------------------------------------------------

// ResponseMapCommand

// optional .SC2APIProtocol.ResponseMapCommand.Error error = 1;
inline bool ResponseMapCommand::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseMapCommand::has_error() const {
  return _internal_has_error();
}
inline void ResponseMapCommand::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::ResponseMapCommand_Error ResponseMapCommand::_internal_error() const {
  return static_cast< ::SC2APIProtocol::ResponseMapCommand_Error >(error_);
}
inline ::SC2APIProtocol::ResponseMapCommand_Error ResponseMapCommand::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseMapCommand.error)
  return _internal_error();
}
inline void ResponseMapCommand::_internal_set_error(::SC2APIProtocol::ResponseMapCommand_Error value) {
  assert(::SC2APIProtocol::ResponseMapCommand_Error_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  error_ = value;
}
inline void ResponseMapCommand::set_error(::SC2APIProtocol::ResponseMapCommand_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseMapCommand.error)
}

// optional string error_details = 2;
inline bool ResponseMapCommand::_internal_has_error_details() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseMapCommand::has_error_details() const {
  return _internal_has_error_details();
}
inline void ResponseMapCommand::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseMapCommand::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseMapCommand.error_details)
  return _internal_error_details();
}
inline void ResponseMapCommand::set_error_details(const std::string& value) {
  _internal_set_error_details(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseMapCommand.error_details)
}
inline std::string* ResponseMapCommand::mutable_error_details() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseMapCommand.error_details)
  return _internal_mutable_error_details();
}
inline const std::string& ResponseMapCommand::_internal_error_details() const {
  return error_details_.GetNoArena();
}
inline void ResponseMapCommand::_internal_set_error_details(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseMapCommand::set_error_details(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseMapCommand.error_details)
}
inline void ResponseMapCommand::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseMapCommand.error_details)
}
inline void ResponseMapCommand::set_error_details(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseMapCommand.error_details)
}
inline std::string* ResponseMapCommand::_internal_mutable_error_details() {
  _has_bits_[0] |= 0x00000001u;
  return error_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseMapCommand::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseMapCommand.error_details)
  if (!_internal_has_error_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseMapCommand::set_allocated_error_details(std::string* error_details) {
  if (error_details != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseMapCommand.error_details)
}

// -------------------------------------------------------------------

// RequestLeaveGame

// -------------------------------------------------------------------

// ResponseLeaveGame

// -------------------------------------------------------------------

// RequestQuickSave

// -------------------------------------------------------------------

// ResponseQuickSave

// -------------------------------------------------------------------

// RequestQuickLoad

// -------------------------------------------------------------------

// ResponseQuickLoad

// -------------------------------------------------------------------

// RequestQuit

// -------------------------------------------------------------------

// ResponseQuit

// -------------------------------------------------------------------

// RequestGameInfo

// -------------------------------------------------------------------

// ResponseGameInfo

// optional string map_name = 1;
inline bool ResponseGameInfo::_internal_has_map_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseGameInfo::has_map_name() const {
  return _internal_has_map_name();
}
inline void ResponseGameInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseGameInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.map_name)
  return _internal_map_name();
}
inline void ResponseGameInfo::set_map_name(const std::string& value) {
  _internal_set_map_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline std::string* ResponseGameInfo::mutable_map_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.map_name)
  return _internal_mutable_map_name();
}
inline const std::string& ResponseGameInfo::_internal_map_name() const {
  return map_name_.GetNoArena();
}
inline void ResponseGameInfo::_internal_set_map_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseGameInfo::set_map_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline void ResponseGameInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline void ResponseGameInfo::set_map_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline std::string* ResponseGameInfo::_internal_mutable_map_name() {
  _has_bits_[0] |= 0x00000001u;
  return map_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseGameInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.map_name)
  if (!_internal_has_map_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return map_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  map_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.map_name)
}

// repeated string mod_names = 6;
inline int ResponseGameInfo::_internal_mod_names_size() const {
  return mod_names_.size();
}
inline int ResponseGameInfo::mod_names_size() const {
  return _internal_mod_names_size();
}
inline void ResponseGameInfo::clear_mod_names() {
  mod_names_.Clear();
}
inline std::string* ResponseGameInfo::add_mod_names() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseGameInfo.mod_names)
  return _internal_add_mod_names();
}
inline const std::string& ResponseGameInfo::_internal_mod_names(int index) const {
  return mod_names_.Get(index);
}
inline const std::string& ResponseGameInfo::mod_names(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.mod_names)
  return _internal_mod_names(index);
}
inline std::string* ResponseGameInfo::mutable_mod_names(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Mutable(index);
}
inline void ResponseGameInfo::set_mod_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.mod_names)
  mod_names_.Mutable(index)->assign(value);
}
inline void ResponseGameInfo::set_mod_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.mod_names)
  mod_names_.Mutable(index)->assign(std::move(value));
}
inline void ResponseGameInfo::set_mod_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mod_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::set_mod_names(int index, const char* value, size_t size) {
  mod_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline std::string* ResponseGameInfo::_internal_add_mod_names() {
  return mod_names_.Add();
}
inline void ResponseGameInfo::add_mod_names(const std::string& value) {
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::add_mod_names(std::string&& value) {
  mod_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::add_mod_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::add_mod_names(const char* value, size_t size) {
  mod_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponseGameInfo::mod_names() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResponseGameInfo::mutable_mod_names() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseGameInfo.mod_names)
  return &mod_names_;
}

// optional string local_map_path = 2;
inline bool ResponseGameInfo::_internal_has_local_map_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseGameInfo::has_local_map_path() const {
  return _internal_has_local_map_path();
}
inline void ResponseGameInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseGameInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.local_map_path)
  return _internal_local_map_path();
}
inline void ResponseGameInfo::set_local_map_path(const std::string& value) {
  _internal_set_local_map_path(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline std::string* ResponseGameInfo::mutable_local_map_path() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.local_map_path)
  return _internal_mutable_local_map_path();
}
inline const std::string& ResponseGameInfo::_internal_local_map_path() const {
  return local_map_path_.GetNoArena();
}
inline void ResponseGameInfo::_internal_set_local_map_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseGameInfo::set_local_map_path(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline void ResponseGameInfo::set_local_map_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline void ResponseGameInfo::set_local_map_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline std::string* ResponseGameInfo::_internal_mutable_local_map_path() {
  _has_bits_[0] |= 0x00000002u;
  return local_map_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseGameInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.local_map_path)
  if (!_internal_has_local_map_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return local_map_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_local_map_path(std::string* local_map_path) {
  if (local_map_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  local_map_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.local_map_path)
}

// repeated .SC2APIProtocol.PlayerInfo player_info = 3;
inline int ResponseGameInfo::_internal_player_info_size() const {
  return player_info_.size();
}
inline int ResponseGameInfo::player_info_size() const {
  return _internal_player_info_size();
}
inline void ResponseGameInfo::clear_player_info() {
  player_info_.Clear();
}
inline ::SC2APIProtocol::PlayerInfo* ResponseGameInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >*
ResponseGameInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseGameInfo.player_info)
  return &player_info_;
}
inline const ::SC2APIProtocol::PlayerInfo& ResponseGameInfo::_internal_player_info(int index) const {
  return player_info_.Get(index);
}
inline const ::SC2APIProtocol::PlayerInfo& ResponseGameInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.player_info)
  return _internal_player_info(index);
}
inline ::SC2APIProtocol::PlayerInfo* ResponseGameInfo::_internal_add_player_info() {
  return player_info_.Add();
}
inline ::SC2APIProtocol::PlayerInfo* ResponseGameInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.player_info)
  return _internal_add_player_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >&
ResponseGameInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_;
}

// optional .SC2APIProtocol.StartRaw start_raw = 4;
inline bool ResponseGameInfo::_internal_has_start_raw() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || start_raw_ != nullptr);
  return value;
}
inline bool ResponseGameInfo::has_start_raw() const {
  return _internal_has_start_raw();
}
inline const ::SC2APIProtocol::StartRaw& ResponseGameInfo::_internal_start_raw() const {
  const ::SC2APIProtocol::StartRaw* p = start_raw_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::StartRaw*>(
      &::SC2APIProtocol::_StartRaw_default_instance_);
}
inline const ::SC2APIProtocol::StartRaw& ResponseGameInfo::start_raw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.start_raw)
  return _internal_start_raw();
}
inline ::SC2APIProtocol::StartRaw* ResponseGameInfo::release_start_raw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.start_raw)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::StartRaw* temp = start_raw_;
  start_raw_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::StartRaw* ResponseGameInfo::_internal_mutable_start_raw() {
  _has_bits_[0] |= 0x00000004u;
  if (start_raw_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::StartRaw>(GetArenaNoVirtual());
    start_raw_ = p;
  }
  return start_raw_;
}
inline ::SC2APIProtocol::StartRaw* ResponseGameInfo::mutable_start_raw() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.start_raw)
  return _internal_mutable_start_raw();
}
inline void ResponseGameInfo::set_allocated_start_raw(::SC2APIProtocol::StartRaw* start_raw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_raw_);
  }
  if (start_raw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      start_raw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_raw, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  start_raw_ = start_raw;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.start_raw)
}

// optional .SC2APIProtocol.InterfaceOptions options = 5;
inline bool ResponseGameInfo::_internal_has_options() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || options_ != nullptr);
  return value;
}
inline bool ResponseGameInfo::has_options() const {
  return _internal_has_options();
}
inline void ResponseGameInfo::clear_options() {
  if (options_ != nullptr) options_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SC2APIProtocol::InterfaceOptions& ResponseGameInfo::_internal_options() const {
  const ::SC2APIProtocol::InterfaceOptions* p = options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::InterfaceOptions*>(
      &::SC2APIProtocol::_InterfaceOptions_default_instance_);
}
inline const ::SC2APIProtocol::InterfaceOptions& ResponseGameInfo::options() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.options)
  return _internal_options();
}
inline ::SC2APIProtocol::InterfaceOptions* ResponseGameInfo::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.options)
  _has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::InterfaceOptions* ResponseGameInfo::_internal_mutable_options() {
  _has_bits_[0] |= 0x00000008u;
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  return options_;
}
inline ::SC2APIProtocol::InterfaceOptions* ResponseGameInfo::mutable_options() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.options)
  return _internal_mutable_options();
}
inline void ResponseGameInfo::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.options)
}

// -------------------------------------------------------------------

// RequestObservation

// optional bool disable_fog = 1;
inline bool RequestObservation::_internal_has_disable_fog() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestObservation::has_disable_fog() const {
  return _internal_has_disable_fog();
}
inline void RequestObservation::clear_disable_fog() {
  disable_fog_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RequestObservation::_internal_disable_fog() const {
  return disable_fog_;
}
inline bool RequestObservation::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestObservation.disable_fog)
  return _internal_disable_fog();
}
inline void RequestObservation::_internal_set_disable_fog(bool value) {
  _has_bits_[0] |= 0x00000001u;
  disable_fog_ = value;
}
inline void RequestObservation::set_disable_fog(bool value) {
  _internal_set_disable_fog(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestObservation.disable_fog)
}

// optional uint32 game_loop = 2;
inline bool RequestObservation::_internal_has_game_loop() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestObservation::has_game_loop() const {
  return _internal_has_game_loop();
}
inline void RequestObservation::clear_game_loop() {
  game_loop_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestObservation::_internal_game_loop() const {
  return game_loop_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestObservation::game_loop() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestObservation.game_loop)
  return _internal_game_loop();
}
inline void RequestObservation::_internal_set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  game_loop_ = value;
}
inline void RequestObservation::set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_game_loop(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestObservation.game_loop)
}

// -------------------------------------------------------------------

// ResponseObservation

// repeated .SC2APIProtocol.Action actions = 1;
inline int ResponseObservation::_internal_actions_size() const {
  return actions_.size();
}
inline int ResponseObservation::actions_size() const {
  return _internal_actions_size();
}
inline void ResponseObservation::clear_actions() {
  actions_.Clear();
}
inline ::SC2APIProtocol::Action* ResponseObservation::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >*
ResponseObservation::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.actions)
  return &actions_;
}
inline const ::SC2APIProtocol::Action& ResponseObservation::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const ::SC2APIProtocol::Action& ResponseObservation::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.actions)
  return _internal_actions(index);
}
inline ::SC2APIProtocol::Action* ResponseObservation::_internal_add_actions() {
  return actions_.Add();
}
inline ::SC2APIProtocol::Action* ResponseObservation::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.actions)
  return _internal_add_actions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >&
ResponseObservation::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.actions)
  return actions_;
}

// repeated .SC2APIProtocol.ActionError action_errors = 2;
inline int ResponseObservation::_internal_action_errors_size() const {
  return action_errors_.size();
}
inline int ResponseObservation::action_errors_size() const {
  return _internal_action_errors_size();
}
inline void ResponseObservation::clear_action_errors() {
  action_errors_.Clear();
}
inline ::SC2APIProtocol::ActionError* ResponseObservation::mutable_action_errors(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ActionError >*
ResponseObservation::mutable_action_errors() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.action_errors)
  return &action_errors_;
}
inline const ::SC2APIProtocol::ActionError& ResponseObservation::_internal_action_errors(int index) const {
  return action_errors_.Get(index);
}
inline const ::SC2APIProtocol::ActionError& ResponseObservation::action_errors(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.action_errors)
  return _internal_action_errors(index);
}
inline ::SC2APIProtocol::ActionError* ResponseObservation::_internal_add_action_errors() {
  return action_errors_.Add();
}
inline ::SC2APIProtocol::ActionError* ResponseObservation::add_action_errors() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.action_errors)
  return _internal_add_action_errors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ActionError >&
ResponseObservation::action_errors() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_;
}

// optional .SC2APIProtocol.Observation observation = 3;
inline bool ResponseObservation::_internal_has_observation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || observation_ != nullptr);
  return value;
}
inline bool ResponseObservation::has_observation() const {
  return _internal_has_observation();
}
inline void ResponseObservation::clear_observation() {
  if (observation_ != nullptr) observation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Observation& ResponseObservation::_internal_observation() const {
  const ::SC2APIProtocol::Observation* p = observation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Observation*>(
      &::SC2APIProtocol::_Observation_default_instance_);
}
inline const ::SC2APIProtocol::Observation& ResponseObservation::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.observation)
  return _internal_observation();
}
inline ::SC2APIProtocol::Observation* ResponseObservation::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseObservation.observation)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Observation* temp = observation_;
  observation_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Observation* ResponseObservation::_internal_mutable_observation() {
  _has_bits_[0] |= 0x00000001u;
  if (observation_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Observation>(GetArenaNoVirtual());
    observation_ = p;
  }
  return observation_;
}
inline ::SC2APIProtocol::Observation* ResponseObservation::mutable_observation() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.observation)
  return _internal_mutable_observation();
}
inline void ResponseObservation::set_allocated_observation(::SC2APIProtocol::Observation* observation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete observation_;
  }
  if (observation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      observation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, observation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  observation_ = observation;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseObservation.observation)
}

// repeated .SC2APIProtocol.PlayerResult player_result = 4;
inline int ResponseObservation::_internal_player_result_size() const {
  return player_result_.size();
}
inline int ResponseObservation::player_result_size() const {
  return _internal_player_result_size();
}
inline void ResponseObservation::clear_player_result() {
  player_result_.Clear();
}
inline ::SC2APIProtocol::PlayerResult* ResponseObservation::mutable_player_result(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >*
ResponseObservation::mutable_player_result() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.player_result)
  return &player_result_;
}
inline const ::SC2APIProtocol::PlayerResult& ResponseObservation::_internal_player_result(int index) const {
  return player_result_.Get(index);
}
inline const ::SC2APIProtocol::PlayerResult& ResponseObservation::player_result(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.player_result)
  return _internal_player_result(index);
}
inline ::SC2APIProtocol::PlayerResult* ResponseObservation::_internal_add_player_result() {
  return player_result_.Add();
}
inline ::SC2APIProtocol::PlayerResult* ResponseObservation::add_player_result() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.player_result)
  return _internal_add_player_result();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >&
ResponseObservation::player_result() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_;
}

// repeated .SC2APIProtocol.ChatReceived chat = 5;
inline int ResponseObservation::_internal_chat_size() const {
  return chat_.size();
}
inline int ResponseObservation::chat_size() const {
  return _internal_chat_size();
}
inline void ResponseObservation::clear_chat() {
  chat_.Clear();
}
inline ::SC2APIProtocol::ChatReceived* ResponseObservation::mutable_chat(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.chat)
  return chat_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >*
ResponseObservation::mutable_chat() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.chat)
  return &chat_;
}
inline const ::SC2APIProtocol::ChatReceived& ResponseObservation::_internal_chat(int index) const {
  return chat_.Get(index);
}
inline const ::SC2APIProtocol::ChatReceived& ResponseObservation::chat(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.chat)
  return _internal_chat(index);
}
inline ::SC2APIProtocol::ChatReceived* ResponseObservation::_internal_add_chat() {
  return chat_.Add();
}
inline ::SC2APIProtocol::ChatReceived* ResponseObservation::add_chat() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.chat)
  return _internal_add_chat();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >&
ResponseObservation::chat() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.chat)
  return chat_;
}

// -------------------------------------------------------------------

// ChatReceived

// optional uint32 player_id = 1;
inline bool ChatReceived::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChatReceived::has_player_id() const {
  return _internal_has_player_id();
}
inline void ChatReceived::clear_player_id() {
  player_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChatReceived::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChatReceived::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ChatReceived.player_id)
  return _internal_player_id();
}
inline void ChatReceived::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  player_id_ = value;
}
inline void ChatReceived::set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ChatReceived.player_id)
}

// optional string message = 2;
inline bool ChatReceived::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatReceived::has_message() const {
  return _internal_has_message();
}
inline void ChatReceived::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatReceived::message() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ChatReceived.message)
  return _internal_message();
}
inline void ChatReceived::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ChatReceived.message)
}
inline std::string* ChatReceived::mutable_message() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ChatReceived.message)
  return _internal_mutable_message();
}
inline const std::string& ChatReceived::_internal_message() const {
  return message_.GetNoArena();
}
inline void ChatReceived::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ChatReceived::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ChatReceived.message)
}
inline void ChatReceived::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ChatReceived.message)
}
inline void ChatReceived::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ChatReceived.message)
}
inline std::string* ChatReceived::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChatReceived::release_message() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ChatReceived.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReceived::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ChatReceived.message)
}

// -------------------------------------------------------------------

// RequestAction

// repeated .SC2APIProtocol.Action actions = 1;
inline int RequestAction::_internal_actions_size() const {
  return actions_.size();
}
inline int RequestAction::actions_size() const {
  return _internal_actions_size();
}
inline void RequestAction::clear_actions() {
  actions_.Clear();
}
inline ::SC2APIProtocol::Action* RequestAction::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestAction.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >*
RequestAction::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestAction.actions)
  return &actions_;
}
inline const ::SC2APIProtocol::Action& RequestAction::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const ::SC2APIProtocol::Action& RequestAction::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestAction.actions)
  return _internal_actions(index);
}
inline ::SC2APIProtocol::Action* RequestAction::_internal_add_actions() {
  return actions_.Add();
}
inline ::SC2APIProtocol::Action* RequestAction::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestAction.actions)
  return _internal_add_actions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Action >&
RequestAction::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestAction.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ResponseAction

// repeated .SC2APIProtocol.ActionResult result = 1;
inline int ResponseAction::_internal_result_size() const {
  return result_.size();
}
inline int ResponseAction::result_size() const {
  return _internal_result_size();
}
inline void ResponseAction::clear_result() {
  result_.Clear();
}
inline ::SC2APIProtocol::ActionResult ResponseAction::_internal_result(int index) const {
  return static_cast< ::SC2APIProtocol::ActionResult >(result_.Get(index));
}
inline ::SC2APIProtocol::ActionResult ResponseAction::result(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAction.result)
  return _internal_result(index);
}
inline void ResponseAction::set_result(int index, ::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  result_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAction.result)
}
inline void ResponseAction::_internal_add_result(::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  result_.Add(value);
}
inline void ResponseAction::add_result(::SC2APIProtocol::ActionResult value) {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAction.result)
  _internal_add_result(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ResponseAction::result() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAction.result)
  return result_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ResponseAction::_internal_mutable_result() {
  return &result_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ResponseAction::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAction.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// RequestObserverAction

// repeated .SC2APIProtocol.ObserverAction actions = 1;
inline int RequestObserverAction::_internal_actions_size() const {
  return actions_.size();
}
inline int RequestObserverAction::actions_size() const {
  return _internal_actions_size();
}
inline void RequestObserverAction::clear_actions() {
  actions_.Clear();
}
inline ::SC2APIProtocol::ObserverAction* RequestObserverAction::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestObserverAction.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >*
RequestObserverAction::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestObserverAction.actions)
  return &actions_;
}
inline const ::SC2APIProtocol::ObserverAction& RequestObserverAction::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const ::SC2APIProtocol::ObserverAction& RequestObserverAction::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestObserverAction.actions)
  return _internal_actions(index);
}
inline ::SC2APIProtocol::ObserverAction* RequestObserverAction::_internal_add_actions() {
  return actions_.Add();
}
inline ::SC2APIProtocol::ObserverAction* RequestObserverAction::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestObserverAction.actions)
  return _internal_add_actions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >&
RequestObserverAction::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestObserverAction.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ResponseObserverAction

// -------------------------------------------------------------------

// RequestStep

// optional uint32 count = 1;
inline bool RequestStep::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestStep::has_count() const {
  return _internal_has_count();
}
inline void RequestStep::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestStep::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestStep::count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStep.count)
  return _internal_count();
}
inline void RequestStep::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  count_ = value;
}
inline void RequestStep::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStep.count)
}

// -------------------------------------------------------------------

// ResponseStep

// optional uint32 simulation_loop = 1;
inline bool ResponseStep::_internal_has_simulation_loop() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseStep::has_simulation_loop() const {
  return _internal_has_simulation_loop();
}
inline void ResponseStep::clear_simulation_loop() {
  simulation_loop_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseStep::_internal_simulation_loop() const {
  return simulation_loop_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseStep::simulation_loop() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseStep.simulation_loop)
  return _internal_simulation_loop();
}
inline void ResponseStep::_internal_set_simulation_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  simulation_loop_ = value;
}
inline void ResponseStep::set_simulation_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_simulation_loop(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseStep.simulation_loop)
}

// -------------------------------------------------------------------

// RequestData

// optional bool ability_id = 1;
inline bool RequestData::_internal_has_ability_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestData::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void RequestData::clear_ability_id() {
  ability_id_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RequestData::_internal_ability_id() const {
  return ability_id_;
}
inline bool RequestData::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.ability_id)
  return _internal_ability_id();
}
inline void RequestData::_internal_set_ability_id(bool value) {
  _has_bits_[0] |= 0x00000001u;
  ability_id_ = value;
}
inline void RequestData::set_ability_id(bool value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.ability_id)
}

// optional bool unit_type_id = 2;
inline bool RequestData::_internal_has_unit_type_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestData::has_unit_type_id() const {
  return _internal_has_unit_type_id();
}
inline void RequestData::clear_unit_type_id() {
  unit_type_id_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool RequestData::_internal_unit_type_id() const {
  return unit_type_id_;
}
inline bool RequestData::unit_type_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.unit_type_id)
  return _internal_unit_type_id();
}
inline void RequestData::_internal_set_unit_type_id(bool value) {
  _has_bits_[0] |= 0x00000002u;
  unit_type_id_ = value;
}
inline void RequestData::set_unit_type_id(bool value) {
  _internal_set_unit_type_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.unit_type_id)
}

// optional bool upgrade_id = 3;
inline bool RequestData::_internal_has_upgrade_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RequestData::has_upgrade_id() const {
  return _internal_has_upgrade_id();
}
inline void RequestData::clear_upgrade_id() {
  upgrade_id_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RequestData::_internal_upgrade_id() const {
  return upgrade_id_;
}
inline bool RequestData::upgrade_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.upgrade_id)
  return _internal_upgrade_id();
}
inline void RequestData::_internal_set_upgrade_id(bool value) {
  _has_bits_[0] |= 0x00000004u;
  upgrade_id_ = value;
}
inline void RequestData::set_upgrade_id(bool value) {
  _internal_set_upgrade_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.upgrade_id)
}

// optional bool buff_id = 4;
inline bool RequestData::_internal_has_buff_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RequestData::has_buff_id() const {
  return _internal_has_buff_id();
}
inline void RequestData::clear_buff_id() {
  buff_id_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RequestData::_internal_buff_id() const {
  return buff_id_;
}
inline bool RequestData::buff_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.buff_id)
  return _internal_buff_id();
}
inline void RequestData::_internal_set_buff_id(bool value) {
  _has_bits_[0] |= 0x00000008u;
  buff_id_ = value;
}
inline void RequestData::set_buff_id(bool value) {
  _internal_set_buff_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.buff_id)
}

// optional bool effect_id = 5;
inline bool RequestData::_internal_has_effect_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequestData::has_effect_id() const {
  return _internal_has_effect_id();
}
inline void RequestData::clear_effect_id() {
  effect_id_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool RequestData::_internal_effect_id() const {
  return effect_id_;
}
inline bool RequestData::effect_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.effect_id)
  return _internal_effect_id();
}
inline void RequestData::_internal_set_effect_id(bool value) {
  _has_bits_[0] |= 0x00000010u;
  effect_id_ = value;
}
inline void RequestData::set_effect_id(bool value) {
  _internal_set_effect_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.effect_id)
}

// -------------------------------------------------------------------

// ResponseData

// repeated .SC2APIProtocol.AbilityData abilities = 1;
inline int ResponseData::_internal_abilities_size() const {
  return abilities_.size();
}
inline int ResponseData::abilities_size() const {
  return _internal_abilities_size();
}
inline ::SC2APIProtocol::AbilityData* ResponseData::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.abilities)
  return abilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AbilityData >*
ResponseData::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.abilities)
  return &abilities_;
}
inline const ::SC2APIProtocol::AbilityData& ResponseData::_internal_abilities(int index) const {
  return abilities_.Get(index);
}
inline const ::SC2APIProtocol::AbilityData& ResponseData::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.abilities)
  return _internal_abilities(index);
}
inline ::SC2APIProtocol::AbilityData* ResponseData::_internal_add_abilities() {
  return abilities_.Add();
}
inline ::SC2APIProtocol::AbilityData* ResponseData::add_abilities() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.abilities)
  return _internal_add_abilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AbilityData >&
ResponseData::abilities() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.abilities)
  return abilities_;
}

// repeated .SC2APIProtocol.UnitTypeData units = 2;
inline int ResponseData::_internal_units_size() const {
  return units_.size();
}
inline int ResponseData::units_size() const {
  return _internal_units_size();
}
inline ::SC2APIProtocol::UnitTypeData* ResponseData::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.units)
  return units_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >*
ResponseData::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.units)
  return &units_;
}
inline const ::SC2APIProtocol::UnitTypeData& ResponseData::_internal_units(int index) const {
  return units_.Get(index);
}
inline const ::SC2APIProtocol::UnitTypeData& ResponseData::units(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.units)
  return _internal_units(index);
}
inline ::SC2APIProtocol::UnitTypeData* ResponseData::_internal_add_units() {
  return units_.Add();
}
inline ::SC2APIProtocol::UnitTypeData* ResponseData::add_units() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.units)
  return _internal_add_units();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >&
ResponseData::units() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.units)
  return units_;
}

// repeated .SC2APIProtocol.UpgradeData upgrades = 3;
inline int ResponseData::_internal_upgrades_size() const {
  return upgrades_.size();
}
inline int ResponseData::upgrades_size() const {
  return _internal_upgrades_size();
}
inline ::SC2APIProtocol::UpgradeData* ResponseData::mutable_upgrades(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >*
ResponseData::mutable_upgrades() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.upgrades)
  return &upgrades_;
}
inline const ::SC2APIProtocol::UpgradeData& ResponseData::_internal_upgrades(int index) const {
  return upgrades_.Get(index);
}
inline const ::SC2APIProtocol::UpgradeData& ResponseData::upgrades(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.upgrades)
  return _internal_upgrades(index);
}
inline ::SC2APIProtocol::UpgradeData* ResponseData::_internal_add_upgrades() {
  return upgrades_.Add();
}
inline ::SC2APIProtocol::UpgradeData* ResponseData::add_upgrades() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.upgrades)
  return _internal_add_upgrades();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >&
ResponseData::upgrades() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_;
}

// repeated .SC2APIProtocol.BuffData buffs = 4;
inline int ResponseData::_internal_buffs_size() const {
  return buffs_.size();
}
inline int ResponseData::buffs_size() const {
  return _internal_buffs_size();
}
inline ::SC2APIProtocol::BuffData* ResponseData::mutable_buffs(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.buffs)
  return buffs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::BuffData >*
ResponseData::mutable_buffs() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.buffs)
  return &buffs_;
}
inline const ::SC2APIProtocol::BuffData& ResponseData::_internal_buffs(int index) const {
  return buffs_.Get(index);
}
inline const ::SC2APIProtocol::BuffData& ResponseData::buffs(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.buffs)
  return _internal_buffs(index);
}
inline ::SC2APIProtocol::BuffData* ResponseData::_internal_add_buffs() {
  return buffs_.Add();
}
inline ::SC2APIProtocol::BuffData* ResponseData::add_buffs() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.buffs)
  return _internal_add_buffs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::BuffData >&
ResponseData::buffs() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.buffs)
  return buffs_;
}

// repeated .SC2APIProtocol.EffectData effects = 5;
inline int ResponseData::_internal_effects_size() const {
  return effects_.size();
}
inline int ResponseData::effects_size() const {
  return _internal_effects_size();
}
inline ::SC2APIProtocol::EffectData* ResponseData::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.effects)
  return effects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::EffectData >*
ResponseData::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.effects)
  return &effects_;
}
inline const ::SC2APIProtocol::EffectData& ResponseData::_internal_effects(int index) const {
  return effects_.Get(index);
}
inline const ::SC2APIProtocol::EffectData& ResponseData::effects(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.effects)
  return _internal_effects(index);
}
inline ::SC2APIProtocol::EffectData* ResponseData::_internal_add_effects() {
  return effects_.Add();
}
inline ::SC2APIProtocol::EffectData* ResponseData::add_effects() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.effects)
  return _internal_add_effects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::EffectData >&
ResponseData::effects() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.effects)
  return effects_;
}

// -------------------------------------------------------------------

// RequestSaveReplay

// -------------------------------------------------------------------

// ResponseSaveReplay

// optional bytes data = 1;
inline bool ResponseSaveReplay::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseSaveReplay::has_data() const {
  return _internal_has_data();
}
inline void ResponseSaveReplay::clear_data() {
  data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseSaveReplay::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseSaveReplay.data)
  return _internal_data();
}
inline void ResponseSaveReplay::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseSaveReplay.data)
}
inline std::string* ResponseSaveReplay::mutable_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseSaveReplay.data)
  return _internal_mutable_data();
}
inline const std::string& ResponseSaveReplay::_internal_data() const {
  return data_.GetNoArena();
}
inline void ResponseSaveReplay::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseSaveReplay::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseSaveReplay.data)
}
inline void ResponseSaveReplay::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseSaveReplay.data)
}
inline void ResponseSaveReplay::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseSaveReplay.data)
}
inline std::string* ResponseSaveReplay::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseSaveReplay::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseSaveReplay.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSaveReplay::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseSaveReplay.data)
}

// -------------------------------------------------------------------

// RequestReplayInfo

// optional string replay_path = 1;
inline bool RequestReplayInfo::_internal_has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline bool RequestReplayInfo::has_replay_path() const {
  return _internal_has_replay_path();
}
inline void RequestReplayInfo::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestReplayInfo::clear_replay_path() {
  if (_internal_has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const std::string& RequestReplayInfo::replay_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.replay_path)
  return _internal_replay_path();
}
inline void RequestReplayInfo::set_replay_path(const std::string& value) {
  _internal_set_replay_path(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline std::string* RequestReplayInfo::mutable_replay_path() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestReplayInfo.replay_path)
  return _internal_mutable_replay_path();
}
inline const std::string& RequestReplayInfo::_internal_replay_path() const {
  if (_internal_has_replay_path()) {
    return replay_.replay_path_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::_internal_set_replay_path(const std::string& value) {
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestReplayInfo::set_replay_path(std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline void RequestReplayInfo::set_replay_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline void RequestReplayInfo::set_replay_path(const char* value, size_t size) {
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline std::string* RequestReplayInfo::_internal_mutable_replay_path() {
  if (!_internal_has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return replay_.replay_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestReplayInfo::release_replay_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (_internal_has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RequestReplayInfo::set_allocated_replay_path(std::string* replay_path) {
  if (has_replay()) {
    clear_replay();
  }
  if (replay_path != nullptr) {
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestReplayInfo.replay_path)
}

// optional bytes replay_data = 2;
inline bool RequestReplayInfo::_internal_has_replay_data() const {
  return replay_case() == kReplayData;
}
inline bool RequestReplayInfo::has_replay_data() const {
  return _internal_has_replay_data();
}
inline void RequestReplayInfo::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestReplayInfo::clear_replay_data() {
  if (_internal_has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const std::string& RequestReplayInfo::replay_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.replay_data)
  return _internal_replay_data();
}
inline void RequestReplayInfo::set_replay_data(const std::string& value) {
  _internal_set_replay_data(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline std::string* RequestReplayInfo::mutable_replay_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestReplayInfo.replay_data)
  return _internal_mutable_replay_data();
}
inline const std::string& RequestReplayInfo::_internal_replay_data() const {
  if (_internal_has_replay_data()) {
    return replay_.replay_data_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::_internal_set_replay_data(const std::string& value) {
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestReplayInfo::set_replay_data(std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline void RequestReplayInfo::set_replay_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline void RequestReplayInfo::set_replay_data(const void* value, size_t size) {
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline std::string* RequestReplayInfo::_internal_mutable_replay_data() {
  if (!_internal_has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return replay_.replay_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestReplayInfo::release_replay_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (_internal_has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RequestReplayInfo::set_allocated_replay_data(std::string* replay_data) {
  if (has_replay()) {
    clear_replay();
  }
  if (replay_data != nullptr) {
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestReplayInfo.replay_data)
}

// optional bool download_data = 3;
inline bool RequestReplayInfo::_internal_has_download_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestReplayInfo::has_download_data() const {
  return _internal_has_download_data();
}
inline void RequestReplayInfo::clear_download_data() {
  download_data_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RequestReplayInfo::_internal_download_data() const {
  return download_data_;
}
inline bool RequestReplayInfo::download_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.download_data)
  return _internal_download_data();
}
inline void RequestReplayInfo::_internal_set_download_data(bool value) {
  _has_bits_[0] |= 0x00000001u;
  download_data_ = value;
}
inline void RequestReplayInfo::set_download_data(bool value) {
  _internal_set_download_data(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.download_data)
}

inline bool RequestReplayInfo::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestReplayInfo::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestReplayInfo::ReplayCase RequestReplayInfo::replay_case() const {
  return RequestReplayInfo::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerInfoExtra

// optional .SC2APIProtocol.PlayerInfo player_info = 1;
inline bool PlayerInfoExtra::_internal_has_player_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || player_info_ != nullptr);
  return value;
}
inline bool PlayerInfoExtra::has_player_info() const {
  return _internal_has_player_info();
}
inline void PlayerInfoExtra::clear_player_info() {
  if (player_info_ != nullptr) player_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::PlayerInfo& PlayerInfoExtra::_internal_player_info() const {
  const ::SC2APIProtocol::PlayerInfo* p = player_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::PlayerInfo*>(
      &::SC2APIProtocol::_PlayerInfo_default_instance_);
}
inline const ::SC2APIProtocol::PlayerInfo& PlayerInfoExtra::player_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_info)
  return _internal_player_info();
}
inline ::SC2APIProtocol::PlayerInfo* PlayerInfoExtra::release_player_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerInfoExtra.player_info)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PlayerInfo* temp = player_info_;
  player_info_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PlayerInfo* PlayerInfoExtra::_internal_mutable_player_info() {
  _has_bits_[0] |= 0x00000001u;
  if (player_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PlayerInfo>(GetArenaNoVirtual());
    player_info_ = p;
  }
  return player_info_;
}
inline ::SC2APIProtocol::PlayerInfo* PlayerInfoExtra::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerInfoExtra.player_info)
  return _internal_mutable_player_info();
}
inline void PlayerInfoExtra::set_allocated_player_info(::SC2APIProtocol::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete player_info_;
  }
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerInfoExtra.player_info)
}

// optional .SC2APIProtocol.PlayerResult player_result = 2;
inline bool PlayerInfoExtra::_internal_has_player_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || player_result_ != nullptr);
  return value;
}
inline bool PlayerInfoExtra::has_player_result() const {
  return _internal_has_player_result();
}
inline void PlayerInfoExtra::clear_player_result() {
  if (player_result_ != nullptr) player_result_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::PlayerResult& PlayerInfoExtra::_internal_player_result() const {
  const ::SC2APIProtocol::PlayerResult* p = player_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::PlayerResult*>(
      &::SC2APIProtocol::_PlayerResult_default_instance_);
}
inline const ::SC2APIProtocol::PlayerResult& PlayerInfoExtra::player_result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_result)
  return _internal_player_result();
}
inline ::SC2APIProtocol::PlayerResult* PlayerInfoExtra::release_player_result() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerInfoExtra.player_result)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::PlayerResult* temp = player_result_;
  player_result_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PlayerResult* PlayerInfoExtra::_internal_mutable_player_result() {
  _has_bits_[0] |= 0x00000002u;
  if (player_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PlayerResult>(GetArenaNoVirtual());
    player_result_ = p;
  }
  return player_result_;
}
inline ::SC2APIProtocol::PlayerResult* PlayerInfoExtra::mutable_player_result() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerInfoExtra.player_result)
  return _internal_mutable_player_result();
}
inline void PlayerInfoExtra::set_allocated_player_result(::SC2APIProtocol::PlayerResult* player_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete player_result_;
  }
  if (player_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  player_result_ = player_result;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerInfoExtra.player_result)
}

// optional int32 player_mmr = 3;
inline bool PlayerInfoExtra::_internal_has_player_mmr() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerInfoExtra::has_player_mmr() const {
  return _internal_has_player_mmr();
}
inline void PlayerInfoExtra::clear_player_mmr() {
  player_mmr_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfoExtra::_internal_player_mmr() const {
  return player_mmr_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfoExtra::player_mmr() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_mmr)
  return _internal_player_mmr();
}
inline void PlayerInfoExtra::_internal_set_player_mmr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  player_mmr_ = value;
}
inline void PlayerInfoExtra::set_player_mmr(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_player_mmr(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfoExtra.player_mmr)
}

// optional int32 player_apm = 4;
inline bool PlayerInfoExtra::_internal_has_player_apm() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerInfoExtra::has_player_apm() const {
  return _internal_has_player_apm();
}
inline void PlayerInfoExtra::clear_player_apm() {
  player_apm_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfoExtra::_internal_player_apm() const {
  return player_apm_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfoExtra::player_apm() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_apm)
  return _internal_player_apm();
}
inline void PlayerInfoExtra::_internal_set_player_apm(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  player_apm_ = value;
}
inline void PlayerInfoExtra::set_player_apm(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_player_apm(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfoExtra.player_apm)
}

// -------------------------------------------------------------------

// ResponseReplayInfo

// optional string map_name = 1;
inline bool ResponseReplayInfo::_internal_has_map_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_map_name() const {
  return _internal_has_map_name();
}
inline void ResponseReplayInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseReplayInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.map_name)
  return _internal_map_name();
}
inline void ResponseReplayInfo::set_map_name(const std::string& value) {
  _internal_set_map_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline std::string* ResponseReplayInfo::mutable_map_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.map_name)
  return _internal_mutable_map_name();
}
inline const std::string& ResponseReplayInfo::_internal_map_name() const {
  return map_name_.GetNoArena();
}
inline void ResponseReplayInfo::_internal_set_map_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseReplayInfo::set_map_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline void ResponseReplayInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline void ResponseReplayInfo::set_map_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  map_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline std::string* ResponseReplayInfo::_internal_mutable_map_name() {
  _has_bits_[0] |= 0x00000001u;
  return map_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseReplayInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.map_name)
  if (!_internal_has_map_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return map_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  map_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.map_name)
}

// optional string local_map_path = 2;
inline bool ResponseReplayInfo::_internal_has_local_map_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_local_map_path() const {
  return _internal_has_local_map_path();
}
inline void ResponseReplayInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponseReplayInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  return _internal_local_map_path();
}
inline void ResponseReplayInfo::set_local_map_path(const std::string& value) {
  _internal_set_local_map_path(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline std::string* ResponseReplayInfo::mutable_local_map_path() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  return _internal_mutable_local_map_path();
}
inline const std::string& ResponseReplayInfo::_internal_local_map_path() const {
  return local_map_path_.GetNoArena();
}
inline void ResponseReplayInfo::_internal_set_local_map_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseReplayInfo::set_local_map_path(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline void ResponseReplayInfo::set_local_map_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline void ResponseReplayInfo::set_local_map_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  local_map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline std::string* ResponseReplayInfo::_internal_mutable_local_map_path() {
  _has_bits_[0] |= 0x00000002u;
  return local_map_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseReplayInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  if (!_internal_has_local_map_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return local_map_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_local_map_path(std::string* local_map_path) {
  if (local_map_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  local_map_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}

// repeated .SC2APIProtocol.PlayerInfoExtra player_info = 3;
inline int ResponseReplayInfo::_internal_player_info_size() const {
  return player_info_.size();
}
inline int ResponseReplayInfo::player_info_size() const {
  return _internal_player_info_size();
}
inline void ResponseReplayInfo::clear_player_info() {
  player_info_.Clear();
}
inline ::SC2APIProtocol::PlayerInfoExtra* ResponseReplayInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >*
ResponseReplayInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseReplayInfo.player_info)
  return &player_info_;
}
inline const ::SC2APIProtocol::PlayerInfoExtra& ResponseReplayInfo::_internal_player_info(int index) const {
  return player_info_.Get(index);
}
inline const ::SC2APIProtocol::PlayerInfoExtra& ResponseReplayInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.player_info)
  return _internal_player_info(index);
}
inline ::SC2APIProtocol::PlayerInfoExtra* ResponseReplayInfo::_internal_add_player_info() {
  return player_info_.Add();
}
inline ::SC2APIProtocol::PlayerInfoExtra* ResponseReplayInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseReplayInfo.player_info)
  return _internal_add_player_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >&
ResponseReplayInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_;
}

// optional uint32 game_duration_loops = 4;
inline bool ResponseReplayInfo::_internal_has_game_duration_loops() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_game_duration_loops() const {
  return _internal_has_game_duration_loops();
}
inline void ResponseReplayInfo::clear_game_duration_loops() {
  game_duration_loops_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseReplayInfo::_internal_game_duration_loops() const {
  return game_duration_loops_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseReplayInfo::game_duration_loops() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_duration_loops)
  return _internal_game_duration_loops();
}
inline void ResponseReplayInfo::_internal_set_game_duration_loops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  game_duration_loops_ = value;
}
inline void ResponseReplayInfo::set_game_duration_loops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_game_duration_loops(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_duration_loops)
}

// optional float game_duration_seconds = 5;
inline bool ResponseReplayInfo::_internal_has_game_duration_seconds() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_game_duration_seconds() const {
  return _internal_has_game_duration_seconds();
}
inline void ResponseReplayInfo::clear_game_duration_seconds() {
  game_duration_seconds_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ResponseReplayInfo::_internal_game_duration_seconds() const {
  return game_duration_seconds_;
}
inline float ResponseReplayInfo::game_duration_seconds() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_duration_seconds)
  return _internal_game_duration_seconds();
}
inline void ResponseReplayInfo::_internal_set_game_duration_seconds(float value) {
  _has_bits_[0] |= 0x00000040u;
  game_duration_seconds_ = value;
}
inline void ResponseReplayInfo::set_game_duration_seconds(float value) {
  _internal_set_game_duration_seconds(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_duration_seconds)
}

// optional string game_version = 6;
inline bool ResponseReplayInfo::_internal_has_game_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_game_version() const {
  return _internal_has_game_version();
}
inline void ResponseReplayInfo::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ResponseReplayInfo::game_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_version)
  return _internal_game_version();
}
inline void ResponseReplayInfo::set_game_version(const std::string& value) {
  _internal_set_game_version(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline std::string* ResponseReplayInfo::mutable_game_version() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.game_version)
  return _internal_mutable_game_version();
}
inline const std::string& ResponseReplayInfo::_internal_game_version() const {
  return game_version_.GetNoArena();
}
inline void ResponseReplayInfo::_internal_set_game_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  game_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseReplayInfo::set_game_version(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  game_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline void ResponseReplayInfo::set_game_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  game_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline void ResponseReplayInfo::set_game_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  game_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline std::string* ResponseReplayInfo::_internal_mutable_game_version() {
  _has_bits_[0] |= 0x00000004u;
  return game_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseReplayInfo::release_game_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.game_version)
  if (!_internal_has_game_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return game_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_game_version(std::string* game_version) {
  if (game_version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  game_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.game_version)
}

// optional string data_version = 11;
inline bool ResponseReplayInfo::_internal_has_data_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_data_version() const {
  return _internal_has_data_version();
}
inline void ResponseReplayInfo::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ResponseReplayInfo::data_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.data_version)
  return _internal_data_version();
}
inline void ResponseReplayInfo::set_data_version(const std::string& value) {
  _internal_set_data_version(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline std::string* ResponseReplayInfo::mutable_data_version() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.data_version)
  return _internal_mutable_data_version();
}
inline const std::string& ResponseReplayInfo::_internal_data_version() const {
  return data_version_.GetNoArena();
}
inline void ResponseReplayInfo::_internal_set_data_version(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  data_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseReplayInfo::set_data_version(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  data_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline void ResponseReplayInfo::set_data_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  data_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline void ResponseReplayInfo::set_data_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  data_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline std::string* ResponseReplayInfo::_internal_mutable_data_version() {
  _has_bits_[0] |= 0x00000010u;
  return data_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseReplayInfo::release_data_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.data_version)
  if (!_internal_has_data_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return data_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_data_version(std::string* data_version) {
  if (data_version != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  data_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.data_version)
}

// optional uint32 data_build = 7;
inline bool ResponseReplayInfo::_internal_has_data_build() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_data_build() const {
  return _internal_has_data_build();
}
inline void ResponseReplayInfo::clear_data_build() {
  data_build_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseReplayInfo::_internal_data_build() const {
  return data_build_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseReplayInfo::data_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.data_build)
  return _internal_data_build();
}
inline void ResponseReplayInfo::_internal_set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  data_build_ = value;
}
inline void ResponseReplayInfo::set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_data_build(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.data_build)
}

// optional uint32 base_build = 8;
inline bool ResponseReplayInfo::_internal_has_base_build() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_base_build() const {
  return _internal_has_base_build();
}
inline void ResponseReplayInfo::clear_base_build() {
  base_build_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseReplayInfo::_internal_base_build() const {
  return base_build_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponseReplayInfo::base_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.base_build)
  return _internal_base_build();
}
inline void ResponseReplayInfo::_internal_set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  base_build_ = value;
}
inline void ResponseReplayInfo::set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_base_build(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.base_build)
}

// optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;
inline bool ResponseReplayInfo::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_error() const {
  return _internal_has_error();
}
inline void ResponseReplayInfo::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::SC2APIProtocol::ResponseReplayInfo_Error ResponseReplayInfo::_internal_error() const {
  return static_cast< ::SC2APIProtocol::ResponseReplayInfo_Error >(error_);
}
inline ::SC2APIProtocol::ResponseReplayInfo_Error ResponseReplayInfo::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.error)
  return _internal_error();
}
inline void ResponseReplayInfo::_internal_set_error(::SC2APIProtocol::ResponseReplayInfo_Error value) {
  assert(::SC2APIProtocol::ResponseReplayInfo_Error_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  error_ = value;
}
inline void ResponseReplayInfo::set_error(::SC2APIProtocol::ResponseReplayInfo_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.error)
}

// optional string error_details = 10;
inline bool ResponseReplayInfo::_internal_has_error_details() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResponseReplayInfo::has_error_details() const {
  return _internal_has_error_details();
}
inline void ResponseReplayInfo::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ResponseReplayInfo::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.error_details)
  return _internal_error_details();
}
inline void ResponseReplayInfo::set_error_details(const std::string& value) {
  _internal_set_error_details(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline std::string* ResponseReplayInfo::mutable_error_details() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.error_details)
  return _internal_mutable_error_details();
}
inline const std::string& ResponseReplayInfo::_internal_error_details() const {
  return error_details_.GetNoArena();
}
inline void ResponseReplayInfo::_internal_set_error_details(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponseReplayInfo::set_error_details(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  error_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline void ResponseReplayInfo::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline void ResponseReplayInfo::set_error_details(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline std::string* ResponseReplayInfo::_internal_mutable_error_details() {
  _has_bits_[0] |= 0x00000008u;
  return error_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponseReplayInfo::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.error_details)
  if (!_internal_has_error_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return error_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_error_details(std::string* error_details) {
  if (error_details != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  error_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.error_details)
}

// -------------------------------------------------------------------

// RequestAvailableMaps

// -------------------------------------------------------------------

// ResponseAvailableMaps

// repeated string local_map_paths = 1;
inline int ResponseAvailableMaps::_internal_local_map_paths_size() const {
  return local_map_paths_.size();
}
inline int ResponseAvailableMaps::local_map_paths_size() const {
  return _internal_local_map_paths_size();
}
inline void ResponseAvailableMaps::clear_local_map_paths() {
  local_map_paths_.Clear();
}
inline std::string* ResponseAvailableMaps::add_local_map_paths() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return _internal_add_local_map_paths();
}
inline const std::string& ResponseAvailableMaps::_internal_local_map_paths(int index) const {
  return local_map_paths_.Get(index);
}
inline const std::string& ResponseAvailableMaps::local_map_paths(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return _internal_local_map_paths(index);
}
inline std::string* ResponseAvailableMaps::mutable_local_map_paths(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Mutable(index);
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  local_map_paths_.Mutable(index)->assign(value);
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  local_map_paths_.Mutable(index)->assign(std::move(value));
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  local_map_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value, size_t size) {
  local_map_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline std::string* ResponseAvailableMaps::_internal_add_local_map_paths() {
  return local_map_paths_.Add();
}
inline void ResponseAvailableMaps::add_local_map_paths(const std::string& value) {
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::add_local_map_paths(std::string&& value) {
  local_map_paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::add_local_map_paths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::add_local_map_paths(const char* value, size_t size) {
  local_map_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponseAvailableMaps::local_map_paths() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResponseAvailableMaps::mutable_local_map_paths() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return &local_map_paths_;
}

// repeated string battlenet_map_names = 2;
inline int ResponseAvailableMaps::_internal_battlenet_map_names_size() const {
  return battlenet_map_names_.size();
}
inline int ResponseAvailableMaps::battlenet_map_names_size() const {
  return _internal_battlenet_map_names_size();
}
inline void ResponseAvailableMaps::clear_battlenet_map_names() {
  battlenet_map_names_.Clear();
}
inline std::string* ResponseAvailableMaps::add_battlenet_map_names() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return _internal_add_battlenet_map_names();
}
inline const std::string& ResponseAvailableMaps::_internal_battlenet_map_names(int index) const {
  return battlenet_map_names_.Get(index);
}
inline const std::string& ResponseAvailableMaps::battlenet_map_names(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return _internal_battlenet_map_names(index);
}
inline std::string* ResponseAvailableMaps::mutable_battlenet_map_names(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Mutable(index);
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  battlenet_map_names_.Mutable(index)->assign(value);
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  battlenet_map_names_.Mutable(index)->assign(std::move(value));
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  battlenet_map_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value, size_t size) {
  battlenet_map_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline std::string* ResponseAvailableMaps::_internal_add_battlenet_map_names() {
  return battlenet_map_names_.Add();
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const std::string& value) {
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::add_battlenet_map_names(std::string&& value) {
  battlenet_map_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value, size_t size) {
  battlenet_map_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponseAvailableMaps::battlenet_map_names() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResponseAvailableMaps::mutable_battlenet_map_names() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return &battlenet_map_names_;
}

// -------------------------------------------------------------------

// RequestSaveMap

// optional string map_path = 1;
inline bool RequestSaveMap::_internal_has_map_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RequestSaveMap::has_map_path() const {
  return _internal_has_map_path();
}
inline void RequestSaveMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RequestSaveMap::map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestSaveMap.map_path)
  return _internal_map_path();
}
inline void RequestSaveMap::set_map_path(const std::string& value) {
  _internal_set_map_path(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestSaveMap.map_path)
}
inline std::string* RequestSaveMap::mutable_map_path() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestSaveMap.map_path)
  return _internal_mutable_map_path();
}
inline const std::string& RequestSaveMap::_internal_map_path() const {
  return map_path_.GetNoArena();
}
inline void RequestSaveMap::_internal_set_map_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestSaveMap::set_map_path(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestSaveMap.map_path)
}
inline void RequestSaveMap::set_map_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestSaveMap.map_path)
}
inline void RequestSaveMap::set_map_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  map_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestSaveMap.map_path)
}
inline std::string* RequestSaveMap::_internal_mutable_map_path() {
  _has_bits_[0] |= 0x00000001u;
  return map_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestSaveMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestSaveMap.map_path)
  if (!_internal_has_map_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return map_path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_path(std::string* map_path) {
  if (map_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  map_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestSaveMap.map_path)
}

// optional bytes map_data = 2;
inline bool RequestSaveMap::_internal_has_map_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RequestSaveMap::has_map_data() const {
  return _internal_has_map_data();
}
inline void RequestSaveMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RequestSaveMap::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestSaveMap.map_data)
  return _internal_map_data();
}
inline void RequestSaveMap::set_map_data(const std::string& value) {
  _internal_set_map_data(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestSaveMap.map_data)
}
inline std::string* RequestSaveMap::mutable_map_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestSaveMap.map_data)
  return _internal_mutable_map_data();
}
inline const std::string& RequestSaveMap::_internal_map_data() const {
  return map_data_.GetNoArena();
}
inline void RequestSaveMap::_internal_set_map_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RequestSaveMap::set_map_data(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestSaveMap.map_data)
}
inline void RequestSaveMap::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestSaveMap.map_data)
}
inline void RequestSaveMap::set_map_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  map_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestSaveMap.map_data)
}
inline std::string* RequestSaveMap::_internal_mutable_map_data() {
  _has_bits_[0] |= 0x00000002u;
  return map_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RequestSaveMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestSaveMap.map_data)
  if (!_internal_has_map_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return map_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_data(std::string* map_data) {
  if (map_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  map_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestSaveMap.map_data)
}

// -------------------------------------------------------------------

// ResponseSaveMap

// optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;
inline bool ResponseSaveMap::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseSaveMap::has_error() const {
  return _internal_has_error();
}
inline void ResponseSaveMap::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::SC2APIProtocol::ResponseSaveMap_Error ResponseSaveMap::_internal_error() const {
  return static_cast< ::SC2APIProtocol::ResponseSaveMap_Error >(error_);
}
inline ::SC2APIProtocol::ResponseSaveMap_Error ResponseSaveMap::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseSaveMap.error)
  return _internal_error();
}
inline void ResponseSaveMap::_internal_set_error(::SC2APIProtocol::ResponseSaveMap_Error value) {
  assert(::SC2APIProtocol::ResponseSaveMap_Error_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  error_ = value;
}
inline void ResponseSaveMap::set_error(::SC2APIProtocol::ResponseSaveMap_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseSaveMap.error)
}

// -------------------------------------------------------------------

// RequestPing

// -------------------------------------------------------------------

// ResponsePing

// optional string game_version = 1;
inline bool ResponsePing::_internal_has_game_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponsePing::has_game_version() const {
  return _internal_has_game_version();
}
inline void ResponsePing::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponsePing::game_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.game_version)
  return _internal_game_version();
}
inline void ResponsePing::set_game_version(const std::string& value) {
  _internal_set_game_version(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.game_version)
}
inline std::string* ResponsePing::mutable_game_version() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponsePing.game_version)
  return _internal_mutable_game_version();
}
inline const std::string& ResponsePing::_internal_game_version() const {
  return game_version_.GetNoArena();
}
inline void ResponsePing::_internal_set_game_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponsePing::set_game_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  game_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponsePing.game_version)
}
inline void ResponsePing::set_game_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  game_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponsePing.game_version)
}
inline void ResponsePing::set_game_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  game_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponsePing.game_version)
}
inline std::string* ResponsePing::_internal_mutable_game_version() {
  _has_bits_[0] |= 0x00000001u;
  return game_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponsePing::release_game_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponsePing.game_version)
  if (!_internal_has_game_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return game_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_game_version(std::string* game_version) {
  if (game_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponsePing.game_version)
}

// optional string data_version = 2;
inline bool ResponsePing::_internal_has_data_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResponsePing::has_data_version() const {
  return _internal_has_data_version();
}
inline void ResponsePing::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResponsePing::data_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.data_version)
  return _internal_data_version();
}
inline void ResponsePing::set_data_version(const std::string& value) {
  _internal_set_data_version(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.data_version)
}
inline std::string* ResponsePing::mutable_data_version() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponsePing.data_version)
  return _internal_mutable_data_version();
}
inline const std::string& ResponsePing::_internal_data_version() const {
  return data_version_.GetNoArena();
}
inline void ResponsePing::_internal_set_data_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ResponsePing::set_data_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponsePing.data_version)
}
inline void ResponsePing::set_data_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponsePing.data_version)
}
inline void ResponsePing::set_data_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponsePing.data_version)
}
inline std::string* ResponsePing::_internal_mutable_data_version() {
  _has_bits_[0] |= 0x00000002u;
  return data_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResponsePing::release_data_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponsePing.data_version)
  if (!_internal_has_data_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_data_version(std::string* data_version) {
  if (data_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponsePing.data_version)
}

// optional uint32 data_build = 3;
inline bool ResponsePing::_internal_has_data_build() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResponsePing::has_data_build() const {
  return _internal_has_data_build();
}
inline void ResponsePing::clear_data_build() {
  data_build_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponsePing::_internal_data_build() const {
  return data_build_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponsePing::data_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.data_build)
  return _internal_data_build();
}
inline void ResponsePing::_internal_set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  data_build_ = value;
}
inline void ResponsePing::set_data_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_data_build(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.data_build)
}

// optional uint32 base_build = 4;
inline bool ResponsePing::_internal_has_base_build() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResponsePing::has_base_build() const {
  return _internal_has_base_build();
}
inline void ResponsePing::clear_base_build() {
  base_build_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponsePing::_internal_base_build() const {
  return base_build_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResponsePing::base_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.base_build)
  return _internal_base_build();
}
inline void ResponsePing::_internal_set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  base_build_ = value;
}
inline void ResponsePing::set_base_build(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_base_build(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.base_build)
}

// -------------------------------------------------------------------

// RequestDebug

// repeated .SC2APIProtocol.DebugCommand debug = 1;
inline int RequestDebug::_internal_debug_size() const {
  return debug_.size();
}
inline int RequestDebug::debug_size() const {
  return _internal_debug_size();
}
inline ::SC2APIProtocol::DebugCommand* RequestDebug::mutable_debug(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestDebug.debug)
  return debug_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >*
RequestDebug::mutable_debug() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestDebug.debug)
  return &debug_;
}
inline const ::SC2APIProtocol::DebugCommand& RequestDebug::_internal_debug(int index) const {
  return debug_.Get(index);
}
inline const ::SC2APIProtocol::DebugCommand& RequestDebug::debug(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestDebug.debug)
  return _internal_debug(index);
}
inline ::SC2APIProtocol::DebugCommand* RequestDebug::_internal_add_debug() {
  return debug_.Add();
}
inline ::SC2APIProtocol::DebugCommand* RequestDebug::add_debug() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestDebug.debug)
  return _internal_add_debug();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >&
RequestDebug::debug() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestDebug.debug)
  return debug_;
}

// -------------------------------------------------------------------

// ResponseDebug

// -------------------------------------------------------------------

// PlayerSetup

// optional .SC2APIProtocol.PlayerType type = 1;
inline bool PlayerSetup::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerSetup::has_type() const {
  return _internal_has_type();
}
inline void PlayerSetup::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::SC2APIProtocol::PlayerType PlayerSetup::_internal_type() const {
  return static_cast< ::SC2APIProtocol::PlayerType >(type_);
}
inline ::SC2APIProtocol::PlayerType PlayerSetup::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.type)
  return _internal_type();
}
inline void PlayerSetup::_internal_set_type(::SC2APIProtocol::PlayerType value) {
  assert(::SC2APIProtocol::PlayerType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void PlayerSetup::set_type(::SC2APIProtocol::PlayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.type)
}

// optional .SC2APIProtocol.Race race = 2;
inline bool PlayerSetup::_internal_has_race() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerSetup::has_race() const {
  return _internal_has_race();
}
inline void PlayerSetup::clear_race() {
  race_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::Race PlayerSetup::_internal_race() const {
  return static_cast< ::SC2APIProtocol::Race >(race_);
}
inline ::SC2APIProtocol::Race PlayerSetup::race() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.race)
  return _internal_race();
}
inline void PlayerSetup::_internal_set_race(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  race_ = value;
}
inline void PlayerSetup::set_race(::SC2APIProtocol::Race value) {
  _internal_set_race(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.race)
}

// optional .SC2APIProtocol.Difficulty difficulty = 3;
inline bool PlayerSetup::_internal_has_difficulty() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerSetup::has_difficulty() const {
  return _internal_has_difficulty();
}
inline void PlayerSetup::clear_difficulty() {
  difficulty_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::SC2APIProtocol::Difficulty PlayerSetup::_internal_difficulty() const {
  return static_cast< ::SC2APIProtocol::Difficulty >(difficulty_);
}
inline ::SC2APIProtocol::Difficulty PlayerSetup::difficulty() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.difficulty)
  return _internal_difficulty();
}
inline void PlayerSetup::_internal_set_difficulty(::SC2APIProtocol::Difficulty value) {
  assert(::SC2APIProtocol::Difficulty_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  difficulty_ = value;
}
inline void PlayerSetup::set_difficulty(::SC2APIProtocol::Difficulty value) {
  _internal_set_difficulty(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.difficulty)
}

// optional string player_name = 4;
inline bool PlayerSetup::_internal_has_player_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerSetup::has_player_name() const {
  return _internal_has_player_name();
}
inline void PlayerSetup::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerSetup::player_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.player_name)
  return _internal_player_name();
}
inline void PlayerSetup::set_player_name(const std::string& value) {
  _internal_set_player_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.player_name)
}
inline std::string* PlayerSetup::mutable_player_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerSetup.player_name)
  return _internal_mutable_player_name();
}
inline const std::string& PlayerSetup::_internal_player_name() const {
  return player_name_.GetNoArena();
}
inline void PlayerSetup::_internal_set_player_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PlayerSetup::set_player_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.PlayerSetup.player_name)
}
inline void PlayerSetup::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.PlayerSetup.player_name)
}
inline void PlayerSetup::set_player_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.PlayerSetup.player_name)
}
inline std::string* PlayerSetup::_internal_mutable_player_name() {
  _has_bits_[0] |= 0x00000001u;
  return player_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PlayerSetup::release_player_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerSetup.player_name)
  if (!_internal_has_player_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerSetup::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerSetup.player_name)
}

// optional .SC2APIProtocol.AIBuild ai_build = 5;
inline bool PlayerSetup::_internal_has_ai_build() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerSetup::has_ai_build() const {
  return _internal_has_ai_build();
}
inline void PlayerSetup::clear_ai_build() {
  ai_build_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SC2APIProtocol::AIBuild PlayerSetup::_internal_ai_build() const {
  return static_cast< ::SC2APIProtocol::AIBuild >(ai_build_);
}
inline ::SC2APIProtocol::AIBuild PlayerSetup::ai_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.ai_build)
  return _internal_ai_build();
}
inline void PlayerSetup::_internal_set_ai_build(::SC2APIProtocol::AIBuild value) {
  assert(::SC2APIProtocol::AIBuild_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ai_build_ = value;
}
inline void PlayerSetup::set_ai_build(::SC2APIProtocol::AIBuild value) {
  _internal_set_ai_build(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.ai_build)
}

// -------------------------------------------------------------------

// SpatialCameraSetup

// optional .SC2APIProtocol.Size2DI resolution = 2;
inline bool SpatialCameraSetup::_internal_has_resolution() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || resolution_ != nullptr);
  return value;
}
inline bool SpatialCameraSetup::has_resolution() const {
  return _internal_has_resolution();
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::_internal_resolution() const {
  const ::SC2APIProtocol::Size2DI* p = resolution_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Size2DI*>(
      &::SC2APIProtocol::_Size2DI_default_instance_);
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::resolution() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.resolution)
  return _internal_resolution();
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::release_resolution() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.SpatialCameraSetup.resolution)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Size2DI* temp = resolution_;
  resolution_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::_internal_mutable_resolution() {
  _has_bits_[0] |= 0x00000001u;
  if (resolution_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Size2DI>(GetArenaNoVirtual());
    resolution_ = p;
  }
  return resolution_;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::mutable_resolution() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.SpatialCameraSetup.resolution)
  return _internal_mutable_resolution();
}
inline void SpatialCameraSetup::set_allocated_resolution(::SC2APIProtocol::Size2DI* resolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolution_);
  }
  if (resolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      resolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolution, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resolution_ = resolution;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.SpatialCameraSetup.resolution)
}

// optional .SC2APIProtocol.Size2DI minimap_resolution = 3;
inline bool SpatialCameraSetup::_internal_has_minimap_resolution() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || minimap_resolution_ != nullptr);
  return value;
}
inline bool SpatialCameraSetup::has_minimap_resolution() const {
  return _internal_has_minimap_resolution();
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::_internal_minimap_resolution() const {
  const ::SC2APIProtocol::Size2DI* p = minimap_resolution_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Size2DI*>(
      &::SC2APIProtocol::_Size2DI_default_instance_);
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::minimap_resolution() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  return _internal_minimap_resolution();
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::release_minimap_resolution() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Size2DI* temp = minimap_resolution_;
  minimap_resolution_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::_internal_mutable_minimap_resolution() {
  _has_bits_[0] |= 0x00000002u;
  if (minimap_resolution_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Size2DI>(GetArenaNoVirtual());
    minimap_resolution_ = p;
  }
  return minimap_resolution_;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::mutable_minimap_resolution() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  return _internal_mutable_minimap_resolution();
}
inline void SpatialCameraSetup::set_allocated_minimap_resolution(::SC2APIProtocol::Size2DI* minimap_resolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimap_resolution_);
  }
  if (minimap_resolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      minimap_resolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimap_resolution, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  minimap_resolution_ = minimap_resolution;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
}

// optional float width = 1;
inline bool SpatialCameraSetup::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SpatialCameraSetup::has_width() const {
  return _internal_has_width();
}
inline void SpatialCameraSetup::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SpatialCameraSetup::_internal_width() const {
  return width_;
}
inline float SpatialCameraSetup::width() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.width)
  return _internal_width();
}
inline void SpatialCameraSetup::_internal_set_width(float value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void SpatialCameraSetup::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.SpatialCameraSetup.width)
}

// optional bool crop_to_playable_area = 4;
inline bool SpatialCameraSetup::_internal_has_crop_to_playable_area() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SpatialCameraSetup::has_crop_to_playable_area() const {
  return _internal_has_crop_to_playable_area();
}
inline void SpatialCameraSetup::clear_crop_to_playable_area() {
  crop_to_playable_area_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool SpatialCameraSetup::_internal_crop_to_playable_area() const {
  return crop_to_playable_area_;
}
inline bool SpatialCameraSetup::crop_to_playable_area() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.crop_to_playable_area)
  return _internal_crop_to_playable_area();
}
inline void SpatialCameraSetup::_internal_set_crop_to_playable_area(bool value) {
  _has_bits_[0] |= 0x00000008u;
  crop_to_playable_area_ = value;
}
inline void SpatialCameraSetup::set_crop_to_playable_area(bool value) {
  _internal_set_crop_to_playable_area(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.SpatialCameraSetup.crop_to_playable_area)
}

// optional bool allow_cheating_layers = 5;
inline bool SpatialCameraSetup::_internal_has_allow_cheating_layers() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SpatialCameraSetup::has_allow_cheating_layers() const {
  return _internal_has_allow_cheating_layers();
}
inline void SpatialCameraSetup::clear_allow_cheating_layers() {
  allow_cheating_layers_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool SpatialCameraSetup::_internal_allow_cheating_layers() const {
  return allow_cheating_layers_;
}
inline bool SpatialCameraSetup::allow_cheating_layers() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.allow_cheating_layers)
  return _internal_allow_cheating_layers();
}
inline void SpatialCameraSetup::_internal_set_allow_cheating_layers(bool value) {
  _has_bits_[0] |= 0x00000010u;
  allow_cheating_layers_ = value;
}
inline void SpatialCameraSetup::set_allow_cheating_layers(bool value) {
  _internal_set_allow_cheating_layers(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.SpatialCameraSetup.allow_cheating_layers)
}

// -------------------------------------------------------------------

// InterfaceOptions

// optional bool raw = 1;
inline bool InterfaceOptions::_internal_has_raw() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InterfaceOptions::has_raw() const {
  return _internal_has_raw();
}
inline void InterfaceOptions::clear_raw() {
  raw_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool InterfaceOptions::_internal_raw() const {
  return raw_;
}
inline bool InterfaceOptions::raw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.raw)
  return _internal_raw();
}
inline void InterfaceOptions::_internal_set_raw(bool value) {
  _has_bits_[0] |= 0x00000004u;
  raw_ = value;
}
inline void InterfaceOptions::set_raw(bool value) {
  _internal_set_raw(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.raw)
}

// optional bool score = 2;
inline bool InterfaceOptions::_internal_has_score() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InterfaceOptions::has_score() const {
  return _internal_has_score();
}
inline void InterfaceOptions::clear_score() {
  score_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool InterfaceOptions::_internal_score() const {
  return score_;
}
inline bool InterfaceOptions::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.score)
  return _internal_score();
}
inline void InterfaceOptions::_internal_set_score(bool value) {
  _has_bits_[0] |= 0x00000008u;
  score_ = value;
}
inline void InterfaceOptions::set_score(bool value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.score)
}

// optional .SC2APIProtocol.SpatialCameraSetup feature_layer = 3;
inline bool InterfaceOptions::_internal_has_feature_layer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || feature_layer_ != nullptr);
  return value;
}
inline bool InterfaceOptions::has_feature_layer() const {
  return _internal_has_feature_layer();
}
inline void InterfaceOptions::clear_feature_layer() {
  if (feature_layer_ != nullptr) feature_layer_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::_internal_feature_layer() const {
  const ::SC2APIProtocol::SpatialCameraSetup* p = feature_layer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::SpatialCameraSetup*>(
      &::SC2APIProtocol::_SpatialCameraSetup_default_instance_);
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::feature_layer() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.feature_layer)
  return _internal_feature_layer();
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::release_feature_layer() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.InterfaceOptions.feature_layer)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::SpatialCameraSetup* temp = feature_layer_;
  feature_layer_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::_internal_mutable_feature_layer() {
  _has_bits_[0] |= 0x00000001u;
  if (feature_layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::SpatialCameraSetup>(GetArenaNoVirtual());
    feature_layer_ = p;
  }
  return feature_layer_;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_feature_layer() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.InterfaceOptions.feature_layer)
  return _internal_mutable_feature_layer();
}
inline void InterfaceOptions::set_allocated_feature_layer(::SC2APIProtocol::SpatialCameraSetup* feature_layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete feature_layer_;
  }
  if (feature_layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      feature_layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_layer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  feature_layer_ = feature_layer;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.InterfaceOptions.feature_layer)
}

// optional .SC2APIProtocol.SpatialCameraSetup render = 4;
inline bool InterfaceOptions::_internal_has_render() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || render_ != nullptr);
  return value;
}
inline bool InterfaceOptions::has_render() const {
  return _internal_has_render();
}
inline void InterfaceOptions::clear_render() {
  if (render_ != nullptr) render_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::_internal_render() const {
  const ::SC2APIProtocol::SpatialCameraSetup* p = render_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::SpatialCameraSetup*>(
      &::SC2APIProtocol::_SpatialCameraSetup_default_instance_);
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::render() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.render)
  return _internal_render();
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::release_render() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.InterfaceOptions.render)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::SpatialCameraSetup* temp = render_;
  render_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::_internal_mutable_render() {
  _has_bits_[0] |= 0x00000002u;
  if (render_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::SpatialCameraSetup>(GetArenaNoVirtual());
    render_ = p;
  }
  return render_;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_render() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.InterfaceOptions.render)
  return _internal_mutable_render();
}
inline void InterfaceOptions::set_allocated_render(::SC2APIProtocol::SpatialCameraSetup* render) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete render_;
  }
  if (render) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      render = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, render, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  render_ = render;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.InterfaceOptions.render)
}

// optional bool show_cloaked = 5;
inline bool InterfaceOptions::_internal_has_show_cloaked() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InterfaceOptions::has_show_cloaked() const {
  return _internal_has_show_cloaked();
}
inline void InterfaceOptions::clear_show_cloaked() {
  show_cloaked_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool InterfaceOptions::_internal_show_cloaked() const {
  return show_cloaked_;
}
inline bool InterfaceOptions::show_cloaked() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.show_cloaked)
  return _internal_show_cloaked();
}
inline void InterfaceOptions::_internal_set_show_cloaked(bool value) {
  _has_bits_[0] |= 0x00000010u;
  show_cloaked_ = value;
}
inline void InterfaceOptions::set_show_cloaked(bool value) {
  _internal_set_show_cloaked(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.show_cloaked)
}

// optional bool show_burrowed_shadows = 9;
inline bool InterfaceOptions::_internal_has_show_burrowed_shadows() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InterfaceOptions::has_show_burrowed_shadows() const {
  return _internal_has_show_burrowed_shadows();
}
inline void InterfaceOptions::clear_show_burrowed_shadows() {
  show_burrowed_shadows_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool InterfaceOptions::_internal_show_burrowed_shadows() const {
  return show_burrowed_shadows_;
}
inline bool InterfaceOptions::show_burrowed_shadows() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.show_burrowed_shadows)
  return _internal_show_burrowed_shadows();
}
inline void InterfaceOptions::_internal_set_show_burrowed_shadows(bool value) {
  _has_bits_[0] |= 0x00000020u;
  show_burrowed_shadows_ = value;
}
inline void InterfaceOptions::set_show_burrowed_shadows(bool value) {
  _internal_set_show_burrowed_shadows(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.show_burrowed_shadows)
}

// optional bool show_placeholders = 8;
inline bool InterfaceOptions::_internal_has_show_placeholders() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InterfaceOptions::has_show_placeholders() const {
  return _internal_has_show_placeholders();
}
inline void InterfaceOptions::clear_show_placeholders() {
  show_placeholders_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool InterfaceOptions::_internal_show_placeholders() const {
  return show_placeholders_;
}
inline bool InterfaceOptions::show_placeholders() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.show_placeholders)
  return _internal_show_placeholders();
}
inline void InterfaceOptions::_internal_set_show_placeholders(bool value) {
  _has_bits_[0] |= 0x00000040u;
  show_placeholders_ = value;
}
inline void InterfaceOptions::set_show_placeholders(bool value) {
  _internal_set_show_placeholders(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.show_placeholders)
}

// optional bool raw_affects_selection = 6;
inline bool InterfaceOptions::_internal_has_raw_affects_selection() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InterfaceOptions::has_raw_affects_selection() const {
  return _internal_has_raw_affects_selection();
}
inline void InterfaceOptions::clear_raw_affects_selection() {
  raw_affects_selection_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool InterfaceOptions::_internal_raw_affects_selection() const {
  return raw_affects_selection_;
}
inline bool InterfaceOptions::raw_affects_selection() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.raw_affects_selection)
  return _internal_raw_affects_selection();
}
inline void InterfaceOptions::_internal_set_raw_affects_selection(bool value) {
  _has_bits_[0] |= 0x00000080u;
  raw_affects_selection_ = value;
}
inline void InterfaceOptions::set_raw_affects_selection(bool value) {
  _internal_set_raw_affects_selection(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.raw_affects_selection)
}

// optional bool raw_crop_to_playable_area = 7;
inline bool InterfaceOptions::_internal_has_raw_crop_to_playable_area() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InterfaceOptions::has_raw_crop_to_playable_area() const {
  return _internal_has_raw_crop_to_playable_area();
}
inline void InterfaceOptions::clear_raw_crop_to_playable_area() {
  raw_crop_to_playable_area_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool InterfaceOptions::_internal_raw_crop_to_playable_area() const {
  return raw_crop_to_playable_area_;
}
inline bool InterfaceOptions::raw_crop_to_playable_area() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.raw_crop_to_playable_area)
  return _internal_raw_crop_to_playable_area();
}
inline void InterfaceOptions::_internal_set_raw_crop_to_playable_area(bool value) {
  _has_bits_[0] |= 0x00000100u;
  raw_crop_to_playable_area_ = value;
}
inline void InterfaceOptions::set_raw_crop_to_playable_area(bool value) {
  _internal_set_raw_crop_to_playable_area(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.raw_crop_to_playable_area)
}

// -------------------------------------------------------------------

// PlayerInfo

// optional uint32 player_id = 1;
inline bool PlayerInfo::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerInfo::has_player_id() const {
  return _internal_has_player_id();
}
inline void PlayerInfo::clear_player_id() {
  player_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerInfo::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerInfo::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.player_id)
  return _internal_player_id();
}
inline void PlayerInfo::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  player_id_ = value;
}
inline void PlayerInfo::set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.player_id)
}

// optional .SC2APIProtocol.PlayerType type = 2;
inline bool PlayerInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlayerInfo::has_type() const {
  return _internal_has_type();
}
inline void PlayerInfo::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::SC2APIProtocol::PlayerType PlayerInfo::_internal_type() const {
  return static_cast< ::SC2APIProtocol::PlayerType >(type_);
}
inline ::SC2APIProtocol::PlayerType PlayerInfo::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.type)
  return _internal_type();
}
inline void PlayerInfo::_internal_set_type(::SC2APIProtocol::PlayerType value) {
  assert(::SC2APIProtocol::PlayerType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void PlayerInfo::set_type(::SC2APIProtocol::PlayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.type)
}

// optional .SC2APIProtocol.Race race_requested = 3;
inline bool PlayerInfo::_internal_has_race_requested() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerInfo::has_race_requested() const {
  return _internal_has_race_requested();
}
inline void PlayerInfo::clear_race_requested() {
  race_requested_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SC2APIProtocol::Race PlayerInfo::_internal_race_requested() const {
  return static_cast< ::SC2APIProtocol::Race >(race_requested_);
}
inline ::SC2APIProtocol::Race PlayerInfo::race_requested() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.race_requested)
  return _internal_race_requested();
}
inline void PlayerInfo::_internal_set_race_requested(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  race_requested_ = value;
}
inline void PlayerInfo::set_race_requested(::SC2APIProtocol::Race value) {
  _internal_set_race_requested(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.race_requested)
}

// optional .SC2APIProtocol.Race race_actual = 4;
inline bool PlayerInfo::_internal_has_race_actual() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerInfo::has_race_actual() const {
  return _internal_has_race_actual();
}
inline void PlayerInfo::clear_race_actual() {
  race_actual_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::SC2APIProtocol::Race PlayerInfo::_internal_race_actual() const {
  return static_cast< ::SC2APIProtocol::Race >(race_actual_);
}
inline ::SC2APIProtocol::Race PlayerInfo::race_actual() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.race_actual)
  return _internal_race_actual();
}
inline void PlayerInfo::_internal_set_race_actual(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  race_actual_ = value;
}
inline void PlayerInfo::set_race_actual(::SC2APIProtocol::Race value) {
  _internal_set_race_actual(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.race_actual)
}

// optional .SC2APIProtocol.Difficulty difficulty = 5;
inline bool PlayerInfo::_internal_has_difficulty() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlayerInfo::has_difficulty() const {
  return _internal_has_difficulty();
}
inline void PlayerInfo::clear_difficulty() {
  difficulty_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::SC2APIProtocol::Difficulty PlayerInfo::_internal_difficulty() const {
  return static_cast< ::SC2APIProtocol::Difficulty >(difficulty_);
}
inline ::SC2APIProtocol::Difficulty PlayerInfo::difficulty() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.difficulty)
  return _internal_difficulty();
}
inline void PlayerInfo::_internal_set_difficulty(::SC2APIProtocol::Difficulty value) {
  assert(::SC2APIProtocol::Difficulty_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  difficulty_ = value;
}
inline void PlayerInfo::set_difficulty(::SC2APIProtocol::Difficulty value) {
  _internal_set_difficulty(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.difficulty)
}

// optional .SC2APIProtocol.AIBuild ai_build = 7;
inline bool PlayerInfo::_internal_has_ai_build() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerInfo::has_ai_build() const {
  return _internal_has_ai_build();
}
inline void PlayerInfo::clear_ai_build() {
  ai_build_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::SC2APIProtocol::AIBuild PlayerInfo::_internal_ai_build() const {
  return static_cast< ::SC2APIProtocol::AIBuild >(ai_build_);
}
inline ::SC2APIProtocol::AIBuild PlayerInfo::ai_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.ai_build)
  return _internal_ai_build();
}
inline void PlayerInfo::_internal_set_ai_build(::SC2APIProtocol::AIBuild value) {
  assert(::SC2APIProtocol::AIBuild_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  ai_build_ = value;
}
inline void PlayerInfo::set_ai_build(::SC2APIProtocol::AIBuild value) {
  _internal_set_ai_build(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.ai_build)
}

// optional string player_name = 6;
inline bool PlayerInfo::_internal_has_player_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerInfo::has_player_name() const {
  return _internal_has_player_name();
}
inline void PlayerInfo::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerInfo::player_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.player_name)
  return _internal_player_name();
}
inline void PlayerInfo::set_player_name(const std::string& value) {
  _internal_set_player_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.player_name)
}
inline std::string* PlayerInfo::mutable_player_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerInfo.player_name)
  return _internal_mutable_player_name();
}
inline const std::string& PlayerInfo::_internal_player_name() const {
  return player_name_.GetNoArena();
}
inline void PlayerInfo::_internal_set_player_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PlayerInfo::set_player_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.PlayerInfo.player_name)
}
inline void PlayerInfo::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.PlayerInfo.player_name)
}
inline void PlayerInfo::set_player_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.PlayerInfo.player_name)
}
inline std::string* PlayerInfo::_internal_mutable_player_name() {
  _has_bits_[0] |= 0x00000001u;
  return player_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PlayerInfo::release_player_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerInfo.player_name)
  if (!_internal_has_player_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerInfo.player_name)
}

// -------------------------------------------------------------------

// PlayerCommon

// optional uint32 player_id = 1;
inline bool PlayerCommon::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerCommon::has_player_id() const {
  return _internal_has_player_id();
}
inline void PlayerCommon::clear_player_id() {
  player_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.player_id)
  return _internal_player_id();
}
inline void PlayerCommon::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  player_id_ = value;
}
inline void PlayerCommon::set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.player_id)
}

// optional uint32 minerals = 2;
inline bool PlayerCommon::_internal_has_minerals() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerCommon::has_minerals() const {
  return _internal_has_minerals();
}
inline void PlayerCommon::clear_minerals() {
  minerals_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_minerals() const {
  return minerals_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::minerals() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.minerals)
  return _internal_minerals();
}
inline void PlayerCommon::_internal_set_minerals(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  minerals_ = value;
}
inline void PlayerCommon::set_minerals(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_minerals(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.minerals)
}

// optional uint32 vespene = 3;
inline bool PlayerCommon::_internal_has_vespene() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerCommon::has_vespene() const {
  return _internal_has_vespene();
}
inline void PlayerCommon::clear_vespene() {
  vespene_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_vespene() const {
  return vespene_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::vespene() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.vespene)
  return _internal_vespene();
}
inline void PlayerCommon::_internal_set_vespene(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  vespene_ = value;
}
inline void PlayerCommon::set_vespene(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_vespene(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.vespene)
}

// optional uint32 food_cap = 4;
inline bool PlayerCommon::_internal_has_food_cap() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerCommon::has_food_cap() const {
  return _internal_has_food_cap();
}
inline void PlayerCommon::clear_food_cap() {
  food_cap_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_food_cap() const {
  return food_cap_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::food_cap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_cap)
  return _internal_food_cap();
}
inline void PlayerCommon::_internal_set_food_cap(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  food_cap_ = value;
}
inline void PlayerCommon::set_food_cap(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_food_cap(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_cap)
}

// optional uint32 food_used = 5;
inline bool PlayerCommon::_internal_has_food_used() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerCommon::has_food_used() const {
  return _internal_has_food_used();
}
inline void PlayerCommon::clear_food_used() {
  food_used_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_food_used() const {
  return food_used_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::food_used() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_used)
  return _internal_food_used();
}
inline void PlayerCommon::_internal_set_food_used(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  food_used_ = value;
}
inline void PlayerCommon::set_food_used(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_food_used(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_used)
}

// optional uint32 food_army = 6;
inline bool PlayerCommon::_internal_has_food_army() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlayerCommon::has_food_army() const {
  return _internal_has_food_army();
}
inline void PlayerCommon::clear_food_army() {
  food_army_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_food_army() const {
  return food_army_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::food_army() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_army)
  return _internal_food_army();
}
inline void PlayerCommon::_internal_set_food_army(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  food_army_ = value;
}
inline void PlayerCommon::set_food_army(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_food_army(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_army)
}

// optional uint32 food_workers = 7;
inline bool PlayerCommon::_internal_has_food_workers() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlayerCommon::has_food_workers() const {
  return _internal_has_food_workers();
}
inline void PlayerCommon::clear_food_workers() {
  food_workers_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_food_workers() const {
  return food_workers_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::food_workers() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_workers)
  return _internal_food_workers();
}
inline void PlayerCommon::_internal_set_food_workers(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  food_workers_ = value;
}
inline void PlayerCommon::set_food_workers(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_food_workers(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_workers)
}

// optional uint32 idle_worker_count = 8;
inline bool PlayerCommon::_internal_has_idle_worker_count() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PlayerCommon::has_idle_worker_count() const {
  return _internal_has_idle_worker_count();
}
inline void PlayerCommon::clear_idle_worker_count() {
  idle_worker_count_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_idle_worker_count() const {
  return idle_worker_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::idle_worker_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.idle_worker_count)
  return _internal_idle_worker_count();
}
inline void PlayerCommon::_internal_set_idle_worker_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  idle_worker_count_ = value;
}
inline void PlayerCommon::set_idle_worker_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idle_worker_count(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.idle_worker_count)
}

// optional uint32 army_count = 9;
inline bool PlayerCommon::_internal_has_army_count() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PlayerCommon::has_army_count() const {
  return _internal_has_army_count();
}
inline void PlayerCommon::clear_army_count() {
  army_count_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_army_count() const {
  return army_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::army_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.army_count)
  return _internal_army_count();
}
inline void PlayerCommon::_internal_set_army_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  army_count_ = value;
}
inline void PlayerCommon::set_army_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_army_count(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.army_count)
}

// optional uint32 warp_gate_count = 10;
inline bool PlayerCommon::_internal_has_warp_gate_count() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PlayerCommon::has_warp_gate_count() const {
  return _internal_has_warp_gate_count();
}
inline void PlayerCommon::clear_warp_gate_count() {
  warp_gate_count_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_warp_gate_count() const {
  return warp_gate_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::warp_gate_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.warp_gate_count)
  return _internal_warp_gate_count();
}
inline void PlayerCommon::_internal_set_warp_gate_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  warp_gate_count_ = value;
}
inline void PlayerCommon::set_warp_gate_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_warp_gate_count(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.warp_gate_count)
}

// optional uint32 larva_count = 11;
inline bool PlayerCommon::_internal_has_larva_count() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PlayerCommon::has_larva_count() const {
  return _internal_has_larva_count();
}
inline void PlayerCommon::clear_larva_count() {
  larva_count_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::_internal_larva_count() const {
  return larva_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerCommon::larva_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.larva_count)
  return _internal_larva_count();
}
inline void PlayerCommon::_internal_set_larva_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  larva_count_ = value;
}
inline void PlayerCommon::set_larva_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_larva_count(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.larva_count)
}

// -------------------------------------------------------------------

// Observation

// optional uint32 game_loop = 9;
inline bool Observation::_internal_has_game_loop() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Observation::has_game_loop() const {
  return _internal_has_game_loop();
}
inline void Observation::clear_game_loop() {
  game_loop_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Observation::_internal_game_loop() const {
  return game_loop_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Observation::game_loop() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.game_loop)
  return _internal_game_loop();
}
inline void Observation::_internal_set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  game_loop_ = value;
}
inline void Observation::set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_game_loop(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Observation.game_loop)
}

// optional .SC2APIProtocol.PlayerCommon player_common = 1;
inline bool Observation::_internal_has_player_common() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || player_common_ != nullptr);
  return value;
}
inline bool Observation::has_player_common() const {
  return _internal_has_player_common();
}
inline void Observation::clear_player_common() {
  if (player_common_ != nullptr) player_common_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::PlayerCommon& Observation::_internal_player_common() const {
  const ::SC2APIProtocol::PlayerCommon* p = player_common_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::PlayerCommon*>(
      &::SC2APIProtocol::_PlayerCommon_default_instance_);
}
inline const ::SC2APIProtocol::PlayerCommon& Observation::player_common() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.player_common)
  return _internal_player_common();
}
inline ::SC2APIProtocol::PlayerCommon* Observation::release_player_common() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.player_common)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::PlayerCommon* temp = player_common_;
  player_common_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::PlayerCommon* Observation::_internal_mutable_player_common() {
  _has_bits_[0] |= 0x00000001u;
  if (player_common_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PlayerCommon>(GetArenaNoVirtual());
    player_common_ = p;
  }
  return player_common_;
}
inline ::SC2APIProtocol::PlayerCommon* Observation::mutable_player_common() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.player_common)
  return _internal_mutable_player_common();
}
inline void Observation::set_allocated_player_common(::SC2APIProtocol::PlayerCommon* player_common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete player_common_;
  }
  if (player_common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_common, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_common_ = player_common;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.player_common)
}

// repeated .SC2APIProtocol.Alert alerts = 10;
inline int Observation::_internal_alerts_size() const {
  return alerts_.size();
}
inline int Observation::alerts_size() const {
  return _internal_alerts_size();
}
inline void Observation::clear_alerts() {
  alerts_.Clear();
}
inline ::SC2APIProtocol::Alert Observation::_internal_alerts(int index) const {
  return static_cast< ::SC2APIProtocol::Alert >(alerts_.Get(index));
}
inline ::SC2APIProtocol::Alert Observation::alerts(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.alerts)
  return _internal_alerts(index);
}
inline void Observation::set_alerts(int index, ::SC2APIProtocol::Alert value) {
  assert(::SC2APIProtocol::Alert_IsValid(value));
  alerts_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Observation.alerts)
}
inline void Observation::_internal_add_alerts(::SC2APIProtocol::Alert value) {
  assert(::SC2APIProtocol::Alert_IsValid(value));
  alerts_.Add(value);
}
inline void Observation::add_alerts(::SC2APIProtocol::Alert value) {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Observation.alerts)
  _internal_add_alerts(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Observation::alerts() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Observation.alerts)
  return alerts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Observation::_internal_mutable_alerts() {
  return &alerts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Observation::mutable_alerts() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Observation.alerts)
  return _internal_mutable_alerts();
}

// repeated .SC2APIProtocol.AvailableAbility abilities = 3;
inline int Observation::_internal_abilities_size() const {
  return abilities_.size();
}
inline int Observation::abilities_size() const {
  return _internal_abilities_size();
}
inline ::SC2APIProtocol::AvailableAbility* Observation::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.abilities)
  return abilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >*
Observation::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Observation.abilities)
  return &abilities_;
}
inline const ::SC2APIProtocol::AvailableAbility& Observation::_internal_abilities(int index) const {
  return abilities_.Get(index);
}
inline const ::SC2APIProtocol::AvailableAbility& Observation::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.abilities)
  return _internal_abilities(index);
}
inline ::SC2APIProtocol::AvailableAbility* Observation::_internal_add_abilities() {
  return abilities_.Add();
}
inline ::SC2APIProtocol::AvailableAbility* Observation::add_abilities() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Observation.abilities)
  return _internal_add_abilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >&
Observation::abilities() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Observation.abilities)
  return abilities_;
}

// optional .SC2APIProtocol.Score score = 4;
inline bool Observation::_internal_has_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || score_ != nullptr);
  return value;
}
inline bool Observation::has_score() const {
  return _internal_has_score();
}
inline const ::SC2APIProtocol::Score& Observation::_internal_score() const {
  const ::SC2APIProtocol::Score* p = score_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Score*>(
      &::SC2APIProtocol::_Score_default_instance_);
}
inline const ::SC2APIProtocol::Score& Observation::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.score)
  return _internal_score();
}
inline ::SC2APIProtocol::Score* Observation::release_score() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.score)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::Score* temp = score_;
  score_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Score* Observation::_internal_mutable_score() {
  _has_bits_[0] |= 0x00000002u;
  if (score_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Score>(GetArenaNoVirtual());
    score_ = p;
  }
  return score_;
}
inline ::SC2APIProtocol::Score* Observation::mutable_score() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.score)
  return _internal_mutable_score();
}
inline void Observation::set_allocated_score(::SC2APIProtocol::Score* score) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(score_);
  }
  if (score) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      score = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, score, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  score_ = score;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.score)
}

// optional .SC2APIProtocol.ObservationRaw raw_data = 5;
inline bool Observation::_internal_has_raw_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || raw_data_ != nullptr);
  return value;
}
inline bool Observation::has_raw_data() const {
  return _internal_has_raw_data();
}
inline const ::SC2APIProtocol::ObservationRaw& Observation::_internal_raw_data() const {
  const ::SC2APIProtocol::ObservationRaw* p = raw_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationRaw*>(
      &::SC2APIProtocol::_ObservationRaw_default_instance_);
}
inline const ::SC2APIProtocol::ObservationRaw& Observation::raw_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.raw_data)
  return _internal_raw_data();
}
inline ::SC2APIProtocol::ObservationRaw* Observation::release_raw_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.raw_data)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ObservationRaw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ObservationRaw* Observation::_internal_mutable_raw_data() {
  _has_bits_[0] |= 0x00000004u;
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationRaw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  return raw_data_;
}
inline ::SC2APIProtocol::ObservationRaw* Observation::mutable_raw_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.raw_data)
  return _internal_mutable_raw_data();
}
inline void Observation::set_allocated_raw_data(::SC2APIProtocol::ObservationRaw* raw_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_data_);
  }
  if (raw_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      raw_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.raw_data)
}

// optional .SC2APIProtocol.ObservationFeatureLayer feature_layer_data = 6;
inline bool Observation::_internal_has_feature_layer_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || feature_layer_data_ != nullptr);
  return value;
}
inline bool Observation::has_feature_layer_data() const {
  return _internal_has_feature_layer_data();
}
inline const ::SC2APIProtocol::ObservationFeatureLayer& Observation::_internal_feature_layer_data() const {
  const ::SC2APIProtocol::ObservationFeatureLayer* p = feature_layer_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationFeatureLayer*>(
      &::SC2APIProtocol::_ObservationFeatureLayer_default_instance_);
}
inline const ::SC2APIProtocol::ObservationFeatureLayer& Observation::feature_layer_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.feature_layer_data)
  return _internal_feature_layer_data();
}
inline ::SC2APIProtocol::ObservationFeatureLayer* Observation::release_feature_layer_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.feature_layer_data)
  _has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ObservationFeatureLayer* temp = feature_layer_data_;
  feature_layer_data_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ObservationFeatureLayer* Observation::_internal_mutable_feature_layer_data() {
  _has_bits_[0] |= 0x00000008u;
  if (feature_layer_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationFeatureLayer>(GetArenaNoVirtual());
    feature_layer_data_ = p;
  }
  return feature_layer_data_;
}
inline ::SC2APIProtocol::ObservationFeatureLayer* Observation::mutable_feature_layer_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.feature_layer_data)
  return _internal_mutable_feature_layer_data();
}
inline void Observation::set_allocated_feature_layer_data(::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_layer_data_);
  }
  if (feature_layer_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      feature_layer_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_layer_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  feature_layer_data_ = feature_layer_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.feature_layer_data)
}

// optional .SC2APIProtocol.ObservationRender render_data = 7;
inline bool Observation::_internal_has_render_data() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || render_data_ != nullptr);
  return value;
}
inline bool Observation::has_render_data() const {
  return _internal_has_render_data();
}
inline const ::SC2APIProtocol::ObservationRender& Observation::_internal_render_data() const {
  const ::SC2APIProtocol::ObservationRender* p = render_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationRender*>(
      &::SC2APIProtocol::_ObservationRender_default_instance_);
}
inline const ::SC2APIProtocol::ObservationRender& Observation::render_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.render_data)
  return _internal_render_data();
}
inline ::SC2APIProtocol::ObservationRender* Observation::release_render_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.render_data)
  _has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ObservationRender* temp = render_data_;
  render_data_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ObservationRender* Observation::_internal_mutable_render_data() {
  _has_bits_[0] |= 0x00000010u;
  if (render_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationRender>(GetArenaNoVirtual());
    render_data_ = p;
  }
  return render_data_;
}
inline ::SC2APIProtocol::ObservationRender* Observation::mutable_render_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.render_data)
  return _internal_mutable_render_data();
}
inline void Observation::set_allocated_render_data(::SC2APIProtocol::ObservationRender* render_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(render_data_);
  }
  if (render_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      render_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, render_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  render_data_ = render_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.render_data)
}

// optional .SC2APIProtocol.ObservationUI ui_data = 8;
inline bool Observation::_internal_has_ui_data() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || ui_data_ != nullptr);
  return value;
}
inline bool Observation::has_ui_data() const {
  return _internal_has_ui_data();
}
inline const ::SC2APIProtocol::ObservationUI& Observation::_internal_ui_data() const {
  const ::SC2APIProtocol::ObservationUI* p = ui_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationUI*>(
      &::SC2APIProtocol::_ObservationUI_default_instance_);
}
inline const ::SC2APIProtocol::ObservationUI& Observation::ui_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.ui_data)
  return _internal_ui_data();
}
inline ::SC2APIProtocol::ObservationUI* Observation::release_ui_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.ui_data)
  _has_bits_[0] &= ~0x00000020u;
  ::SC2APIProtocol::ObservationUI* temp = ui_data_;
  ui_data_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ObservationUI* Observation::_internal_mutable_ui_data() {
  _has_bits_[0] |= 0x00000020u;
  if (ui_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationUI>(GetArenaNoVirtual());
    ui_data_ = p;
  }
  return ui_data_;
}
inline ::SC2APIProtocol::ObservationUI* Observation::mutable_ui_data() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.ui_data)
  return _internal_mutable_ui_data();
}
inline void Observation::set_allocated_ui_data(::SC2APIProtocol::ObservationUI* ui_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ui_data_);
  }
  if (ui_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ui_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ui_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  ui_data_ = ui_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.ui_data)
}

// -------------------------------------------------------------------

// Action

// optional .SC2APIProtocol.ActionRaw action_raw = 1;
inline bool Action::_internal_has_action_raw() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || action_raw_ != nullptr);
  return value;
}
inline bool Action::has_action_raw() const {
  return _internal_has_action_raw();
}
inline const ::SC2APIProtocol::ActionRaw& Action::_internal_action_raw() const {
  const ::SC2APIProtocol::ActionRaw* p = action_raw_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionRaw*>(
      &::SC2APIProtocol::_ActionRaw_default_instance_);
}
inline const ::SC2APIProtocol::ActionRaw& Action::action_raw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_raw)
  return _internal_action_raw();
}
inline ::SC2APIProtocol::ActionRaw* Action::release_action_raw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_raw)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::ActionRaw* temp = action_raw_;
  action_raw_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ActionRaw* Action::_internal_mutable_action_raw() {
  _has_bits_[0] |= 0x00000001u;
  if (action_raw_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionRaw>(GetArenaNoVirtual());
    action_raw_ = p;
  }
  return action_raw_;
}
inline ::SC2APIProtocol::ActionRaw* Action::mutable_action_raw() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_raw)
  return _internal_mutable_action_raw();
}
inline void Action::set_allocated_action_raw(::SC2APIProtocol::ActionRaw* action_raw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_raw_);
  }
  if (action_raw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      action_raw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_raw, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  action_raw_ = action_raw;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_raw)
}

// optional .SC2APIProtocol.ActionSpatial action_feature_layer = 2;
inline bool Action::_internal_has_action_feature_layer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || action_feature_layer_ != nullptr);
  return value;
}
inline bool Action::has_action_feature_layer() const {
  return _internal_has_action_feature_layer();
}
inline const ::SC2APIProtocol::ActionSpatial& Action::_internal_action_feature_layer() const {
  const ::SC2APIProtocol::ActionSpatial* p = action_feature_layer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionSpatial*>(
      &::SC2APIProtocol::_ActionSpatial_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatial& Action::action_feature_layer() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_feature_layer)
  return _internal_action_feature_layer();
}
inline ::SC2APIProtocol::ActionSpatial* Action::release_action_feature_layer() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_feature_layer)
  _has_bits_[0] &= ~0x00000002u;
  ::SC2APIProtocol::ActionSpatial* temp = action_feature_layer_;
  action_feature_layer_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ActionSpatial* Action::_internal_mutable_action_feature_layer() {
  _has_bits_[0] |= 0x00000002u;
  if (action_feature_layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionSpatial>(GetArenaNoVirtual());
    action_feature_layer_ = p;
  }
  return action_feature_layer_;
}
inline ::SC2APIProtocol::ActionSpatial* Action::mutable_action_feature_layer() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_feature_layer)
  return _internal_mutable_action_feature_layer();
}
inline void Action::set_allocated_action_feature_layer(::SC2APIProtocol::ActionSpatial* action_feature_layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_feature_layer_);
  }
  if (action_feature_layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      action_feature_layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_feature_layer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  action_feature_layer_ = action_feature_layer;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_feature_layer)
}

// optional .SC2APIProtocol.ActionSpatial action_render = 3;
inline bool Action::_internal_has_action_render() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || action_render_ != nullptr);
  return value;
}
inline bool Action::has_action_render() const {
  return _internal_has_action_render();
}
inline const ::SC2APIProtocol::ActionSpatial& Action::_internal_action_render() const {
  const ::SC2APIProtocol::ActionSpatial* p = action_render_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionSpatial*>(
      &::SC2APIProtocol::_ActionSpatial_default_instance_);
}
inline const ::SC2APIProtocol::ActionSpatial& Action::action_render() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_render)
  return _internal_action_render();
}
inline ::SC2APIProtocol::ActionSpatial* Action::release_action_render() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_render)
  _has_bits_[0] &= ~0x00000004u;
  ::SC2APIProtocol::ActionSpatial* temp = action_render_;
  action_render_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ActionSpatial* Action::_internal_mutable_action_render() {
  _has_bits_[0] |= 0x00000004u;
  if (action_render_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionSpatial>(GetArenaNoVirtual());
    action_render_ = p;
  }
  return action_render_;
}
inline ::SC2APIProtocol::ActionSpatial* Action::mutable_action_render() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_render)
  return _internal_mutable_action_render();
}
inline void Action::set_allocated_action_render(::SC2APIProtocol::ActionSpatial* action_render) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_render_);
  }
  if (action_render) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      action_render = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_render, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  action_render_ = action_render;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_render)
}

// optional .SC2APIProtocol.ActionUI action_ui = 4;
inline bool Action::_internal_has_action_ui() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || action_ui_ != nullptr);
  return value;
}
inline bool Action::has_action_ui() const {
  return _internal_has_action_ui();
}
inline const ::SC2APIProtocol::ActionUI& Action::_internal_action_ui() const {
  const ::SC2APIProtocol::ActionUI* p = action_ui_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionUI*>(
      &::SC2APIProtocol::_ActionUI_default_instance_);
}
inline const ::SC2APIProtocol::ActionUI& Action::action_ui() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_ui)
  return _internal_action_ui();
}
inline ::SC2APIProtocol::ActionUI* Action::release_action_ui() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_ui)
  _has_bits_[0] &= ~0x00000008u;
  ::SC2APIProtocol::ActionUI* temp = action_ui_;
  action_ui_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ActionUI* Action::_internal_mutable_action_ui() {
  _has_bits_[0] |= 0x00000008u;
  if (action_ui_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionUI>(GetArenaNoVirtual());
    action_ui_ = p;
  }
  return action_ui_;
}
inline ::SC2APIProtocol::ActionUI* Action::mutable_action_ui() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_ui)
  return _internal_mutable_action_ui();
}
inline void Action::set_allocated_action_ui(::SC2APIProtocol::ActionUI* action_ui) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_ui_);
  }
  if (action_ui) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      action_ui = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_ui, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  action_ui_ = action_ui;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_ui)
}

// optional .SC2APIProtocol.ActionChat action_chat = 6;
inline bool Action::_internal_has_action_chat() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || action_chat_ != nullptr);
  return value;
}
inline bool Action::has_action_chat() const {
  return _internal_has_action_chat();
}
inline void Action::clear_action_chat() {
  if (action_chat_ != nullptr) action_chat_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::SC2APIProtocol::ActionChat& Action::_internal_action_chat() const {
  const ::SC2APIProtocol::ActionChat* p = action_chat_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionChat*>(
      &::SC2APIProtocol::_ActionChat_default_instance_);
}
inline const ::SC2APIProtocol::ActionChat& Action::action_chat() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_chat)
  return _internal_action_chat();
}
inline ::SC2APIProtocol::ActionChat* Action::release_action_chat() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_chat)
  _has_bits_[0] &= ~0x00000010u;
  ::SC2APIProtocol::ActionChat* temp = action_chat_;
  action_chat_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::ActionChat* Action::_internal_mutable_action_chat() {
  _has_bits_[0] |= 0x00000010u;
  if (action_chat_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionChat>(GetArenaNoVirtual());
    action_chat_ = p;
  }
  return action_chat_;
}
inline ::SC2APIProtocol::ActionChat* Action::mutable_action_chat() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_chat)
  return _internal_mutable_action_chat();
}
inline void Action::set_allocated_action_chat(::SC2APIProtocol::ActionChat* action_chat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete action_chat_;
  }
  if (action_chat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      action_chat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action_chat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  action_chat_ = action_chat;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_chat)
}

// optional uint32 game_loop = 7;
inline bool Action::_internal_has_game_loop() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Action::has_game_loop() const {
  return _internal_has_game_loop();
}
inline void Action::clear_game_loop() {
  game_loop_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Action::_internal_game_loop() const {
  return game_loop_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Action::game_loop() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.game_loop)
  return _internal_game_loop();
}
inline void Action::_internal_set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  game_loop_ = value;
}
inline void Action::set_game_loop(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_game_loop(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Action.game_loop)
}

// -------------------------------------------------------------------

// ActionChat

// optional .SC2APIProtocol.ActionChat.Channel channel = 1;
inline bool ActionChat::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionChat::has_channel() const {
  return _internal_has_channel();
}
inline void ActionChat::clear_channel() {
  channel_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::ActionChat_Channel ActionChat::_internal_channel() const {
  return static_cast< ::SC2APIProtocol::ActionChat_Channel >(channel_);
}
inline ::SC2APIProtocol::ActionChat_Channel ActionChat::channel() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionChat.channel)
  return _internal_channel();
}
inline void ActionChat::_internal_set_channel(::SC2APIProtocol::ActionChat_Channel value) {
  assert(::SC2APIProtocol::ActionChat_Channel_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  channel_ = value;
}
inline void ActionChat::set_channel(::SC2APIProtocol::ActionChat_Channel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionChat.channel)
}

// optional string message = 2;
inline bool ActionChat::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionChat::has_message() const {
  return _internal_has_message();
}
inline void ActionChat::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionChat::message() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionChat.message)
  return _internal_message();
}
inline void ActionChat::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionChat.message)
}
inline std::string* ActionChat::mutable_message() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionChat.message)
  return _internal_mutable_message();
}
inline const std::string& ActionChat::_internal_message() const {
  return message_.GetNoArena();
}
inline void ActionChat::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ActionChat::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ActionChat.message)
}
inline void ActionChat::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ActionChat.message)
}
inline void ActionChat::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ActionChat.message)
}
inline std::string* ActionChat::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ActionChat::release_message() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionChat.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ActionChat::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionChat.message)
}

// -------------------------------------------------------------------

// ActionError

// optional uint64 unit_tag = 1;
inline bool ActionError::_internal_has_unit_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionError::has_unit_tag() const {
  return _internal_has_unit_tag();
}
inline void ActionError::clear_unit_tag() {
  unit_tag_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActionError::_internal_unit_tag() const {
  return unit_tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActionError::unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.unit_tag)
  return _internal_unit_tag();
}
inline void ActionError::_internal_set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  unit_tag_ = value;
}
inline void ActionError::set_unit_tag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_unit_tag(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.unit_tag)
}

// optional uint64 ability_id = 2;
inline bool ActionError::_internal_has_ability_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionError::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void ActionError::clear_ability_id() {
  ability_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActionError::_internal_ability_id() const {
  return ability_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActionError::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.ability_id)
  return _internal_ability_id();
}
inline void ActionError::_internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ability_id_ = value;
}
inline void ActionError::set_ability_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.ability_id)
}

// optional .SC2APIProtocol.ActionResult result = 3;
inline bool ActionError::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ActionError::has_result() const {
  return _internal_has_result();
}
inline void ActionError::clear_result() {
  result_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::SC2APIProtocol::ActionResult ActionError::_internal_result() const {
  return static_cast< ::SC2APIProtocol::ActionResult >(result_);
}
inline ::SC2APIProtocol::ActionResult ActionError::result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.result)
  return _internal_result();
}
inline void ActionError::_internal_set_result(::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  result_ = value;
}
inline void ActionError::set_result(::SC2APIProtocol::ActionResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.result)
}

// -------------------------------------------------------------------

// ObserverAction

// optional .SC2APIProtocol.ActionObserverPlayerPerspective player_perspective = 1;
inline bool ObserverAction::_internal_has_player_perspective() const {
  return action_case() == kPlayerPerspective;
}
inline bool ObserverAction::has_player_perspective() const {
  return _internal_has_player_perspective();
}
inline void ObserverAction::set_has_player_perspective() {
  _oneof_case_[0] = kPlayerPerspective;
}
inline void ObserverAction::clear_player_perspective() {
  if (_internal_has_player_perspective()) {
    delete action_.player_perspective_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionObserverPlayerPerspective* ObserverAction::release_player_perspective() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.player_perspective)
  if (_internal_has_player_perspective()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverPlayerPerspective* temp = action_.player_perspective_;
    action_.player_perspective_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionObserverPlayerPerspective& ObserverAction::_internal_player_perspective() const {
  return _internal_has_player_perspective()
      ? *action_.player_perspective_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverPlayerPerspective*>(&::SC2APIProtocol::_ActionObserverPlayerPerspective_default_instance_);
}
inline const ::SC2APIProtocol::ActionObserverPlayerPerspective& ObserverAction::player_perspective() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.player_perspective)
  return _internal_player_perspective();
}
inline ::SC2APIProtocol::ActionObserverPlayerPerspective* ObserverAction::_internal_mutable_player_perspective() {
  if (!_internal_has_player_perspective()) {
    clear_action();
    set_has_player_perspective();
    action_.player_perspective_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverPlayerPerspective >(
        GetArenaNoVirtual());
  }
  return action_.player_perspective_;
}
inline ::SC2APIProtocol::ActionObserverPlayerPerspective* ObserverAction::mutable_player_perspective() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.player_perspective)
  return _internal_mutable_player_perspective();
}

// optional .SC2APIProtocol.ActionObserverCameraMove camera_move = 2;
inline bool ObserverAction::_internal_has_camera_move() const {
  return action_case() == kCameraMove;
}
inline bool ObserverAction::has_camera_move() const {
  return _internal_has_camera_move();
}
inline void ObserverAction::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ObserverAction::clear_camera_move() {
  if (_internal_has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionObserverCameraMove* ObserverAction::release_camera_move() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.camera_move)
  if (_internal_has_camera_move()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraMove& ObserverAction::_internal_camera_move() const {
  return _internal_has_camera_move()
      ? *action_.camera_move_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverCameraMove*>(&::SC2APIProtocol::_ActionObserverCameraMove_default_instance_);
}
inline const ::SC2APIProtocol::ActionObserverCameraMove& ObserverAction::camera_move() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.camera_move)
  return _internal_camera_move();
}
inline ::SC2APIProtocol::ActionObserverCameraMove* ObserverAction::_internal_mutable_camera_move() {
  if (!_internal_has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverCameraMove >(
        GetArenaNoVirtual());
  }
  return action_.camera_move_;
}
inline ::SC2APIProtocol::ActionObserverCameraMove* ObserverAction::mutable_camera_move() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.camera_move)
  return _internal_mutable_camera_move();
}

// optional .SC2APIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;
inline bool ObserverAction::_internal_has_camera_follow_player() const {
  return action_case() == kCameraFollowPlayer;
}
inline bool ObserverAction::has_camera_follow_player() const {
  return _internal_has_camera_follow_player();
}
inline void ObserverAction::set_has_camera_follow_player() {
  _oneof_case_[0] = kCameraFollowPlayer;
}
inline void ObserverAction::clear_camera_follow_player() {
  if (_internal_has_camera_follow_player()) {
    delete action_.camera_follow_player_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionObserverCameraFollowPlayer* ObserverAction::release_camera_follow_player() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.camera_follow_player)
  if (_internal_has_camera_follow_player()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverCameraFollowPlayer* temp = action_.camera_follow_player_;
    action_.camera_follow_player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& ObserverAction::_internal_camera_follow_player() const {
  return _internal_has_camera_follow_player()
      ? *action_.camera_follow_player_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverCameraFollowPlayer*>(&::SC2APIProtocol::_ActionObserverCameraFollowPlayer_default_instance_);
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& ObserverAction::camera_follow_player() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.camera_follow_player)
  return _internal_camera_follow_player();
}
inline ::SC2APIProtocol::ActionObserverCameraFollowPlayer* ObserverAction::_internal_mutable_camera_follow_player() {
  if (!_internal_has_camera_follow_player()) {
    clear_action();
    set_has_camera_follow_player();
    action_.camera_follow_player_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverCameraFollowPlayer >(
        GetArenaNoVirtual());
  }
  return action_.camera_follow_player_;
}
inline ::SC2APIProtocol::ActionObserverCameraFollowPlayer* ObserverAction::mutable_camera_follow_player() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.camera_follow_player)
  return _internal_mutable_camera_follow_player();
}

// optional .SC2APIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;
inline bool ObserverAction::_internal_has_camera_follow_units() const {
  return action_case() == kCameraFollowUnits;
}
inline bool ObserverAction::has_camera_follow_units() const {
  return _internal_has_camera_follow_units();
}
inline void ObserverAction::set_has_camera_follow_units() {
  _oneof_case_[0] = kCameraFollowUnits;
}
inline void ObserverAction::clear_camera_follow_units() {
  if (_internal_has_camera_follow_units()) {
    delete action_.camera_follow_units_;
    clear_has_action();
  }
}
inline ::SC2APIProtocol::ActionObserverCameraFollowUnits* ObserverAction::release_camera_follow_units() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.camera_follow_units)
  if (_internal_has_camera_follow_units()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverCameraFollowUnits* temp = action_.camera_follow_units_;
    action_.camera_follow_units_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowUnits& ObserverAction::_internal_camera_follow_units() const {
  return _internal_has_camera_follow_units()
      ? *action_.camera_follow_units_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverCameraFollowUnits*>(&::SC2APIProtocol::_ActionObserverCameraFollowUnits_default_instance_);
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowUnits& ObserverAction::camera_follow_units() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.camera_follow_units)
  return _internal_camera_follow_units();
}
inline ::SC2APIProtocol::ActionObserverCameraFollowUnits* ObserverAction::_internal_mutable_camera_follow_units() {
  if (!_internal_has_camera_follow_units()) {
    clear_action();
    set_has_camera_follow_units();
    action_.camera_follow_units_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverCameraFollowUnits >(
        GetArenaNoVirtual());
  }
  return action_.camera_follow_units_;
}
inline ::SC2APIProtocol::ActionObserverCameraFollowUnits* ObserverAction::mutable_camera_follow_units() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.camera_follow_units)
  return _internal_mutable_camera_follow_units();
}

inline bool ObserverAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ObserverAction::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ObserverAction::ActionCase ObserverAction::action_case() const {
  return ObserverAction::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionObserverPlayerPerspective

// optional uint32 player_id = 1;
inline bool ActionObserverPlayerPerspective::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionObserverPlayerPerspective::has_player_id() const {
  return _internal_has_player_id();
}
inline void ActionObserverPlayerPerspective::clear_player_id() {
  player_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionObserverPlayerPerspective::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionObserverPlayerPerspective::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverPlayerPerspective.player_id)
  return _internal_player_id();
}
inline void ActionObserverPlayerPerspective::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  player_id_ = value;
}
inline void ActionObserverPlayerPerspective::set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverPlayerPerspective.player_id)
}

// -------------------------------------------------------------------

// ActionObserverCameraMove

// optional .SC2APIProtocol.Point2D world_pos = 1;
inline bool ActionObserverCameraMove::_internal_has_world_pos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || world_pos_ != nullptr);
  return value;
}
inline bool ActionObserverCameraMove::has_world_pos() const {
  return _internal_has_world_pos();
}
inline const ::SC2APIProtocol::Point2D& ActionObserverCameraMove::_internal_world_pos() const {
  const ::SC2APIProtocol::Point2D* p = world_pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point2D*>(
      &::SC2APIProtocol::_Point2D_default_instance_);
}
inline const ::SC2APIProtocol::Point2D& ActionObserverCameraMove::world_pos() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraMove.world_pos)
  return _internal_world_pos();
}
inline ::SC2APIProtocol::Point2D* ActionObserverCameraMove::release_world_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionObserverCameraMove.world_pos)
  _has_bits_[0] &= ~0x00000001u;
  ::SC2APIProtocol::Point2D* temp = world_pos_;
  world_pos_ = nullptr;
  return temp;
}
inline ::SC2APIProtocol::Point2D* ActionObserverCameraMove::_internal_mutable_world_pos() {
  _has_bits_[0] |= 0x00000001u;
  if (world_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point2D>(GetArenaNoVirtual());
    world_pos_ = p;
  }
  return world_pos_;
}
inline ::SC2APIProtocol::Point2D* ActionObserverCameraMove::mutable_world_pos() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionObserverCameraMove.world_pos)
  return _internal_mutable_world_pos();
}
inline void ActionObserverCameraMove::set_allocated_world_pos(::SC2APIProtocol::Point2D* world_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_pos_);
  }
  if (world_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      world_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  world_pos_ = world_pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionObserverCameraMove.world_pos)
}

// optional float distance = 2;
inline bool ActionObserverCameraMove::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionObserverCameraMove::has_distance() const {
  return _internal_has_distance();
}
inline void ActionObserverCameraMove::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ActionObserverCameraMove::_internal_distance() const {
  return distance_;
}
inline float ActionObserverCameraMove::distance() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraMove.distance)
  return _internal_distance();
}
inline void ActionObserverCameraMove::_internal_set_distance(float value) {
  _has_bits_[0] |= 0x00000002u;
  distance_ = value;
}
inline void ActionObserverCameraMove::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverCameraMove.distance)
}

// -------------------------------------------------------------------

// ActionObserverCameraFollowPlayer

// optional uint32 player_id = 1;
inline bool ActionObserverCameraFollowPlayer::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionObserverCameraFollowPlayer::has_player_id() const {
  return _internal_has_player_id();
}
inline void ActionObserverCameraFollowPlayer::clear_player_id() {
  player_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionObserverCameraFollowPlayer::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ActionObserverCameraFollowPlayer::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraFollowPlayer.player_id)
  return _internal_player_id();
}
inline void ActionObserverCameraFollowPlayer::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  player_id_ = value;
}
inline void ActionObserverCameraFollowPlayer::set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverCameraFollowPlayer.player_id)
}

// -------------------------------------------------------------------

// ActionObserverCameraFollowUnits

// repeated uint64 unit_tags = 1;
inline int ActionObserverCameraFollowUnits::_internal_unit_tags_size() const {
  return unit_tags_.size();
}
inline int ActionObserverCameraFollowUnits::unit_tags_size() const {
  return _internal_unit_tags_size();
}
inline void ActionObserverCameraFollowUnits::clear_unit_tags() {
  unit_tags_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActionObserverCameraFollowUnits::_internal_unit_tags(int index) const {
  return unit_tags_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ActionObserverCameraFollowUnits::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return _internal_unit_tags(index);
}
inline void ActionObserverCameraFollowUnits::set_unit_tags(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
}
inline void ActionObserverCameraFollowUnits::_internal_add_unit_tags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  unit_tags_.Add(value);
}
inline void ActionObserverCameraFollowUnits::add_unit_tags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_unit_tags(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
ActionObserverCameraFollowUnits::_internal_unit_tags() const {
  return unit_tags_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
ActionObserverCameraFollowUnits::unit_tags() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return _internal_unit_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
ActionObserverCameraFollowUnits::_internal_mutable_unit_tags() {
  return &unit_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
ActionObserverCameraFollowUnits::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return _internal_mutable_unit_tags();
}

// -------------------------------------------------------------------

// PlayerResult

// optional uint32 player_id = 1;
inline bool PlayerResult::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerResult::has_player_id() const {
  return _internal_has_player_id();
}
inline void PlayerResult::clear_player_id() {
  player_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerResult::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerResult::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerResult.player_id)
  return _internal_player_id();
}
inline void PlayerResult::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  player_id_ = value;
}
inline void PlayerResult::set_player_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerResult.player_id)
}

// optional .SC2APIProtocol.Result result = 2;
inline bool PlayerResult::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerResult::has_result() const {
  return _internal_has_result();
}
inline void PlayerResult::clear_result() {
  result_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::Result PlayerResult::_internal_result() const {
  return static_cast< ::SC2APIProtocol::Result >(result_);
}
inline ::SC2APIProtocol::Result PlayerResult::result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerResult.result)
  return _internal_result();
}
inline void PlayerResult::_internal_set_result(::SC2APIProtocol::Result value) {
  assert(::SC2APIProtocol::Result_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  result_ = value;
}
inline void PlayerResult::set_result(::SC2APIProtocol::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerResult.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SC2APIProtocol::ResponseCreateGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseCreateGame_Error>() {
  return ::SC2APIProtocol::ResponseCreateGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseJoinGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseJoinGame_Error>() {
  return ::SC2APIProtocol::ResponseJoinGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseRestartGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseRestartGame_Error>() {
  return ::SC2APIProtocol::ResponseRestartGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseStartReplay_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseStartReplay_Error>() {
  return ::SC2APIProtocol::ResponseStartReplay_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseMapCommand_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseMapCommand_Error>() {
  return ::SC2APIProtocol::ResponseMapCommand_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseReplayInfo_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseReplayInfo_Error>() {
  return ::SC2APIProtocol::ResponseReplayInfo_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseSaveMap_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseSaveMap_Error>() {
  return ::SC2APIProtocol::ResponseSaveMap_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ActionChat_Channel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ActionChat_Channel>() {
  return ::SC2APIProtocol::ActionChat_Channel_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Status>() {
  return ::SC2APIProtocol::Status_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Difficulty> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Difficulty>() {
  return ::SC2APIProtocol::Difficulty_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::PlayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::PlayerType>() {
  return ::SC2APIProtocol::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::AIBuild> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::AIBuild>() {
  return ::SC2APIProtocol::AIBuild_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Alert> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Alert>() {
  return ::SC2APIProtocol::Alert_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Result>() {
  return ::SC2APIProtocol::Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fsc2api_2eproto
