// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_s2clientprotocol_2fdata_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fdata_2eproto;
namespace SC2APIProtocol {
class AbilityData;
class AbilityDataDefaultTypeInternal;
extern AbilityDataDefaultTypeInternal _AbilityData_default_instance_;
class BuffData;
class BuffDataDefaultTypeInternal;
extern BuffDataDefaultTypeInternal _BuffData_default_instance_;
class DamageBonus;
class DamageBonusDefaultTypeInternal;
extern DamageBonusDefaultTypeInternal _DamageBonus_default_instance_;
class EffectData;
class EffectDataDefaultTypeInternal;
extern EffectDataDefaultTypeInternal _EffectData_default_instance_;
class UnitTypeData;
class UnitTypeDataDefaultTypeInternal;
extern UnitTypeDataDefaultTypeInternal _UnitTypeData_default_instance_;
class UpgradeData;
class UpgradeDataDefaultTypeInternal;
extern UpgradeDataDefaultTypeInternal _UpgradeData_default_instance_;
class Weapon;
class WeaponDefaultTypeInternal;
extern WeaponDefaultTypeInternal _Weapon_default_instance_;
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> ::SC2APIProtocol::AbilityData* Arena::CreateMaybeMessage<::SC2APIProtocol::AbilityData>(Arena*);
template<> ::SC2APIProtocol::BuffData* Arena::CreateMaybeMessage<::SC2APIProtocol::BuffData>(Arena*);
template<> ::SC2APIProtocol::DamageBonus* Arena::CreateMaybeMessage<::SC2APIProtocol::DamageBonus>(Arena*);
template<> ::SC2APIProtocol::EffectData* Arena::CreateMaybeMessage<::SC2APIProtocol::EffectData>(Arena*);
template<> ::SC2APIProtocol::UnitTypeData* Arena::CreateMaybeMessage<::SC2APIProtocol::UnitTypeData>(Arena*);
template<> ::SC2APIProtocol::UpgradeData* Arena::CreateMaybeMessage<::SC2APIProtocol::UpgradeData>(Arena*);
template<> ::SC2APIProtocol::Weapon* Arena::CreateMaybeMessage<::SC2APIProtocol::Weapon>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SC2APIProtocol {

enum AbilityData_Target : int {
  AbilityData_Target_None = 1,
  AbilityData_Target_Point = 2,
  AbilityData_Target_Unit = 3,
  AbilityData_Target_PointOrUnit = 4,
  AbilityData_Target_PointOrNone = 5
};
bool AbilityData_Target_IsValid(int value);
constexpr AbilityData_Target AbilityData_Target_Target_MIN = AbilityData_Target_None;
constexpr AbilityData_Target AbilityData_Target_Target_MAX = AbilityData_Target_PointOrNone;
constexpr int AbilityData_Target_Target_ARRAYSIZE = AbilityData_Target_Target_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbilityData_Target_descriptor();
template<typename T>
inline const std::string& AbilityData_Target_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AbilityData_Target>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AbilityData_Target_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AbilityData_Target_descriptor(), enum_t_value);
}
inline bool AbilityData_Target_Parse(
    const std::string& name, AbilityData_Target* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AbilityData_Target>(
    AbilityData_Target_descriptor(), name, value);
}
enum Weapon_TargetType : int {
  Weapon_TargetType_Ground = 1,
  Weapon_TargetType_Air = 2,
  Weapon_TargetType_Any = 3
};
bool Weapon_TargetType_IsValid(int value);
constexpr Weapon_TargetType Weapon_TargetType_TargetType_MIN = Weapon_TargetType_Ground;
constexpr Weapon_TargetType Weapon_TargetType_TargetType_MAX = Weapon_TargetType_Any;
constexpr int Weapon_TargetType_TargetType_ARRAYSIZE = Weapon_TargetType_TargetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Weapon_TargetType_descriptor();
template<typename T>
inline const std::string& Weapon_TargetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Weapon_TargetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Weapon_TargetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Weapon_TargetType_descriptor(), enum_t_value);
}
inline bool Weapon_TargetType_Parse(
    const std::string& name, Weapon_TargetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Weapon_TargetType>(
    Weapon_TargetType_descriptor(), name, value);
}
enum Attribute : int {
  Light = 1,
  Armored = 2,
  Biological = 3,
  Mechanical = 4,
  Robotic = 5,
  Psionic = 6,
  Massive = 7,
  Structure = 8,
  Hover = 9,
  Heroic = 10,
  Summoned = 11
};
bool Attribute_IsValid(int value);
constexpr Attribute Attribute_MIN = Light;
constexpr Attribute Attribute_MAX = Summoned;
constexpr int Attribute_ARRAYSIZE = Attribute_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Attribute_descriptor();
template<typename T>
inline const std::string& Attribute_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Attribute>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Attribute_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Attribute_descriptor(), enum_t_value);
}
inline bool Attribute_Parse(
    const std::string& name, Attribute* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Attribute>(
    Attribute_descriptor(), name, value);
}
// ===================================================================

class AbilityData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.AbilityData) */ {
 public:
  AbilityData();
  virtual ~AbilityData();

  AbilityData(const AbilityData& from);
  AbilityData(AbilityData&& from) noexcept
    : AbilityData() {
    *this = ::std::move(from);
  }

  inline AbilityData& operator=(const AbilityData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbilityData& operator=(AbilityData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbilityData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbilityData* internal_default_instance() {
    return reinterpret_cast<const AbilityData*>(
               &_AbilityData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AbilityData& a, AbilityData& b) {
    a.Swap(&b);
  }
  inline void Swap(AbilityData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbilityData* New() const final {
    return CreateMaybeMessage<AbilityData>(nullptr);
  }

  AbilityData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbilityData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbilityData& from);
  void MergeFrom(const AbilityData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbilityData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.AbilityData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdata_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AbilityData_Target Target;
  static constexpr Target None =
    AbilityData_Target_None;
  static constexpr Target Point =
    AbilityData_Target_Point;
  static constexpr Target Unit =
    AbilityData_Target_Unit;
  static constexpr Target PointOrUnit =
    AbilityData_Target_PointOrUnit;
  static constexpr Target PointOrNone =
    AbilityData_Target_PointOrNone;
  static inline bool Target_IsValid(int value) {
    return AbilityData_Target_IsValid(value);
  }
  static constexpr Target Target_MIN =
    AbilityData_Target_Target_MIN;
  static constexpr Target Target_MAX =
    AbilityData_Target_Target_MAX;
  static constexpr int Target_ARRAYSIZE =
    AbilityData_Target_Target_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Target_descriptor() {
    return AbilityData_Target_descriptor();
  }
  template<typename T>
  static inline const std::string& Target_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Target>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Target_Name.");
    return AbilityData_Target_Name(enum_t_value);
  }
  static inline bool Target_Parse(const std::string& name,
      Target* value) {
    return AbilityData_Target_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLinkNameFieldNumber = 2,
    kButtonNameFieldNumber = 4,
    kFriendlyNameFieldNumber = 5,
    kHotkeyFieldNumber = 6,
    kAbilityIdFieldNumber = 1,
    kLinkIndexFieldNumber = 3,
    kRemapsToAbilityIdFieldNumber = 7,
    kAvailableFieldNumber = 8,
    kAllowMinimapFieldNumber = 10,
    kAllowAutocastFieldNumber = 11,
    kIsBuildingFieldNumber = 12,
    kFootprintRadiusFieldNumber = 13,
    kIsInstantPlacementFieldNumber = 14,
    kCastRangeFieldNumber = 15,
    kTargetFieldNumber = 9,
  };
  // optional string link_name = 2;
  bool has_link_name() const;
  private:
  bool _internal_has_link_name() const;
  public:
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // optional string button_name = 4;
  bool has_button_name() const;
  private:
  bool _internal_has_button_name() const;
  public:
  void clear_button_name();
  const std::string& button_name() const;
  void set_button_name(const std::string& value);
  void set_button_name(std::string&& value);
  void set_button_name(const char* value);
  void set_button_name(const char* value, size_t size);
  std::string* mutable_button_name();
  std::string* release_button_name();
  void set_allocated_button_name(std::string* button_name);
  private:
  const std::string& _internal_button_name() const;
  void _internal_set_button_name(const std::string& value);
  std::string* _internal_mutable_button_name();
  public:

  // optional string friendly_name = 5;
  bool has_friendly_name() const;
  private:
  bool _internal_has_friendly_name() const;
  public:
  void clear_friendly_name();
  const std::string& friendly_name() const;
  void set_friendly_name(const std::string& value);
  void set_friendly_name(std::string&& value);
  void set_friendly_name(const char* value);
  void set_friendly_name(const char* value, size_t size);
  std::string* mutable_friendly_name();
  std::string* release_friendly_name();
  void set_allocated_friendly_name(std::string* friendly_name);
  private:
  const std::string& _internal_friendly_name() const;
  void _internal_set_friendly_name(const std::string& value);
  std::string* _internal_mutable_friendly_name();
  public:

  // optional string hotkey = 6;
  bool has_hotkey() const;
  private:
  bool _internal_has_hotkey() const;
  public:
  void clear_hotkey();
  const std::string& hotkey() const;
  void set_hotkey(const std::string& value);
  void set_hotkey(std::string&& value);
  void set_hotkey(const char* value);
  void set_hotkey(const char* value, size_t size);
  std::string* mutable_hotkey();
  std::string* release_hotkey();
  void set_allocated_hotkey(std::string* hotkey);
  private:
  const std::string& _internal_hotkey() const;
  void _internal_set_hotkey(const std::string& value);
  std::string* _internal_mutable_hotkey();
  public:

  // optional uint32 ability_id = 1;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 ability_id() const;
  void set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ability_id() const;
  void _internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 link_index = 3;
  bool has_link_index() const;
  private:
  bool _internal_has_link_index() const;
  public:
  void clear_link_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 link_index() const;
  void set_link_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_link_index() const;
  void _internal_set_link_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 remaps_to_ability_id = 7;
  bool has_remaps_to_ability_id() const;
  private:
  bool _internal_has_remaps_to_ability_id() const;
  public:
  void clear_remaps_to_ability_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 remaps_to_ability_id() const;
  void set_remaps_to_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_remaps_to_ability_id() const;
  void _internal_set_remaps_to_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool available = 8;
  bool has_available() const;
  private:
  bool _internal_has_available() const;
  public:
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // optional bool allow_minimap = 10;
  bool has_allow_minimap() const;
  private:
  bool _internal_has_allow_minimap() const;
  public:
  void clear_allow_minimap();
  bool allow_minimap() const;
  void set_allow_minimap(bool value);
  private:
  bool _internal_allow_minimap() const;
  void _internal_set_allow_minimap(bool value);
  public:

  // optional bool allow_autocast = 11;
  bool has_allow_autocast() const;
  private:
  bool _internal_has_allow_autocast() const;
  public:
  void clear_allow_autocast();
  bool allow_autocast() const;
  void set_allow_autocast(bool value);
  private:
  bool _internal_allow_autocast() const;
  void _internal_set_allow_autocast(bool value);
  public:

  // optional bool is_building = 12;
  bool has_is_building() const;
  private:
  bool _internal_has_is_building() const;
  public:
  void clear_is_building();
  bool is_building() const;
  void set_is_building(bool value);
  private:
  bool _internal_is_building() const;
  void _internal_set_is_building(bool value);
  public:

  // optional float footprint_radius = 13;
  bool has_footprint_radius() const;
  private:
  bool _internal_has_footprint_radius() const;
  public:
  void clear_footprint_radius();
  float footprint_radius() const;
  void set_footprint_radius(float value);
  private:
  float _internal_footprint_radius() const;
  void _internal_set_footprint_radius(float value);
  public:

  // optional bool is_instant_placement = 14;
  bool has_is_instant_placement() const;
  private:
  bool _internal_has_is_instant_placement() const;
  public:
  void clear_is_instant_placement();
  bool is_instant_placement() const;
  void set_is_instant_placement(bool value);
  private:
  bool _internal_is_instant_placement() const;
  void _internal_set_is_instant_placement(bool value);
  public:

  // optional float cast_range = 15;
  bool has_cast_range() const;
  private:
  bool _internal_has_cast_range() const;
  public:
  void clear_cast_range();
  float cast_range() const;
  void set_cast_range(float value);
  private:
  float _internal_cast_range() const;
  void _internal_set_cast_range(float value);
  public:

  // optional .SC2APIProtocol.AbilityData.Target target = 9;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  ::SC2APIProtocol::AbilityData_Target target() const;
  void set_target(::SC2APIProtocol::AbilityData_Target value);
  private:
  ::SC2APIProtocol::AbilityData_Target _internal_target() const;
  void _internal_set_target(::SC2APIProtocol::AbilityData_Target value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.AbilityData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr button_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friendly_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hotkey_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ability_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 link_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 remaps_to_ability_id_;
  bool available_;
  bool allow_minimap_;
  bool allow_autocast_;
  bool is_building_;
  float footprint_radius_;
  bool is_instant_placement_;
  float cast_range_;
  int target_;
  friend struct ::TableStruct_s2clientprotocol_2fdata_2eproto;
};
// -------------------------------------------------------------------

class DamageBonus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.DamageBonus) */ {
 public:
  DamageBonus();
  virtual ~DamageBonus();

  DamageBonus(const DamageBonus& from);
  DamageBonus(DamageBonus&& from) noexcept
    : DamageBonus() {
    *this = ::std::move(from);
  }

  inline DamageBonus& operator=(const DamageBonus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageBonus& operator=(DamageBonus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DamageBonus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DamageBonus* internal_default_instance() {
    return reinterpret_cast<const DamageBonus*>(
               &_DamageBonus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DamageBonus& a, DamageBonus& b) {
    a.Swap(&b);
  }
  inline void Swap(DamageBonus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DamageBonus* New() const final {
    return CreateMaybeMessage<DamageBonus>(nullptr);
  }

  DamageBonus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DamageBonus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DamageBonus& from);
  void MergeFrom(const DamageBonus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DamageBonus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.DamageBonus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdata_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBonusFieldNumber = 2,
    kAttributeFieldNumber = 1,
  };
  // optional float bonus = 2;
  bool has_bonus() const;
  private:
  bool _internal_has_bonus() const;
  public:
  void clear_bonus();
  float bonus() const;
  void set_bonus(float value);
  private:
  float _internal_bonus() const;
  void _internal_set_bonus(float value);
  public:

  // optional .SC2APIProtocol.Attribute attribute = 1;
  bool has_attribute() const;
  private:
  bool _internal_has_attribute() const;
  public:
  void clear_attribute();
  ::SC2APIProtocol::Attribute attribute() const;
  void set_attribute(::SC2APIProtocol::Attribute value);
  private:
  ::SC2APIProtocol::Attribute _internal_attribute() const;
  void _internal_set_attribute(::SC2APIProtocol::Attribute value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.DamageBonus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float bonus_;
  int attribute_;
  friend struct ::TableStruct_s2clientprotocol_2fdata_2eproto;
};
// -------------------------------------------------------------------

class Weapon :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Weapon) */ {
 public:
  Weapon();
  virtual ~Weapon();

  Weapon(const Weapon& from);
  Weapon(Weapon&& from) noexcept
    : Weapon() {
    *this = ::std::move(from);
  }

  inline Weapon& operator=(const Weapon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Weapon& operator=(Weapon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Weapon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Weapon* internal_default_instance() {
    return reinterpret_cast<const Weapon*>(
               &_Weapon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Weapon& a, Weapon& b) {
    a.Swap(&b);
  }
  inline void Swap(Weapon* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Weapon* New() const final {
    return CreateMaybeMessage<Weapon>(nullptr);
  }

  Weapon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Weapon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Weapon& from);
  void MergeFrom(const Weapon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Weapon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.Weapon";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdata_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Weapon_TargetType TargetType;
  static constexpr TargetType Ground =
    Weapon_TargetType_Ground;
  static constexpr TargetType Air =
    Weapon_TargetType_Air;
  static constexpr TargetType Any =
    Weapon_TargetType_Any;
  static inline bool TargetType_IsValid(int value) {
    return Weapon_TargetType_IsValid(value);
  }
  static constexpr TargetType TargetType_MIN =
    Weapon_TargetType_TargetType_MIN;
  static constexpr TargetType TargetType_MAX =
    Weapon_TargetType_TargetType_MAX;
  static constexpr int TargetType_ARRAYSIZE =
    Weapon_TargetType_TargetType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TargetType_descriptor() {
    return Weapon_TargetType_descriptor();
  }
  template<typename T>
  static inline const std::string& TargetType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TargetType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TargetType_Name.");
    return Weapon_TargetType_Name(enum_t_value);
  }
  static inline bool TargetType_Parse(const std::string& name,
      TargetType* value) {
    return Weapon_TargetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDamageBonusFieldNumber = 3,
    kDamageFieldNumber = 2,
    kAttacksFieldNumber = 4,
    kRangeFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
  int damage_bonus_size() const;
  private:
  int _internal_damage_bonus_size() const;
  public:
  void clear_damage_bonus();
  ::SC2APIProtocol::DamageBonus* mutable_damage_bonus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DamageBonus >*
      mutable_damage_bonus();
  private:
  const ::SC2APIProtocol::DamageBonus& _internal_damage_bonus(int index) const;
  ::SC2APIProtocol::DamageBonus* _internal_add_damage_bonus();
  public:
  const ::SC2APIProtocol::DamageBonus& damage_bonus(int index) const;
  ::SC2APIProtocol::DamageBonus* add_damage_bonus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DamageBonus >&
      damage_bonus() const;

  // optional float damage = 2;
  bool has_damage() const;
  private:
  bool _internal_has_damage() const;
  public:
  void clear_damage();
  float damage() const;
  void set_damage(float value);
  private:
  float _internal_damage() const;
  void _internal_set_damage(float value);
  public:

  // optional uint32 attacks = 4;
  bool has_attacks() const;
  private:
  bool _internal_has_attacks() const;
  public:
  void clear_attacks();
  ::PROTOBUF_NAMESPACE_ID::uint32 attacks() const;
  void set_attacks(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_attacks() const;
  void _internal_set_attacks(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float range = 5;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  float range() const;
  void set_range(float value);
  private:
  float _internal_range() const;
  void _internal_set_range(float value);
  public:

  // optional float speed = 6;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // optional .SC2APIProtocol.Weapon.TargetType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::SC2APIProtocol::Weapon_TargetType type() const;
  void set_type(::SC2APIProtocol::Weapon_TargetType value);
  private:
  ::SC2APIProtocol::Weapon_TargetType _internal_type() const;
  void _internal_set_type(::SC2APIProtocol::Weapon_TargetType value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Weapon)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DamageBonus > damage_bonus_;
  float damage_;
  ::PROTOBUF_NAMESPACE_ID::uint32 attacks_;
  float range_;
  float speed_;
  int type_;
  friend struct ::TableStruct_s2clientprotocol_2fdata_2eproto;
};
// -------------------------------------------------------------------

class UnitTypeData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.UnitTypeData) */ {
 public:
  UnitTypeData();
  virtual ~UnitTypeData();

  UnitTypeData(const UnitTypeData& from);
  UnitTypeData(UnitTypeData&& from) noexcept
    : UnitTypeData() {
    *this = ::std::move(from);
  }

  inline UnitTypeData& operator=(const UnitTypeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnitTypeData& operator=(UnitTypeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnitTypeData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitTypeData* internal_default_instance() {
    return reinterpret_cast<const UnitTypeData*>(
               &_UnitTypeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UnitTypeData& a, UnitTypeData& b) {
    a.Swap(&b);
  }
  inline void Swap(UnitTypeData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnitTypeData* New() const final {
    return CreateMaybeMessage<UnitTypeData>(nullptr);
  }

  UnitTypeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnitTypeData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnitTypeData& from);
  void MergeFrom(const UnitTypeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitTypeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.UnitTypeData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdata_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 8,
    kWeaponsFieldNumber = 11,
    kTechAliasFieldNumber = 21,
    kNameFieldNumber = 2,
    kUnitIdFieldNumber = 1,
    kCargoSizeFieldNumber = 4,
    kMovementSpeedFieldNumber = 9,
    kArmorFieldNumber = 10,
    kMineralCostFieldNumber = 12,
    kVespeneCostFieldNumber = 13,
    kFoodRequiredFieldNumber = 14,
    kAbilityIdFieldNumber = 15,
    kRaceFieldNumber = 16,
    kAvailableFieldNumber = 3,
    kHasVespeneFieldNumber = 19,
    kHasMineralsFieldNumber = 20,
    kRequireAttachedFieldNumber = 24,
    kBuildTimeFieldNumber = 17,
    kFoodProvidedFieldNumber = 18,
    kUnitAliasFieldNumber = 22,
    kTechRequirementFieldNumber = 23,
    kSightRangeFieldNumber = 25,
  };
  // repeated .SC2APIProtocol.Attribute attributes = 8;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  ::SC2APIProtocol::Attribute _internal_attributes(int index) const;
  void _internal_add_attributes(::SC2APIProtocol::Attribute value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_attributes();
  public:
  ::SC2APIProtocol::Attribute attributes(int index) const;
  void set_attributes(int index, ::SC2APIProtocol::Attribute value);
  void add_attributes(::SC2APIProtocol::Attribute value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_attributes();

  // repeated .SC2APIProtocol.Weapon weapons = 11;
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;
  public:
  void clear_weapons();
  ::SC2APIProtocol::Weapon* mutable_weapons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Weapon >*
      mutable_weapons();
  private:
  const ::SC2APIProtocol::Weapon& _internal_weapons(int index) const;
  ::SC2APIProtocol::Weapon* _internal_add_weapons();
  public:
  const ::SC2APIProtocol::Weapon& weapons(int index) const;
  ::SC2APIProtocol::Weapon* add_weapons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Weapon >&
      weapons() const;

  // repeated uint32 tech_alias = 21;
  int tech_alias_size() const;
  private:
  int _internal_tech_alias_size() const;
  public:
  void clear_tech_alias();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tech_alias(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_tech_alias() const;
  void _internal_add_tech_alias(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_tech_alias();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 tech_alias(int index) const;
  void set_tech_alias(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_tech_alias(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      tech_alias() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_tech_alias();

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 unit_id = 1;
  bool has_unit_id() const;
  private:
  bool _internal_has_unit_id() const;
  public:
  void clear_unit_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 unit_id() const;
  void set_unit_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unit_id() const;
  void _internal_set_unit_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 cargo_size = 4;
  bool has_cargo_size() const;
  private:
  bool _internal_has_cargo_size() const;
  public:
  void clear_cargo_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 cargo_size() const;
  void set_cargo_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cargo_size() const;
  void _internal_set_cargo_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float movement_speed = 9;
  bool has_movement_speed() const;
  private:
  bool _internal_has_movement_speed() const;
  public:
  void clear_movement_speed();
  float movement_speed() const;
  void set_movement_speed(float value);
  private:
  float _internal_movement_speed() const;
  void _internal_set_movement_speed(float value);
  public:

  // optional float armor = 10;
  bool has_armor() const;
  private:
  bool _internal_has_armor() const;
  public:
  void clear_armor();
  float armor() const;
  void set_armor(float value);
  private:
  float _internal_armor() const;
  void _internal_set_armor(float value);
  public:

  // optional uint32 mineral_cost = 12;
  bool has_mineral_cost() const;
  private:
  bool _internal_has_mineral_cost() const;
  public:
  void clear_mineral_cost();
  ::PROTOBUF_NAMESPACE_ID::uint32 mineral_cost() const;
  void set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mineral_cost() const;
  void _internal_set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 vespene_cost = 13;
  bool has_vespene_cost() const;
  private:
  bool _internal_has_vespene_cost() const;
  public:
  void clear_vespene_cost();
  ::PROTOBUF_NAMESPACE_ID::uint32 vespene_cost() const;
  void set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_vespene_cost() const;
  void _internal_set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float food_required = 14;
  bool has_food_required() const;
  private:
  bool _internal_has_food_required() const;
  public:
  void clear_food_required();
  float food_required() const;
  void set_food_required(float value);
  private:
  float _internal_food_required() const;
  void _internal_set_food_required(float value);
  public:

  // optional uint32 ability_id = 15;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 ability_id() const;
  void set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ability_id() const;
  void _internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .SC2APIProtocol.Race race = 16;
  bool has_race() const;
  private:
  bool _internal_has_race() const;
  public:
  void clear_race();
  ::SC2APIProtocol::Race race() const;
  void set_race(::SC2APIProtocol::Race value);
  private:
  ::SC2APIProtocol::Race _internal_race() const;
  void _internal_set_race(::SC2APIProtocol::Race value);
  public:

  // optional bool available = 3;
  bool has_available() const;
  private:
  bool _internal_has_available() const;
  public:
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // optional bool has_vespene = 19;
  bool has_has_vespene() const;
  private:
  bool _internal_has_has_vespene() const;
  public:
  void clear_has_vespene();
  bool has_vespene() const;
  void set_has_vespene(bool value);
  private:
  bool _internal_has_vespene() const;
  void _internal_set_has_vespene(bool value);
  public:

  // optional bool has_minerals = 20;
  bool has_has_minerals() const;
  private:
  bool _internal_has_has_minerals() const;
  public:
  void clear_has_minerals();
  bool has_minerals() const;
  void set_has_minerals(bool value);
  private:
  bool _internal_has_minerals() const;
  void _internal_set_has_minerals(bool value);
  public:

  // optional bool require_attached = 24;
  bool has_require_attached() const;
  private:
  bool _internal_has_require_attached() const;
  public:
  void clear_require_attached();
  bool require_attached() const;
  void set_require_attached(bool value);
  private:
  bool _internal_require_attached() const;
  void _internal_set_require_attached(bool value);
  public:

  // optional float build_time = 17;
  bool has_build_time() const;
  private:
  bool _internal_has_build_time() const;
  public:
  void clear_build_time();
  float build_time() const;
  void set_build_time(float value);
  private:
  float _internal_build_time() const;
  void _internal_set_build_time(float value);
  public:

  // optional float food_provided = 18;
  bool has_food_provided() const;
  private:
  bool _internal_has_food_provided() const;
  public:
  void clear_food_provided();
  float food_provided() const;
  void set_food_provided(float value);
  private:
  float _internal_food_provided() const;
  void _internal_set_food_provided(float value);
  public:

  // optional uint32 unit_alias = 22;
  bool has_unit_alias() const;
  private:
  bool _internal_has_unit_alias() const;
  public:
  void clear_unit_alias();
  ::PROTOBUF_NAMESPACE_ID::uint32 unit_alias() const;
  void set_unit_alias(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unit_alias() const;
  void _internal_set_unit_alias(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 tech_requirement = 23;
  bool has_tech_requirement() const;
  private:
  bool _internal_has_tech_requirement() const;
  public:
  void clear_tech_requirement();
  ::PROTOBUF_NAMESPACE_ID::uint32 tech_requirement() const;
  void set_tech_requirement(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tech_requirement() const;
  void _internal_set_tech_requirement(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float sight_range = 25;
  bool has_sight_range() const;
  private:
  bool _internal_has_sight_range() const;
  public:
  void clear_sight_range();
  float sight_range() const;
  void set_sight_range(float value);
  private:
  float _internal_sight_range() const;
  void _internal_set_sight_range(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.UnitTypeData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> attributes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Weapon > weapons_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > tech_alias_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unit_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cargo_size_;
  float movement_speed_;
  float armor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mineral_cost_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vespene_cost_;
  float food_required_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ability_id_;
  int race_;
  bool available_;
  bool has_vespene_;
  bool has_minerals_;
  bool require_attached_;
  float build_time_;
  float food_provided_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unit_alias_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tech_requirement_;
  float sight_range_;
  friend struct ::TableStruct_s2clientprotocol_2fdata_2eproto;
};
// -------------------------------------------------------------------

class UpgradeData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.UpgradeData) */ {
 public:
  UpgradeData();
  virtual ~UpgradeData();

  UpgradeData(const UpgradeData& from);
  UpgradeData(UpgradeData&& from) noexcept
    : UpgradeData() {
    *this = ::std::move(from);
  }

  inline UpgradeData& operator=(const UpgradeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpgradeData& operator=(UpgradeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpgradeData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpgradeData* internal_default_instance() {
    return reinterpret_cast<const UpgradeData*>(
               &_UpgradeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpgradeData& a, UpgradeData& b) {
    a.Swap(&b);
  }
  inline void Swap(UpgradeData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpgradeData* New() const final {
    return CreateMaybeMessage<UpgradeData>(nullptr);
  }

  UpgradeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpgradeData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpgradeData& from);
  void MergeFrom(const UpgradeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpgradeData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.UpgradeData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdata_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kUpgradeIdFieldNumber = 1,
    kMineralCostFieldNumber = 3,
    kVespeneCostFieldNumber = 4,
    kResearchTimeFieldNumber = 5,
    kAbilityIdFieldNumber = 6,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 upgrade_id = 1;
  bool has_upgrade_id() const;
  private:
  bool _internal_has_upgrade_id() const;
  public:
  void clear_upgrade_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 upgrade_id() const;
  void set_upgrade_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_upgrade_id() const;
  void _internal_set_upgrade_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 mineral_cost = 3;
  bool has_mineral_cost() const;
  private:
  bool _internal_has_mineral_cost() const;
  public:
  void clear_mineral_cost();
  ::PROTOBUF_NAMESPACE_ID::uint32 mineral_cost() const;
  void set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mineral_cost() const;
  void _internal_set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 vespene_cost = 4;
  bool has_vespene_cost() const;
  private:
  bool _internal_has_vespene_cost() const;
  public:
  void clear_vespene_cost();
  ::PROTOBUF_NAMESPACE_ID::uint32 vespene_cost() const;
  void set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_vespene_cost() const;
  void _internal_set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float research_time = 5;
  bool has_research_time() const;
  private:
  bool _internal_has_research_time() const;
  public:
  void clear_research_time();
  float research_time() const;
  void set_research_time(float value);
  private:
  float _internal_research_time() const;
  void _internal_set_research_time(float value);
  public:

  // optional uint32 ability_id = 6;
  bool has_ability_id() const;
  private:
  bool _internal_has_ability_id() const;
  public:
  void clear_ability_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 ability_id() const;
  void set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ability_id() const;
  void _internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.UpgradeData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 upgrade_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mineral_cost_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vespene_cost_;
  float research_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ability_id_;
  friend struct ::TableStruct_s2clientprotocol_2fdata_2eproto;
};
// -------------------------------------------------------------------

class BuffData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.BuffData) */ {
 public:
  BuffData();
  virtual ~BuffData();

  BuffData(const BuffData& from);
  BuffData(BuffData&& from) noexcept
    : BuffData() {
    *this = ::std::move(from);
  }

  inline BuffData& operator=(const BuffData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuffData& operator=(BuffData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuffData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuffData* internal_default_instance() {
    return reinterpret_cast<const BuffData*>(
               &_BuffData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BuffData& a, BuffData& b) {
    a.Swap(&b);
  }
  inline void Swap(BuffData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BuffData* New() const final {
    return CreateMaybeMessage<BuffData>(nullptr);
  }

  BuffData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuffData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuffData& from);
  void MergeFrom(const BuffData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuffData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.BuffData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdata_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kBuffIdFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 buff_id = 1;
  bool has_buff_id() const;
  private:
  bool _internal_has_buff_id() const;
  public:
  void clear_buff_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 buff_id() const;
  void set_buff_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_buff_id() const;
  void _internal_set_buff_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.BuffData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 buff_id_;
  friend struct ::TableStruct_s2clientprotocol_2fdata_2eproto;
};
// -------------------------------------------------------------------

class EffectData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.EffectData) */ {
 public:
  EffectData();
  virtual ~EffectData();

  EffectData(const EffectData& from);
  EffectData(EffectData&& from) noexcept
    : EffectData() {
    *this = ::std::move(from);
  }

  inline EffectData& operator=(const EffectData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EffectData& operator=(EffectData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EffectData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EffectData* internal_default_instance() {
    return reinterpret_cast<const EffectData*>(
               &_EffectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EffectData& a, EffectData& b) {
    a.Swap(&b);
  }
  inline void Swap(EffectData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EffectData* New() const final {
    return CreateMaybeMessage<EffectData>(nullptr);
  }

  EffectData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EffectData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EffectData& from);
  void MergeFrom(const EffectData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EffectData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SC2APIProtocol.EffectData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_s2clientprotocol_2fdata_2eproto);
    return ::descriptor_table_s2clientprotocol_2fdata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kFriendlyNameFieldNumber = 3,
    kEffectIdFieldNumber = 1,
    kRadiusFieldNumber = 4,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string friendly_name = 3;
  bool has_friendly_name() const;
  private:
  bool _internal_has_friendly_name() const;
  public:
  void clear_friendly_name();
  const std::string& friendly_name() const;
  void set_friendly_name(const std::string& value);
  void set_friendly_name(std::string&& value);
  void set_friendly_name(const char* value);
  void set_friendly_name(const char* value, size_t size);
  std::string* mutable_friendly_name();
  std::string* release_friendly_name();
  void set_allocated_friendly_name(std::string* friendly_name);
  private:
  const std::string& _internal_friendly_name() const;
  void _internal_set_friendly_name(const std::string& value);
  std::string* _internal_mutable_friendly_name();
  public:

  // optional uint32 effect_id = 1;
  bool has_effect_id() const;
  private:
  bool _internal_has_effect_id() const;
  public:
  void clear_effect_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 effect_id() const;
  void set_effect_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_effect_id() const;
  void _internal_set_effect_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float radius = 4;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.EffectData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friendly_name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 effect_id_;
  float radius_;
  friend struct ::TableStruct_s2clientprotocol_2fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AbilityData

// optional uint32 ability_id = 1;
inline bool AbilityData::_internal_has_ability_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AbilityData::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void AbilityData::clear_ability_id() {
  ability_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbilityData::_internal_ability_id() const {
  return ability_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbilityData::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.ability_id)
  return _internal_ability_id();
}
inline void AbilityData::_internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  ability_id_ = value;
}
inline void AbilityData::set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.ability_id)
}

// optional string link_name = 2;
inline bool AbilityData::_internal_has_link_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AbilityData::has_link_name() const {
  return _internal_has_link_name();
}
inline void AbilityData::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AbilityData::link_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.link_name)
  return _internal_link_name();
}
inline void AbilityData::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.link_name)
}
inline std::string* AbilityData::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.AbilityData.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& AbilityData::_internal_link_name() const {
  return link_name_.GetNoArena();
}
inline void AbilityData::_internal_set_link_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  link_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AbilityData::set_link_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  link_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.AbilityData.link_name)
}
inline void AbilityData::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  link_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.AbilityData.link_name)
}
inline void AbilityData::set_link_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  link_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.AbilityData.link_name)
}
inline std::string* AbilityData::_internal_mutable_link_name() {
  _has_bits_[0] |= 0x00000001u;
  return link_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AbilityData::release_link_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.AbilityData.link_name)
  if (!_internal_has_link_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return link_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  link_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.AbilityData.link_name)
}

// optional uint32 link_index = 3;
inline bool AbilityData::_internal_has_link_index() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AbilityData::has_link_index() const {
  return _internal_has_link_index();
}
inline void AbilityData::clear_link_index() {
  link_index_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbilityData::_internal_link_index() const {
  return link_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbilityData::link_index() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.link_index)
  return _internal_link_index();
}
inline void AbilityData::_internal_set_link_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  link_index_ = value;
}
inline void AbilityData::set_link_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_link_index(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.link_index)
}

// optional string button_name = 4;
inline bool AbilityData::_internal_has_button_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AbilityData::has_button_name() const {
  return _internal_has_button_name();
}
inline void AbilityData::clear_button_name() {
  button_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AbilityData::button_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.button_name)
  return _internal_button_name();
}
inline void AbilityData::set_button_name(const std::string& value) {
  _internal_set_button_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.button_name)
}
inline std::string* AbilityData::mutable_button_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.AbilityData.button_name)
  return _internal_mutable_button_name();
}
inline const std::string& AbilityData::_internal_button_name() const {
  return button_name_.GetNoArena();
}
inline void AbilityData::_internal_set_button_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  button_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AbilityData::set_button_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  button_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.AbilityData.button_name)
}
inline void AbilityData::set_button_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  button_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.AbilityData.button_name)
}
inline void AbilityData::set_button_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  button_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.AbilityData.button_name)
}
inline std::string* AbilityData::_internal_mutable_button_name() {
  _has_bits_[0] |= 0x00000002u;
  return button_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AbilityData::release_button_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.AbilityData.button_name)
  if (!_internal_has_button_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return button_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_button_name(std::string* button_name) {
  if (button_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  button_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), button_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.AbilityData.button_name)
}

// optional string friendly_name = 5;
inline bool AbilityData::_internal_has_friendly_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AbilityData::has_friendly_name() const {
  return _internal_has_friendly_name();
}
inline void AbilityData::clear_friendly_name() {
  friendly_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AbilityData::friendly_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.friendly_name)
  return _internal_friendly_name();
}
inline void AbilityData::set_friendly_name(const std::string& value) {
  _internal_set_friendly_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.friendly_name)
}
inline std::string* AbilityData::mutable_friendly_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.AbilityData.friendly_name)
  return _internal_mutable_friendly_name();
}
inline const std::string& AbilityData::_internal_friendly_name() const {
  return friendly_name_.GetNoArena();
}
inline void AbilityData::_internal_set_friendly_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  friendly_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AbilityData::set_friendly_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  friendly_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.AbilityData.friendly_name)
}
inline void AbilityData::set_friendly_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  friendly_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.AbilityData.friendly_name)
}
inline void AbilityData::set_friendly_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  friendly_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.AbilityData.friendly_name)
}
inline std::string* AbilityData::_internal_mutable_friendly_name() {
  _has_bits_[0] |= 0x00000004u;
  return friendly_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AbilityData::release_friendly_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.AbilityData.friendly_name)
  if (!_internal_has_friendly_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return friendly_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_friendly_name(std::string* friendly_name) {
  if (friendly_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  friendly_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), friendly_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.AbilityData.friendly_name)
}

// optional string hotkey = 6;
inline bool AbilityData::_internal_has_hotkey() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AbilityData::has_hotkey() const {
  return _internal_has_hotkey();
}
inline void AbilityData::clear_hotkey() {
  hotkey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AbilityData::hotkey() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.hotkey)
  return _internal_hotkey();
}
inline void AbilityData::set_hotkey(const std::string& value) {
  _internal_set_hotkey(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.hotkey)
}
inline std::string* AbilityData::mutable_hotkey() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.AbilityData.hotkey)
  return _internal_mutable_hotkey();
}
inline const std::string& AbilityData::_internal_hotkey() const {
  return hotkey_.GetNoArena();
}
inline void AbilityData::_internal_set_hotkey(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  hotkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AbilityData::set_hotkey(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  hotkey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.AbilityData.hotkey)
}
inline void AbilityData::set_hotkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  hotkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.AbilityData.hotkey)
}
inline void AbilityData::set_hotkey(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  hotkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.AbilityData.hotkey)
}
inline std::string* AbilityData::_internal_mutable_hotkey() {
  _has_bits_[0] |= 0x00000008u;
  return hotkey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AbilityData::release_hotkey() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.AbilityData.hotkey)
  if (!_internal_has_hotkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return hotkey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AbilityData::set_allocated_hotkey(std::string* hotkey) {
  if (hotkey != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hotkey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hotkey);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.AbilityData.hotkey)
}

// optional uint32 remaps_to_ability_id = 7;
inline bool AbilityData::_internal_has_remaps_to_ability_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AbilityData::has_remaps_to_ability_id() const {
  return _internal_has_remaps_to_ability_id();
}
inline void AbilityData::clear_remaps_to_ability_id() {
  remaps_to_ability_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbilityData::_internal_remaps_to_ability_id() const {
  return remaps_to_ability_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbilityData::remaps_to_ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.remaps_to_ability_id)
  return _internal_remaps_to_ability_id();
}
inline void AbilityData::_internal_set_remaps_to_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  remaps_to_ability_id_ = value;
}
inline void AbilityData::set_remaps_to_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_remaps_to_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.remaps_to_ability_id)
}

// optional bool available = 8;
inline bool AbilityData::_internal_has_available() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AbilityData::has_available() const {
  return _internal_has_available();
}
inline void AbilityData::clear_available() {
  available_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool AbilityData::_internal_available() const {
  return available_;
}
inline bool AbilityData::available() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.available)
  return _internal_available();
}
inline void AbilityData::_internal_set_available(bool value) {
  _has_bits_[0] |= 0x00000080u;
  available_ = value;
}
inline void AbilityData::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.available)
}

// optional .SC2APIProtocol.AbilityData.Target target = 9;
inline bool AbilityData::_internal_has_target() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool AbilityData::has_target() const {
  return _internal_has_target();
}
inline void AbilityData::clear_target() {
  target_ = 1;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::SC2APIProtocol::AbilityData_Target AbilityData::_internal_target() const {
  return static_cast< ::SC2APIProtocol::AbilityData_Target >(target_);
}
inline ::SC2APIProtocol::AbilityData_Target AbilityData::target() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.target)
  return _internal_target();
}
inline void AbilityData::_internal_set_target(::SC2APIProtocol::AbilityData_Target value) {
  assert(::SC2APIProtocol::AbilityData_Target_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  target_ = value;
}
inline void AbilityData::set_target(::SC2APIProtocol::AbilityData_Target value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.target)
}

// optional bool allow_minimap = 10;
inline bool AbilityData::_internal_has_allow_minimap() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AbilityData::has_allow_minimap() const {
  return _internal_has_allow_minimap();
}
inline void AbilityData::clear_allow_minimap() {
  allow_minimap_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool AbilityData::_internal_allow_minimap() const {
  return allow_minimap_;
}
inline bool AbilityData::allow_minimap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.allow_minimap)
  return _internal_allow_minimap();
}
inline void AbilityData::_internal_set_allow_minimap(bool value) {
  _has_bits_[0] |= 0x00000100u;
  allow_minimap_ = value;
}
inline void AbilityData::set_allow_minimap(bool value) {
  _internal_set_allow_minimap(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.allow_minimap)
}

// optional bool allow_autocast = 11;
inline bool AbilityData::_internal_has_allow_autocast() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AbilityData::has_allow_autocast() const {
  return _internal_has_allow_autocast();
}
inline void AbilityData::clear_allow_autocast() {
  allow_autocast_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool AbilityData::_internal_allow_autocast() const {
  return allow_autocast_;
}
inline bool AbilityData::allow_autocast() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.allow_autocast)
  return _internal_allow_autocast();
}
inline void AbilityData::_internal_set_allow_autocast(bool value) {
  _has_bits_[0] |= 0x00000200u;
  allow_autocast_ = value;
}
inline void AbilityData::set_allow_autocast(bool value) {
  _internal_set_allow_autocast(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.allow_autocast)
}

// optional bool is_building = 12;
inline bool AbilityData::_internal_has_is_building() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AbilityData::has_is_building() const {
  return _internal_has_is_building();
}
inline void AbilityData::clear_is_building() {
  is_building_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool AbilityData::_internal_is_building() const {
  return is_building_;
}
inline bool AbilityData::is_building() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.is_building)
  return _internal_is_building();
}
inline void AbilityData::_internal_set_is_building(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_building_ = value;
}
inline void AbilityData::set_is_building(bool value) {
  _internal_set_is_building(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.is_building)
}

// optional float footprint_radius = 13;
inline bool AbilityData::_internal_has_footprint_radius() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AbilityData::has_footprint_radius() const {
  return _internal_has_footprint_radius();
}
inline void AbilityData::clear_footprint_radius() {
  footprint_radius_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float AbilityData::_internal_footprint_radius() const {
  return footprint_radius_;
}
inline float AbilityData::footprint_radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.footprint_radius)
  return _internal_footprint_radius();
}
inline void AbilityData::_internal_set_footprint_radius(float value) {
  _has_bits_[0] |= 0x00000800u;
  footprint_radius_ = value;
}
inline void AbilityData::set_footprint_radius(float value) {
  _internal_set_footprint_radius(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.footprint_radius)
}

// optional bool is_instant_placement = 14;
inline bool AbilityData::_internal_has_is_instant_placement() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool AbilityData::has_is_instant_placement() const {
  return _internal_has_is_instant_placement();
}
inline void AbilityData::clear_is_instant_placement() {
  is_instant_placement_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool AbilityData::_internal_is_instant_placement() const {
  return is_instant_placement_;
}
inline bool AbilityData::is_instant_placement() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.is_instant_placement)
  return _internal_is_instant_placement();
}
inline void AbilityData::_internal_set_is_instant_placement(bool value) {
  _has_bits_[0] |= 0x00001000u;
  is_instant_placement_ = value;
}
inline void AbilityData::set_is_instant_placement(bool value) {
  _internal_set_is_instant_placement(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.is_instant_placement)
}

// optional float cast_range = 15;
inline bool AbilityData::_internal_has_cast_range() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool AbilityData::has_cast_range() const {
  return _internal_has_cast_range();
}
inline void AbilityData::clear_cast_range() {
  cast_range_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float AbilityData::_internal_cast_range() const {
  return cast_range_;
}
inline float AbilityData::cast_range() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.AbilityData.cast_range)
  return _internal_cast_range();
}
inline void AbilityData::_internal_set_cast_range(float value) {
  _has_bits_[0] |= 0x00002000u;
  cast_range_ = value;
}
inline void AbilityData::set_cast_range(float value) {
  _internal_set_cast_range(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.AbilityData.cast_range)
}

// -------------------------------------------------------------------

// DamageBonus

// optional .SC2APIProtocol.Attribute attribute = 1;
inline bool DamageBonus::_internal_has_attribute() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DamageBonus::has_attribute() const {
  return _internal_has_attribute();
}
inline void DamageBonus::clear_attribute() {
  attribute_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SC2APIProtocol::Attribute DamageBonus::_internal_attribute() const {
  return static_cast< ::SC2APIProtocol::Attribute >(attribute_);
}
inline ::SC2APIProtocol::Attribute DamageBonus::attribute() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DamageBonus.attribute)
  return _internal_attribute();
}
inline void DamageBonus::_internal_set_attribute(::SC2APIProtocol::Attribute value) {
  assert(::SC2APIProtocol::Attribute_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  attribute_ = value;
}
inline void DamageBonus::set_attribute(::SC2APIProtocol::Attribute value) {
  _internal_set_attribute(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DamageBonus.attribute)
}

// optional float bonus = 2;
inline bool DamageBonus::_internal_has_bonus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DamageBonus::has_bonus() const {
  return _internal_has_bonus();
}
inline void DamageBonus::clear_bonus() {
  bonus_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float DamageBonus::_internal_bonus() const {
  return bonus_;
}
inline float DamageBonus::bonus() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.DamageBonus.bonus)
  return _internal_bonus();
}
inline void DamageBonus::_internal_set_bonus(float value) {
  _has_bits_[0] |= 0x00000001u;
  bonus_ = value;
}
inline void DamageBonus::set_bonus(float value) {
  _internal_set_bonus(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.DamageBonus.bonus)
}

// -------------------------------------------------------------------

// Weapon

// optional .SC2APIProtocol.Weapon.TargetType type = 1;
inline bool Weapon::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Weapon::has_type() const {
  return _internal_has_type();
}
inline void Weapon::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::SC2APIProtocol::Weapon_TargetType Weapon::_internal_type() const {
  return static_cast< ::SC2APIProtocol::Weapon_TargetType >(type_);
}
inline ::SC2APIProtocol::Weapon_TargetType Weapon::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Weapon.type)
  return _internal_type();
}
inline void Weapon::_internal_set_type(::SC2APIProtocol::Weapon_TargetType value) {
  assert(::SC2APIProtocol::Weapon_TargetType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void Weapon::set_type(::SC2APIProtocol::Weapon_TargetType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Weapon.type)
}

// optional float damage = 2;
inline bool Weapon::_internal_has_damage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Weapon::has_damage() const {
  return _internal_has_damage();
}
inline void Weapon::clear_damage() {
  damage_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Weapon::_internal_damage() const {
  return damage_;
}
inline float Weapon::damage() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Weapon.damage)
  return _internal_damage();
}
inline void Weapon::_internal_set_damage(float value) {
  _has_bits_[0] |= 0x00000001u;
  damage_ = value;
}
inline void Weapon::set_damage(float value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Weapon.damage)
}

// repeated .SC2APIProtocol.DamageBonus damage_bonus = 3;
inline int Weapon::_internal_damage_bonus_size() const {
  return damage_bonus_.size();
}
inline int Weapon::damage_bonus_size() const {
  return _internal_damage_bonus_size();
}
inline void Weapon::clear_damage_bonus() {
  damage_bonus_.Clear();
}
inline ::SC2APIProtocol::DamageBonus* Weapon::mutable_damage_bonus(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Weapon.damage_bonus)
  return damage_bonus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DamageBonus >*
Weapon::mutable_damage_bonus() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Weapon.damage_bonus)
  return &damage_bonus_;
}
inline const ::SC2APIProtocol::DamageBonus& Weapon::_internal_damage_bonus(int index) const {
  return damage_bonus_.Get(index);
}
inline const ::SC2APIProtocol::DamageBonus& Weapon::damage_bonus(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Weapon.damage_bonus)
  return _internal_damage_bonus(index);
}
inline ::SC2APIProtocol::DamageBonus* Weapon::_internal_add_damage_bonus() {
  return damage_bonus_.Add();
}
inline ::SC2APIProtocol::DamageBonus* Weapon::add_damage_bonus() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Weapon.damage_bonus)
  return _internal_add_damage_bonus();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::DamageBonus >&
Weapon::damage_bonus() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Weapon.damage_bonus)
  return damage_bonus_;
}

// optional uint32 attacks = 4;
inline bool Weapon::_internal_has_attacks() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Weapon::has_attacks() const {
  return _internal_has_attacks();
}
inline void Weapon::clear_attacks() {
  attacks_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Weapon::_internal_attacks() const {
  return attacks_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Weapon::attacks() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Weapon.attacks)
  return _internal_attacks();
}
inline void Weapon::_internal_set_attacks(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  attacks_ = value;
}
inline void Weapon::set_attacks(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_attacks(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Weapon.attacks)
}

// optional float range = 5;
inline bool Weapon::_internal_has_range() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Weapon::has_range() const {
  return _internal_has_range();
}
inline void Weapon::clear_range() {
  range_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Weapon::_internal_range() const {
  return range_;
}
inline float Weapon::range() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Weapon.range)
  return _internal_range();
}
inline void Weapon::_internal_set_range(float value) {
  _has_bits_[0] |= 0x00000004u;
  range_ = value;
}
inline void Weapon::set_range(float value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Weapon.range)
}

// optional float speed = 6;
inline bool Weapon::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Weapon::has_speed() const {
  return _internal_has_speed();
}
inline void Weapon::clear_speed() {
  speed_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Weapon::_internal_speed() const {
  return speed_;
}
inline float Weapon::speed() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Weapon.speed)
  return _internal_speed();
}
inline void Weapon::_internal_set_speed(float value) {
  _has_bits_[0] |= 0x00000008u;
  speed_ = value;
}
inline void Weapon::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Weapon.speed)
}

// -------------------------------------------------------------------

// UnitTypeData

// optional uint32 unit_id = 1;
inline bool UnitTypeData::_internal_has_unit_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnitTypeData::has_unit_id() const {
  return _internal_has_unit_id();
}
inline void UnitTypeData::clear_unit_id() {
  unit_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_unit_id() const {
  return unit_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::unit_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.unit_id)
  return _internal_unit_id();
}
inline void UnitTypeData::_internal_set_unit_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  unit_id_ = value;
}
inline void UnitTypeData::set_unit_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unit_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.unit_id)
}

// optional string name = 2;
inline bool UnitTypeData::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnitTypeData::has_name() const {
  return _internal_has_name();
}
inline void UnitTypeData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnitTypeData::name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.name)
  return _internal_name();
}
inline void UnitTypeData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.name)
}
inline std::string* UnitTypeData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.UnitTypeData.name)
  return _internal_mutable_name();
}
inline const std::string& UnitTypeData::_internal_name() const {
  return name_.GetNoArena();
}
inline void UnitTypeData::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UnitTypeData::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.UnitTypeData.name)
}
inline void UnitTypeData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.UnitTypeData.name)
}
inline void UnitTypeData::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.UnitTypeData.name)
}
inline std::string* UnitTypeData::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UnitTypeData::release_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.UnitTypeData.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UnitTypeData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.UnitTypeData.name)
}

// optional bool available = 3;
inline bool UnitTypeData::_internal_has_available() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UnitTypeData::has_available() const {
  return _internal_has_available();
}
inline void UnitTypeData::clear_available() {
  available_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool UnitTypeData::_internal_available() const {
  return available_;
}
inline bool UnitTypeData::available() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.available)
  return _internal_available();
}
inline void UnitTypeData::_internal_set_available(bool value) {
  _has_bits_[0] |= 0x00000400u;
  available_ = value;
}
inline void UnitTypeData::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.available)
}

// optional uint32 cargo_size = 4;
inline bool UnitTypeData::_internal_has_cargo_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnitTypeData::has_cargo_size() const {
  return _internal_has_cargo_size();
}
inline void UnitTypeData::clear_cargo_size() {
  cargo_size_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_cargo_size() const {
  return cargo_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::cargo_size() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.cargo_size)
  return _internal_cargo_size();
}
inline void UnitTypeData::_internal_set_cargo_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  cargo_size_ = value;
}
inline void UnitTypeData::set_cargo_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cargo_size(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.cargo_size)
}

// optional uint32 mineral_cost = 12;
inline bool UnitTypeData::_internal_has_mineral_cost() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UnitTypeData::has_mineral_cost() const {
  return _internal_has_mineral_cost();
}
inline void UnitTypeData::clear_mineral_cost() {
  mineral_cost_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_mineral_cost() const {
  return mineral_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::mineral_cost() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.mineral_cost)
  return _internal_mineral_cost();
}
inline void UnitTypeData::_internal_set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  mineral_cost_ = value;
}
inline void UnitTypeData::set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mineral_cost(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.mineral_cost)
}

// optional uint32 vespene_cost = 13;
inline bool UnitTypeData::_internal_has_vespene_cost() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UnitTypeData::has_vespene_cost() const {
  return _internal_has_vespene_cost();
}
inline void UnitTypeData::clear_vespene_cost() {
  vespene_cost_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_vespene_cost() const {
  return vespene_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::vespene_cost() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.vespene_cost)
  return _internal_vespene_cost();
}
inline void UnitTypeData::_internal_set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  vespene_cost_ = value;
}
inline void UnitTypeData::set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_vespene_cost(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.vespene_cost)
}

// optional float food_required = 14;
inline bool UnitTypeData::_internal_has_food_required() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UnitTypeData::has_food_required() const {
  return _internal_has_food_required();
}
inline void UnitTypeData::clear_food_required() {
  food_required_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float UnitTypeData::_internal_food_required() const {
  return food_required_;
}
inline float UnitTypeData::food_required() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.food_required)
  return _internal_food_required();
}
inline void UnitTypeData::_internal_set_food_required(float value) {
  _has_bits_[0] |= 0x00000080u;
  food_required_ = value;
}
inline void UnitTypeData::set_food_required(float value) {
  _internal_set_food_required(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.food_required)
}

// optional float food_provided = 18;
inline bool UnitTypeData::_internal_has_food_provided() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool UnitTypeData::has_food_provided() const {
  return _internal_has_food_provided();
}
inline void UnitTypeData::clear_food_provided() {
  food_provided_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float UnitTypeData::_internal_food_provided() const {
  return food_provided_;
}
inline float UnitTypeData::food_provided() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.food_provided)
  return _internal_food_provided();
}
inline void UnitTypeData::_internal_set_food_provided(float value) {
  _has_bits_[0] |= 0x00008000u;
  food_provided_ = value;
}
inline void UnitTypeData::set_food_provided(float value) {
  _internal_set_food_provided(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.food_provided)
}

// optional uint32 ability_id = 15;
inline bool UnitTypeData::_internal_has_ability_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UnitTypeData::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void UnitTypeData::clear_ability_id() {
  ability_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_ability_id() const {
  return ability_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.ability_id)
  return _internal_ability_id();
}
inline void UnitTypeData::_internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  ability_id_ = value;
}
inline void UnitTypeData::set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.ability_id)
}

// optional .SC2APIProtocol.Race race = 16;
inline bool UnitTypeData::_internal_has_race() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UnitTypeData::has_race() const {
  return _internal_has_race();
}
inline void UnitTypeData::clear_race() {
  race_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::SC2APIProtocol::Race UnitTypeData::_internal_race() const {
  return static_cast< ::SC2APIProtocol::Race >(race_);
}
inline ::SC2APIProtocol::Race UnitTypeData::race() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.race)
  return _internal_race();
}
inline void UnitTypeData::_internal_set_race(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  race_ = value;
}
inline void UnitTypeData::set_race(::SC2APIProtocol::Race value) {
  _internal_set_race(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.race)
}

// optional float build_time = 17;
inline bool UnitTypeData::_internal_has_build_time() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool UnitTypeData::has_build_time() const {
  return _internal_has_build_time();
}
inline void UnitTypeData::clear_build_time() {
  build_time_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float UnitTypeData::_internal_build_time() const {
  return build_time_;
}
inline float UnitTypeData::build_time() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.build_time)
  return _internal_build_time();
}
inline void UnitTypeData::_internal_set_build_time(float value) {
  _has_bits_[0] |= 0x00004000u;
  build_time_ = value;
}
inline void UnitTypeData::set_build_time(float value) {
  _internal_set_build_time(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.build_time)
}

// optional bool has_vespene = 19;
inline bool UnitTypeData::_internal_has_has_vespene() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UnitTypeData::has_has_vespene() const {
  return _internal_has_has_vespene();
}
inline void UnitTypeData::clear_has_vespene() {
  has_vespene_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool UnitTypeData::_internal_has_vespene() const {
  return has_vespene_;
}
inline bool UnitTypeData::has_vespene() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.has_vespene)
  return _internal_has_vespene();
}
inline void UnitTypeData::_internal_set_has_vespene(bool value) {
  _has_bits_[0] |= 0x00000800u;
  has_vespene_ = value;
}
inline void UnitTypeData::set_has_vespene(bool value) {
  _internal_set_has_vespene(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.has_vespene)
}

// optional bool has_minerals = 20;
inline bool UnitTypeData::_internal_has_has_minerals() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool UnitTypeData::has_has_minerals() const {
  return _internal_has_has_minerals();
}
inline void UnitTypeData::clear_has_minerals() {
  has_minerals_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool UnitTypeData::_internal_has_minerals() const {
  return has_minerals_;
}
inline bool UnitTypeData::has_minerals() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.has_minerals)
  return _internal_has_minerals();
}
inline void UnitTypeData::_internal_set_has_minerals(bool value) {
  _has_bits_[0] |= 0x00001000u;
  has_minerals_ = value;
}
inline void UnitTypeData::set_has_minerals(bool value) {
  _internal_set_has_minerals(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.has_minerals)
}

// optional float sight_range = 25;
inline bool UnitTypeData::_internal_has_sight_range() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool UnitTypeData::has_sight_range() const {
  return _internal_has_sight_range();
}
inline void UnitTypeData::clear_sight_range() {
  sight_range_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline float UnitTypeData::_internal_sight_range() const {
  return sight_range_;
}
inline float UnitTypeData::sight_range() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.sight_range)
  return _internal_sight_range();
}
inline void UnitTypeData::_internal_set_sight_range(float value) {
  _has_bits_[0] |= 0x00040000u;
  sight_range_ = value;
}
inline void UnitTypeData::set_sight_range(float value) {
  _internal_set_sight_range(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.sight_range)
}

// repeated uint32 tech_alias = 21;
inline int UnitTypeData::_internal_tech_alias_size() const {
  return tech_alias_.size();
}
inline int UnitTypeData::tech_alias_size() const {
  return _internal_tech_alias_size();
}
inline void UnitTypeData::clear_tech_alias() {
  tech_alias_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_tech_alias(int index) const {
  return tech_alias_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::tech_alias(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.tech_alias)
  return _internal_tech_alias(index);
}
inline void UnitTypeData::set_tech_alias(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  tech_alias_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.tech_alias)
}
inline void UnitTypeData::_internal_add_tech_alias(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  tech_alias_.Add(value);
}
inline void UnitTypeData::add_tech_alias(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_tech_alias(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.UnitTypeData.tech_alias)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
UnitTypeData::_internal_tech_alias() const {
  return tech_alias_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
UnitTypeData::tech_alias() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.UnitTypeData.tech_alias)
  return _internal_tech_alias();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
UnitTypeData::_internal_mutable_tech_alias() {
  return &tech_alias_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
UnitTypeData::mutable_tech_alias() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.UnitTypeData.tech_alias)
  return _internal_mutable_tech_alias();
}

// optional uint32 unit_alias = 22;
inline bool UnitTypeData::_internal_has_unit_alias() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool UnitTypeData::has_unit_alias() const {
  return _internal_has_unit_alias();
}
inline void UnitTypeData::clear_unit_alias() {
  unit_alias_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_unit_alias() const {
  return unit_alias_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::unit_alias() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.unit_alias)
  return _internal_unit_alias();
}
inline void UnitTypeData::_internal_set_unit_alias(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  unit_alias_ = value;
}
inline void UnitTypeData::set_unit_alias(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unit_alias(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.unit_alias)
}

// optional uint32 tech_requirement = 23;
inline bool UnitTypeData::_internal_has_tech_requirement() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool UnitTypeData::has_tech_requirement() const {
  return _internal_has_tech_requirement();
}
inline void UnitTypeData::clear_tech_requirement() {
  tech_requirement_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::_internal_tech_requirement() const {
  return tech_requirement_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnitTypeData::tech_requirement() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.tech_requirement)
  return _internal_tech_requirement();
}
inline void UnitTypeData::_internal_set_tech_requirement(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  tech_requirement_ = value;
}
inline void UnitTypeData::set_tech_requirement(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tech_requirement(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.tech_requirement)
}

// optional bool require_attached = 24;
inline bool UnitTypeData::_internal_has_require_attached() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool UnitTypeData::has_require_attached() const {
  return _internal_has_require_attached();
}
inline void UnitTypeData::clear_require_attached() {
  require_attached_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool UnitTypeData::_internal_require_attached() const {
  return require_attached_;
}
inline bool UnitTypeData::require_attached() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.require_attached)
  return _internal_require_attached();
}
inline void UnitTypeData::_internal_set_require_attached(bool value) {
  _has_bits_[0] |= 0x00002000u;
  require_attached_ = value;
}
inline void UnitTypeData::set_require_attached(bool value) {
  _internal_set_require_attached(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.require_attached)
}

// repeated .SC2APIProtocol.Attribute attributes = 8;
inline int UnitTypeData::_internal_attributes_size() const {
  return attributes_.size();
}
inline int UnitTypeData::attributes_size() const {
  return _internal_attributes_size();
}
inline void UnitTypeData::clear_attributes() {
  attributes_.Clear();
}
inline ::SC2APIProtocol::Attribute UnitTypeData::_internal_attributes(int index) const {
  return static_cast< ::SC2APIProtocol::Attribute >(attributes_.Get(index));
}
inline ::SC2APIProtocol::Attribute UnitTypeData::attributes(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.attributes)
  return _internal_attributes(index);
}
inline void UnitTypeData::set_attributes(int index, ::SC2APIProtocol::Attribute value) {
  assert(::SC2APIProtocol::Attribute_IsValid(value));
  attributes_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.attributes)
}
inline void UnitTypeData::_internal_add_attributes(::SC2APIProtocol::Attribute value) {
  assert(::SC2APIProtocol::Attribute_IsValid(value));
  attributes_.Add(value);
}
inline void UnitTypeData::add_attributes(::SC2APIProtocol::Attribute value) {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.UnitTypeData.attributes)
  _internal_add_attributes(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UnitTypeData::attributes() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.UnitTypeData.attributes)
  return attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UnitTypeData::_internal_mutable_attributes() {
  return &attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UnitTypeData::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.UnitTypeData.attributes)
  return _internal_mutable_attributes();
}

// optional float movement_speed = 9;
inline bool UnitTypeData::_internal_has_movement_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnitTypeData::has_movement_speed() const {
  return _internal_has_movement_speed();
}
inline void UnitTypeData::clear_movement_speed() {
  movement_speed_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float UnitTypeData::_internal_movement_speed() const {
  return movement_speed_;
}
inline float UnitTypeData::movement_speed() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.movement_speed)
  return _internal_movement_speed();
}
inline void UnitTypeData::_internal_set_movement_speed(float value) {
  _has_bits_[0] |= 0x00000008u;
  movement_speed_ = value;
}
inline void UnitTypeData::set_movement_speed(float value) {
  _internal_set_movement_speed(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.movement_speed)
}

// optional float armor = 10;
inline bool UnitTypeData::_internal_has_armor() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnitTypeData::has_armor() const {
  return _internal_has_armor();
}
inline void UnitTypeData::clear_armor() {
  armor_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float UnitTypeData::_internal_armor() const {
  return armor_;
}
inline float UnitTypeData::armor() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.armor)
  return _internal_armor();
}
inline void UnitTypeData::_internal_set_armor(float value) {
  _has_bits_[0] |= 0x00000010u;
  armor_ = value;
}
inline void UnitTypeData::set_armor(float value) {
  _internal_set_armor(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UnitTypeData.armor)
}

// repeated .SC2APIProtocol.Weapon weapons = 11;
inline int UnitTypeData::_internal_weapons_size() const {
  return weapons_.size();
}
inline int UnitTypeData::weapons_size() const {
  return _internal_weapons_size();
}
inline void UnitTypeData::clear_weapons() {
  weapons_.Clear();
}
inline ::SC2APIProtocol::Weapon* UnitTypeData::mutable_weapons(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.UnitTypeData.weapons)
  return weapons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Weapon >*
UnitTypeData::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.UnitTypeData.weapons)
  return &weapons_;
}
inline const ::SC2APIProtocol::Weapon& UnitTypeData::_internal_weapons(int index) const {
  return weapons_.Get(index);
}
inline const ::SC2APIProtocol::Weapon& UnitTypeData::weapons(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UnitTypeData.weapons)
  return _internal_weapons(index);
}
inline ::SC2APIProtocol::Weapon* UnitTypeData::_internal_add_weapons() {
  return weapons_.Add();
}
inline ::SC2APIProtocol::Weapon* UnitTypeData::add_weapons() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.UnitTypeData.weapons)
  return _internal_add_weapons();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SC2APIProtocol::Weapon >&
UnitTypeData::weapons() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.UnitTypeData.weapons)
  return weapons_;
}

// -------------------------------------------------------------------

// UpgradeData

// optional uint32 upgrade_id = 1;
inline bool UpgradeData::_internal_has_upgrade_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpgradeData::has_upgrade_id() const {
  return _internal_has_upgrade_id();
}
inline void UpgradeData::clear_upgrade_id() {
  upgrade_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::_internal_upgrade_id() const {
  return upgrade_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::upgrade_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UpgradeData.upgrade_id)
  return _internal_upgrade_id();
}
inline void UpgradeData::_internal_set_upgrade_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  upgrade_id_ = value;
}
inline void UpgradeData::set_upgrade_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_upgrade_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UpgradeData.upgrade_id)
}

// optional string name = 2;
inline bool UpgradeData::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpgradeData::has_name() const {
  return _internal_has_name();
}
inline void UpgradeData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpgradeData::name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UpgradeData.name)
  return _internal_name();
}
inline void UpgradeData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UpgradeData.name)
}
inline std::string* UpgradeData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.UpgradeData.name)
  return _internal_mutable_name();
}
inline const std::string& UpgradeData::_internal_name() const {
  return name_.GetNoArena();
}
inline void UpgradeData::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UpgradeData::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.UpgradeData.name)
}
inline void UpgradeData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.UpgradeData.name)
}
inline void UpgradeData::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.UpgradeData.name)
}
inline std::string* UpgradeData::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UpgradeData::release_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.UpgradeData.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UpgradeData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.UpgradeData.name)
}

// optional uint32 mineral_cost = 3;
inline bool UpgradeData::_internal_has_mineral_cost() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpgradeData::has_mineral_cost() const {
  return _internal_has_mineral_cost();
}
inline void UpgradeData::clear_mineral_cost() {
  mineral_cost_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::_internal_mineral_cost() const {
  return mineral_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::mineral_cost() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UpgradeData.mineral_cost)
  return _internal_mineral_cost();
}
inline void UpgradeData::_internal_set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  mineral_cost_ = value;
}
inline void UpgradeData::set_mineral_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mineral_cost(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UpgradeData.mineral_cost)
}

// optional uint32 vespene_cost = 4;
inline bool UpgradeData::_internal_has_vespene_cost() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpgradeData::has_vespene_cost() const {
  return _internal_has_vespene_cost();
}
inline void UpgradeData::clear_vespene_cost() {
  vespene_cost_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::_internal_vespene_cost() const {
  return vespene_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::vespene_cost() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UpgradeData.vespene_cost)
  return _internal_vespene_cost();
}
inline void UpgradeData::_internal_set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  vespene_cost_ = value;
}
inline void UpgradeData::set_vespene_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_vespene_cost(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UpgradeData.vespene_cost)
}

// optional float research_time = 5;
inline bool UpgradeData::_internal_has_research_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UpgradeData::has_research_time() const {
  return _internal_has_research_time();
}
inline void UpgradeData::clear_research_time() {
  research_time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float UpgradeData::_internal_research_time() const {
  return research_time_;
}
inline float UpgradeData::research_time() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UpgradeData.research_time)
  return _internal_research_time();
}
inline void UpgradeData::_internal_set_research_time(float value) {
  _has_bits_[0] |= 0x00000010u;
  research_time_ = value;
}
inline void UpgradeData::set_research_time(float value) {
  _internal_set_research_time(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UpgradeData.research_time)
}

// optional uint32 ability_id = 6;
inline bool UpgradeData::_internal_has_ability_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UpgradeData::has_ability_id() const {
  return _internal_has_ability_id();
}
inline void UpgradeData::clear_ability_id() {
  ability_id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::_internal_ability_id() const {
  return ability_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UpgradeData::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.UpgradeData.ability_id)
  return _internal_ability_id();
}
inline void UpgradeData::_internal_set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  ability_id_ = value;
}
inline void UpgradeData::set_ability_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ability_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.UpgradeData.ability_id)
}

// -------------------------------------------------------------------

// BuffData

// optional uint32 buff_id = 1;
inline bool BuffData::_internal_has_buff_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BuffData::has_buff_id() const {
  return _internal_has_buff_id();
}
inline void BuffData::clear_buff_id() {
  buff_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BuffData::_internal_buff_id() const {
  return buff_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BuffData::buff_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.BuffData.buff_id)
  return _internal_buff_id();
}
inline void BuffData::_internal_set_buff_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  buff_id_ = value;
}
inline void BuffData::set_buff_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_buff_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.BuffData.buff_id)
}

// optional string name = 2;
inline bool BuffData::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BuffData::has_name() const {
  return _internal_has_name();
}
inline void BuffData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BuffData::name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.BuffData.name)
  return _internal_name();
}
inline void BuffData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.BuffData.name)
}
inline std::string* BuffData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.BuffData.name)
  return _internal_mutable_name();
}
inline const std::string& BuffData::_internal_name() const {
  return name_.GetNoArena();
}
inline void BuffData::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void BuffData::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.BuffData.name)
}
inline void BuffData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.BuffData.name)
}
inline void BuffData::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.BuffData.name)
}
inline std::string* BuffData::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuffData::release_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.BuffData.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuffData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.BuffData.name)
}

// -------------------------------------------------------------------

// EffectData

// optional uint32 effect_id = 1;
inline bool EffectData::_internal_has_effect_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EffectData::has_effect_id() const {
  return _internal_has_effect_id();
}
inline void EffectData::clear_effect_id() {
  effect_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EffectData::_internal_effect_id() const {
  return effect_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EffectData::effect_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.EffectData.effect_id)
  return _internal_effect_id();
}
inline void EffectData::_internal_set_effect_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  effect_id_ = value;
}
inline void EffectData::set_effect_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_effect_id(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.EffectData.effect_id)
}

// optional string name = 2;
inline bool EffectData::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EffectData::has_name() const {
  return _internal_has_name();
}
inline void EffectData::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EffectData::name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.EffectData.name)
  return _internal_name();
}
inline void EffectData::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.EffectData.name)
}
inline std::string* EffectData::mutable_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.EffectData.name)
  return _internal_mutable_name();
}
inline const std::string& EffectData::_internal_name() const {
  return name_.GetNoArena();
}
inline void EffectData::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EffectData::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.EffectData.name)
}
inline void EffectData::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.EffectData.name)
}
inline void EffectData::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.EffectData.name)
}
inline std::string* EffectData::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EffectData::release_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.EffectData.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EffectData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.EffectData.name)
}

// optional string friendly_name = 3;
inline bool EffectData::_internal_has_friendly_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EffectData::has_friendly_name() const {
  return _internal_has_friendly_name();
}
inline void EffectData::clear_friendly_name() {
  friendly_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EffectData::friendly_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.EffectData.friendly_name)
  return _internal_friendly_name();
}
inline void EffectData::set_friendly_name(const std::string& value) {
  _internal_set_friendly_name(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.EffectData.friendly_name)
}
inline std::string* EffectData::mutable_friendly_name() {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.EffectData.friendly_name)
  return _internal_mutable_friendly_name();
}
inline const std::string& EffectData::_internal_friendly_name() const {
  return friendly_name_.GetNoArena();
}
inline void EffectData::_internal_set_friendly_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  friendly_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EffectData::set_friendly_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  friendly_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.EffectData.friendly_name)
}
inline void EffectData::set_friendly_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  friendly_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.EffectData.friendly_name)
}
inline void EffectData::set_friendly_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  friendly_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.EffectData.friendly_name)
}
inline std::string* EffectData::_internal_mutable_friendly_name() {
  _has_bits_[0] |= 0x00000002u;
  return friendly_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EffectData::release_friendly_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.EffectData.friendly_name)
  if (!_internal_has_friendly_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return friendly_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EffectData::set_allocated_friendly_name(std::string* friendly_name) {
  if (friendly_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  friendly_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), friendly_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.EffectData.friendly_name)
}

// optional float radius = 4;
inline bool EffectData::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EffectData::has_radius() const {
  return _internal_has_radius();
}
inline void EffectData::clear_radius() {
  radius_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float EffectData::_internal_radius() const {
  return radius_;
}
inline float EffectData::radius() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.EffectData.radius)
  return _internal_radius();
}
inline void EffectData::_internal_set_radius(float value) {
  _has_bits_[0] |= 0x00000008u;
  radius_ = value;
}
inline void EffectData::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.EffectData.radius)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SC2APIProtocol::AbilityData_Target> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::AbilityData_Target>() {
  return ::SC2APIProtocol::AbilityData_Target_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Weapon_TargetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Weapon_TargetType>() {
  return ::SC2APIProtocol::Weapon_TargetType_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Attribute> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Attribute>() {
  return ::SC2APIProtocol::Attribute_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_s2clientprotocol_2fdata_2eproto
