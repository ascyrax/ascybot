// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/raw.proto

#include "s2clientprotocol/raw.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ActionRawToggleAutocast_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Effect_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Event_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fcommon_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ImageData_s2clientprotocol_2fcommon_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MapState_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PassengerUnit_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fcommon_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Point_s2clientprotocol_2fcommon_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fcommon_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Point2D_s2clientprotocol_2fcommon_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PowerSource_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RadarRing_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RallyTarget_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fcommon_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RectangleI_s2clientprotocol_2fcommon_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fcommon_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Size2DI_s2clientprotocol_2fcommon_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Unit_s2clientprotocol_2fraw_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_s2clientprotocol_2fraw_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UnitOrder_s2clientprotocol_2fraw_2eproto;
namespace SC2APIProtocol {
class StartRawDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StartRaw> _instance;
} _StartRaw_default_instance_;
class ObservationRawDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ObservationRaw> _instance;
} _ObservationRaw_default_instance_;
class RadarRingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RadarRing> _instance;
} _RadarRing_default_instance_;
class PowerSourceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PowerSource> _instance;
} _PowerSource_default_instance_;
class PlayerRawDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PlayerRaw> _instance;
} _PlayerRaw_default_instance_;
class UnitOrderDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UnitOrder> _instance;
  const ::SC2APIProtocol::Point* target_world_space_pos_;
  ::PROTOBUF_NAMESPACE_ID::uint64 target_unit_tag_;
} _UnitOrder_default_instance_;
class PassengerUnitDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PassengerUnit> _instance;
} _PassengerUnit_default_instance_;
class RallyTargetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RallyTarget> _instance;
} _RallyTarget_default_instance_;
class UnitDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Unit> _instance;
} _Unit_default_instance_;
class MapStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MapState> _instance;
} _MapState_default_instance_;
class EventDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Event> _instance;
} _Event_default_instance_;
class EffectDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Effect> _instance;
} _Effect_default_instance_;
class ActionRawDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ActionRaw> _instance;
  const ::SC2APIProtocol::ActionRawUnitCommand* unit_command_;
  const ::SC2APIProtocol::ActionRawCameraMove* camera_move_;
  const ::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast_;
} _ActionRaw_default_instance_;
class ActionRawUnitCommandDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ActionRawUnitCommand> _instance;
  const ::SC2APIProtocol::Point2D* target_world_space_pos_;
  ::PROTOBUF_NAMESPACE_ID::uint64 target_unit_tag_;
} _ActionRawUnitCommand_default_instance_;
class ActionRawCameraMoveDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ActionRawCameraMove> _instance;
} _ActionRawCameraMove_default_instance_;
class ActionRawToggleAutocastDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ActionRawToggleAutocast> _instance;
} _ActionRawToggleAutocast_default_instance_;
}  // namespace SC2APIProtocol
static void InitDefaultsscc_info_ActionRaw_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_ActionRaw_default_instance_;
    new (ptr) ::SC2APIProtocol::ActionRaw();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::ActionRaw::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ActionRaw_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_ActionRaw_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_ActionRawToggleAutocast_s2clientprotocol_2fraw_2eproto.base,}};

static void InitDefaultsscc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_ActionRawCameraMove_default_instance_;
    new (ptr) ::SC2APIProtocol::ActionRawCameraMove();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::ActionRawCameraMove::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_ActionRawToggleAutocast_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_ActionRawToggleAutocast_default_instance_;
    new (ptr) ::SC2APIProtocol::ActionRawToggleAutocast();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::ActionRawToggleAutocast::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ActionRawToggleAutocast_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ActionRawToggleAutocast_s2clientprotocol_2fraw_2eproto}, {}};

static void InitDefaultsscc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_ActionRawUnitCommand_default_instance_;
    new (ptr) ::SC2APIProtocol::ActionRawUnitCommand();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::ActionRawUnitCommand::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point2D_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_Effect_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_Effect_default_instance_;
    new (ptr) ::SC2APIProtocol::Effect();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::Effect::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Effect_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Effect_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point2D_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_Event_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_Event_default_instance_;
    new (ptr) ::SC2APIProtocol::Event();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::Event::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Event_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Event_s2clientprotocol_2fraw_2eproto}, {}};

static void InitDefaultsscc_info_MapState_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_MapState_default_instance_;
    new (ptr) ::SC2APIProtocol::MapState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::MapState::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MapState_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_MapState_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_ImageData_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_ObservationRaw_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_ObservationRaw_default_instance_;
    new (ptr) ::SC2APIProtocol::ObservationRaw();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::ObservationRaw::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_ObservationRaw_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, 0, InitDefaultsscc_info_ObservationRaw_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_Unit_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_MapState_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_Event_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_Effect_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_RadarRing_s2clientprotocol_2fraw_2eproto.base,}};

static void InitDefaultsscc_info_PassengerUnit_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_PassengerUnit_default_instance_;
    new (ptr) ::SC2APIProtocol::PassengerUnit();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::PassengerUnit::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PassengerUnit_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PassengerUnit_s2clientprotocol_2fraw_2eproto}, {}};

static void InitDefaultsscc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_PlayerRaw_default_instance_;
    new (ptr) ::SC2APIProtocol::PlayerRaw();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::PlayerRaw::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_PowerSource_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_Point_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_PowerSource_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_PowerSource_default_instance_;
    new (ptr) ::SC2APIProtocol::PowerSource();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::PowerSource::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PowerSource_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PowerSource_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_RadarRing_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_RadarRing_default_instance_;
    new (ptr) ::SC2APIProtocol::RadarRing();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::RadarRing::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RadarRing_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RadarRing_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_RallyTarget_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_RallyTarget_default_instance_;
    new (ptr) ::SC2APIProtocol::RallyTarget();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::RallyTarget::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RallyTarget_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RallyTarget_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_StartRaw_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_StartRaw_default_instance_;
    new (ptr) ::SC2APIProtocol::StartRaw();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::StartRaw::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_StartRaw_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_StartRaw_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Size2DI_s2clientprotocol_2fcommon_2eproto.base,
      &scc_info_ImageData_s2clientprotocol_2fcommon_2eproto.base,
      &scc_info_RectangleI_s2clientprotocol_2fcommon_2eproto.base,
      &scc_info_Point2D_s2clientprotocol_2fcommon_2eproto.base,}};

static void InitDefaultsscc_info_Unit_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_Unit_default_instance_;
    new (ptr) ::SC2APIProtocol::Unit();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::Unit::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Unit_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_Unit_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point_s2clientprotocol_2fcommon_2eproto.base,
      &scc_info_UnitOrder_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_PassengerUnit_s2clientprotocol_2fraw_2eproto.base,
      &scc_info_RallyTarget_s2clientprotocol_2fraw_2eproto.base,}};

static void InitDefaultsscc_info_UnitOrder_s2clientprotocol_2fraw_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::SC2APIProtocol::_UnitOrder_default_instance_;
    new (ptr) ::SC2APIProtocol::UnitOrder();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SC2APIProtocol::UnitOrder::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UnitOrder_s2clientprotocol_2fraw_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_UnitOrder_s2clientprotocol_2fraw_2eproto}, {
      &scc_info_Point_s2clientprotocol_2fcommon_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_s2clientprotocol_2fraw_2eproto[16];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_s2clientprotocol_2fraw_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_s2clientprotocol_2fraw_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, map_size_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, pathing_grid_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, terrain_height_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, placement_grid_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, playable_area_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::StartRaw, start_locations_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, player_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, units_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, map_state_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, event_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, effects_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ObservationRaw, radar_),
  0,
  ~0u,
  1,
  2,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RadarRing, radius_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, radius_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PowerSource, tag_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, power_sources_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, camera_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PlayerRaw, upgrade_ids_),
  ~0u,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, ability_id_),
  offsetof(::SC2APIProtocol::UnitOrderDefaultTypeInternal, target_world_space_pos_),
  offsetof(::SC2APIProtocol::UnitOrderDefaultTypeInternal, target_unit_tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, progress_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::UnitOrder, target_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, health_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, health_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, shield_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, shield_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, energy_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, energy_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::PassengerUnit, unit_type_),
  0,
  1,
  2,
  3,
  6,
  4,
  7,
  5,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, point_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::RallyTarget, tag_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, display_type_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, alliance_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, unit_type_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, owner_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, facing_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, radius_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, build_progress_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, cloak_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, buff_ids_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, detect_range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, radar_range_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_selected_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_on_screen_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_blip_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_powered_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_active_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, attack_upgrade_level_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, armor_upgrade_level_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, shield_upgrade_level_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, health_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, health_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, shield_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, shield_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, energy_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, energy_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, mineral_contents_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, vespene_contents_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_flying_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_burrowed_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, is_hallucination_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, orders_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, add_on_tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, passengers_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, cargo_space_taken_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, cargo_space_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, assigned_harvesters_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, ideal_harvesters_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, weapon_cooldown_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, engaged_target_tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, buff_duration_remain_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, buff_duration_max_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Unit, rally_targets_),
  38,
  39,
  1,
  2,
  3,
  0,
  4,
  5,
  6,
  7,
  ~0u,
  28,
  30,
  12,
  13,
  14,
  15,
  23,
  33,
  34,
  35,
  8,
  9,
  10,
  31,
  11,
  32,
  16,
  17,
  24,
  25,
  26,
  ~0u,
  19,
  ~0u,
  18,
  20,
  21,
  22,
  27,
  29,
  36,
  37,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, visibility_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::MapState, creep_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Event, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Event, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Event, dead_units_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, effect_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, pos_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, alliance_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, owner_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::Effect, radius_),
  0,
  ~0u,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRaw, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRaw, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRaw, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  offsetof(::SC2APIProtocol::ActionRawDefaultTypeInternal, unit_command_),
  offsetof(::SC2APIProtocol::ActionRawDefaultTypeInternal, camera_move_),
  offsetof(::SC2APIProtocol::ActionRawDefaultTypeInternal, toggle_autocast_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRaw, action_),
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, ability_id_),
  offsetof(::SC2APIProtocol::ActionRawUnitCommandDefaultTypeInternal, target_world_space_pos_),
  offsetof(::SC2APIProtocol::ActionRawUnitCommandDefaultTypeInternal, target_unit_tag_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, unit_tags_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, queue_command_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawUnitCommand, target_),
  0,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawCameraMove, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawCameraMove, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawCameraMove, center_world_space_),
  0,
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, ability_id_),
  PROTOBUF_FIELD_OFFSET(::SC2APIProtocol::ActionRawToggleAutocast, unit_tags_),
  0,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, sizeof(::SC2APIProtocol::StartRaw)},
  { 17, 28, sizeof(::SC2APIProtocol::ObservationRaw)},
  { 34, 41, sizeof(::SC2APIProtocol::RadarRing)},
  { 43, 51, sizeof(::SC2APIProtocol::PowerSource)},
  { 54, 62, sizeof(::SC2APIProtocol::PlayerRaw)},
  { 65, 75, sizeof(::SC2APIProtocol::UnitOrder)},
  { 79, 92, sizeof(::SC2APIProtocol::PassengerUnit)},
  { 100, 107, sizeof(::SC2APIProtocol::RallyTarget)},
  { 109, 158, sizeof(::SC2APIProtocol::Unit)},
  { 202, 209, sizeof(::SC2APIProtocol::MapState)},
  { 211, 217, sizeof(::SC2APIProtocol::Event)},
  { 218, 228, sizeof(::SC2APIProtocol::Effect)},
  { 233, 242, sizeof(::SC2APIProtocol::ActionRaw)},
  { 245, 256, sizeof(::SC2APIProtocol::ActionRawUnitCommand)},
  { 261, 267, sizeof(::SC2APIProtocol::ActionRawCameraMove)},
  { 268, 275, sizeof(::SC2APIProtocol::ActionRawToggleAutocast)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_StartRaw_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_ObservationRaw_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_RadarRing_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_PowerSource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_PlayerRaw_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_UnitOrder_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_PassengerUnit_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_RallyTarget_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_Unit_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_MapState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_Event_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_Effect_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_ActionRaw_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_ActionRawUnitCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_ActionRawCameraMove_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::SC2APIProtocol::_ActionRawToggleAutocast_default_instance_),
};

const char descriptor_table_protodef_s2clientprotocol_2fraw_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\032s2clientprotocol/raw.proto\022\016SC2APIProt"
  "ocol\032\035s2clientprotocol/common.proto\"\261\002\n\010"
  "StartRaw\022)\n\010map_size\030\001 \001(\0132\027.SC2APIProto"
  "col.Size2DI\022/\n\014pathing_grid\030\002 \001(\0132\031.SC2A"
  "PIProtocol.ImageData\0221\n\016terrain_height\030\003"
  " \001(\0132\031.SC2APIProtocol.ImageData\0221\n\016place"
  "ment_grid\030\004 \001(\0132\031.SC2APIProtocol.ImageDa"
  "ta\0221\n\rplayable_area\030\005 \001(\0132\032.SC2APIProtoc"
  "ol.RectangleI\0220\n\017start_locations\030\006 \003(\0132\027"
  ".SC2APIProtocol.Point2D\"\206\002\n\016ObservationR"
  "aw\022)\n\006player\030\001 \001(\0132\031.SC2APIProtocol.Play"
  "erRaw\022#\n\005units\030\002 \003(\0132\024.SC2APIProtocol.Un"
  "it\022+\n\tmap_state\030\003 \001(\0132\030.SC2APIProtocol.M"
  "apState\022$\n\005event\030\004 \001(\0132\025.SC2APIProtocol."
  "Event\022\'\n\007effects\030\005 \003(\0132\026.SC2APIProtocol."
  "Effect\022(\n\005radar\030\006 \003(\0132\031.SC2APIProtocol.R"
  "adarRing\"\?\n\tRadarRing\022\"\n\003pos\030\001 \001(\0132\025.SC2"
  "APIProtocol.Point\022\016\n\006radius\030\002 \001(\002\"N\n\013Pow"
  "erSource\022\"\n\003pos\030\001 \001(\0132\025.SC2APIProtocol.P"
  "oint\022\016\n\006radius\030\002 \001(\002\022\013\n\003tag\030\003 \001(\004\"{\n\tPla"
  "yerRaw\0222\n\rpower_sources\030\001 \003(\0132\033.SC2APIPr"
  "otocol.PowerSource\022%\n\006camera\030\002 \001(\0132\025.SC2"
  "APIProtocol.Point\022\023\n\013upgrade_ids\030\003 \003(\r\"\217"
  "\001\n\tUnitOrder\022\022\n\nability_id\030\001 \001(\r\0227\n\026targ"
  "et_world_space_pos\030\002 \001(\0132\025.SC2APIProtoco"
  "l.PointH\000\022\031\n\017target_unit_tag\030\003 \001(\004H\000\022\020\n\010"
  "progress\030\004 \001(\002B\010\n\006target\"\233\001\n\rPassengerUn"
  "it\022\013\n\003tag\030\001 \001(\004\022\016\n\006health\030\002 \001(\002\022\022\n\nhealt"
  "h_max\030\003 \001(\002\022\016\n\006shield\030\004 \001(\002\022\022\n\nshield_ma"
  "x\030\007 \001(\002\022\016\n\006energy\030\005 \001(\002\022\022\n\nenergy_max\030\010 "
  "\001(\002\022\021\n\tunit_type\030\006 \001(\r\"@\n\013RallyTarget\022$\n"
  "\005point\030\001 \001(\0132\025.SC2APIProtocol.Point\022\013\n\003t"
  "ag\030\002 \001(\004\"\365\010\n\004Unit\0221\n\014display_type\030\001 \001(\0162"
  "\033.SC2APIProtocol.DisplayType\022*\n\010alliance"
  "\030\002 \001(\0162\030.SC2APIProtocol.Alliance\022\013\n\003tag\030"
  "\003 \001(\004\022\021\n\tunit_type\030\004 \001(\r\022\r\n\005owner\030\005 \001(\005\022"
  "\"\n\003pos\030\006 \001(\0132\025.SC2APIProtocol.Point\022\016\n\006f"
  "acing\030\007 \001(\002\022\016\n\006radius\030\010 \001(\002\022\026\n\016build_pro"
  "gress\030\t \001(\002\022)\n\005cloak\030\n \001(\0162\032.SC2APIProto"
  "col.CloakState\022\020\n\010buff_ids\030\033 \003(\r\022\024\n\014dete"
  "ct_range\030\037 \001(\002\022\023\n\013radar_range\030  \001(\002\022\023\n\013i"
  "s_selected\030\013 \001(\010\022\024\n\014is_on_screen\030\014 \001(\010\022\017"
  "\n\007is_blip\030\r \001(\010\022\022\n\nis_powered\030# \001(\010\022\021\n\ti"
  "s_active\030\' \001(\010\022\034\n\024attack_upgrade_level\030("
  " \001(\005\022\033\n\023armor_upgrade_level\030) \001(\005\022\034\n\024shi"
  "eld_upgrade_level\030* \001(\005\022\016\n\006health\030\016 \001(\002\022"
  "\022\n\nhealth_max\030\017 \001(\002\022\016\n\006shield\030\020 \001(\002\022\022\n\ns"
  "hield_max\030$ \001(\002\022\016\n\006energy\030\021 \001(\002\022\022\n\nenerg"
  "y_max\030% \001(\002\022\030\n\020mineral_contents\030\022 \001(\005\022\030\n"
  "\020vespene_contents\030\023 \001(\005\022\021\n\tis_flying\030\024 \001"
  "(\010\022\023\n\013is_burrowed\030\025 \001(\010\022\030\n\020is_hallucinat"
  "ion\030& \001(\010\022)\n\006orders\030\026 \003(\0132\031.SC2APIProtoc"
  "ol.UnitOrder\022\022\n\nadd_on_tag\030\027 \001(\004\0221\n\npass"
  "engers\030\030 \003(\0132\035.SC2APIProtocol.PassengerU"
  "nit\022\031\n\021cargo_space_taken\030\031 \001(\005\022\027\n\017cargo_"
  "space_max\030\032 \001(\005\022\033\n\023assigned_harvesters\030\034"
  " \001(\005\022\030\n\020ideal_harvesters\030\035 \001(\005\022\027\n\017weapon"
  "_cooldown\030\036 \001(\002\022\032\n\022engaged_target_tag\030\" "
  "\001(\004\022\034\n\024buff_duration_remain\030+ \001(\005\022\031\n\021buf"
  "f_duration_max\030, \001(\005\0222\n\rrally_targets\030- "
  "\003(\0132\033.SC2APIProtocol.RallyTarget\"c\n\010MapS"
  "tate\022-\n\nvisibility\030\001 \001(\0132\031.SC2APIProtoco"
  "l.ImageData\022(\n\005creep\030\002 \001(\0132\031.SC2APIProto"
  "col.ImageData\"\033\n\005Event\022\022\n\ndead_units\030\001 \003"
  "(\004\"\214\001\n\006Effect\022\021\n\teffect_id\030\001 \001(\r\022$\n\003pos\030"
  "\002 \003(\0132\027.SC2APIProtocol.Point2D\022*\n\010allian"
  "ce\030\003 \001(\0162\030.SC2APIProtocol.Alliance\022\r\n\005ow"
  "ner\030\004 \001(\005\022\016\n\006radius\030\005 \001(\002\"\323\001\n\tActionRaw\022"
  "<\n\014unit_command\030\001 \001(\0132$.SC2APIProtocol.A"
  "ctionRawUnitCommandH\000\022:\n\013camera_move\030\002 \001"
  "(\0132#.SC2APIProtocol.ActionRawCameraMoveH"
  "\000\022B\n\017toggle_autocast\030\003 \001(\0132\'.SC2APIProto"
  "col.ActionRawToggleAutocastH\000B\010\n\006action\""
  "\264\001\n\024ActionRawUnitCommand\022\022\n\nability_id\030\001"
  " \001(\005\0229\n\026target_world_space_pos\030\002 \001(\0132\027.S"
  "C2APIProtocol.Point2DH\000\022\031\n\017target_unit_t"
  "ag\030\003 \001(\004H\000\022\021\n\tunit_tags\030\004 \003(\004\022\025\n\rqueue_c"
  "ommand\030\005 \001(\010B\010\n\006target\"H\n\023ActionRawCamer"
  "aMove\0221\n\022center_world_space\030\001 \001(\0132\025.SC2A"
  "PIProtocol.Point\"@\n\027ActionRawToggleAutoc"
  "ast\022\022\n\nability_id\030\001 \001(\005\022\021\n\tunit_tags\030\002 \003"
  "(\004*E\n\013DisplayType\022\013\n\007Visible\020\001\022\014\n\010Snapsh"
  "ot\020\002\022\n\n\006Hidden\020\003\022\017\n\013Placeholder\020\004*6\n\010All"
  "iance\022\010\n\004Self\020\001\022\010\n\004Ally\020\002\022\013\n\007Neutral\020\003\022\t"
  "\n\005Enemy\020\004*e\n\nCloakState\022\022\n\016CloakedUnknow"
  "n\020\000\022\013\n\007Cloaked\020\001\022\023\n\017CloakedDetected\020\002\022\016\n"
  "\nNotCloaked\020\003\022\021\n\rCloakedAllied\020\004"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_s2clientprotocol_2fraw_2eproto_deps[1] = {
  &::descriptor_table_s2clientprotocol_2fcommon_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_s2clientprotocol_2fraw_2eproto_sccs[16] = {
  &scc_info_ActionRaw_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_ActionRawToggleAutocast_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_Effect_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_Event_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_MapState_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_ObservationRaw_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_PassengerUnit_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_PowerSource_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_RadarRing_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_RallyTarget_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_StartRaw_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_Unit_s2clientprotocol_2fraw_2eproto.base,
  &scc_info_UnitOrder_s2clientprotocol_2fraw_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_s2clientprotocol_2fraw_2eproto_once;
static bool descriptor_table_s2clientprotocol_2fraw_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_s2clientprotocol_2fraw_2eproto = {
  &descriptor_table_s2clientprotocol_2fraw_2eproto_initialized, descriptor_table_protodef_s2clientprotocol_2fraw_2eproto, "s2clientprotocol/raw.proto", 3472,
  &descriptor_table_s2clientprotocol_2fraw_2eproto_once, descriptor_table_s2clientprotocol_2fraw_2eproto_sccs, descriptor_table_s2clientprotocol_2fraw_2eproto_deps, 16, 1,
  schemas, file_default_instances, TableStruct_s2clientprotocol_2fraw_2eproto::offsets,
  file_level_metadata_s2clientprotocol_2fraw_2eproto, 16, file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto, file_level_service_descriptors_s2clientprotocol_2fraw_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_s2clientprotocol_2fraw_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_s2clientprotocol_2fraw_2eproto)), true);
namespace SC2APIProtocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DisplayType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fraw_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[0];
}
bool DisplayType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alliance_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fraw_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[1];
}
bool Alliance_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CloakState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_s2clientprotocol_2fraw_2eproto);
  return file_level_enum_descriptors_s2clientprotocol_2fraw_2eproto[2];
}
bool CloakState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void StartRaw::InitAsDefaultInstance() {
  ::SC2APIProtocol::_StartRaw_default_instance_._instance.get_mutable()->map_size_ = const_cast< ::SC2APIProtocol::Size2DI*>(
      ::SC2APIProtocol::Size2DI::internal_default_instance());
  ::SC2APIProtocol::_StartRaw_default_instance_._instance.get_mutable()->pathing_grid_ = const_cast< ::SC2APIProtocol::ImageData*>(
      ::SC2APIProtocol::ImageData::internal_default_instance());
  ::SC2APIProtocol::_StartRaw_default_instance_._instance.get_mutable()->terrain_height_ = const_cast< ::SC2APIProtocol::ImageData*>(
      ::SC2APIProtocol::ImageData::internal_default_instance());
  ::SC2APIProtocol::_StartRaw_default_instance_._instance.get_mutable()->placement_grid_ = const_cast< ::SC2APIProtocol::ImageData*>(
      ::SC2APIProtocol::ImageData::internal_default_instance());
  ::SC2APIProtocol::_StartRaw_default_instance_._instance.get_mutable()->playable_area_ = const_cast< ::SC2APIProtocol::RectangleI*>(
      ::SC2APIProtocol::RectangleI::internal_default_instance());
}
class StartRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<StartRaw>()._has_bits_);
  static const ::SC2APIProtocol::Size2DI& map_size(const StartRaw* msg);
  static void set_has_map_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::ImageData& pathing_grid(const StartRaw* msg);
  static void set_has_pathing_grid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SC2APIProtocol::ImageData& terrain_height(const StartRaw* msg);
  static void set_has_terrain_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::SC2APIProtocol::ImageData& placement_grid(const StartRaw* msg);
  static void set_has_placement_grid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::SC2APIProtocol::RectangleI& playable_area(const StartRaw* msg);
  static void set_has_playable_area(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::SC2APIProtocol::Size2DI&
StartRaw::_Internal::map_size(const StartRaw* msg) {
  return *msg->map_size_;
}
const ::SC2APIProtocol::ImageData&
StartRaw::_Internal::pathing_grid(const StartRaw* msg) {
  return *msg->pathing_grid_;
}
const ::SC2APIProtocol::ImageData&
StartRaw::_Internal::terrain_height(const StartRaw* msg) {
  return *msg->terrain_height_;
}
const ::SC2APIProtocol::ImageData&
StartRaw::_Internal::placement_grid(const StartRaw* msg) {
  return *msg->placement_grid_;
}
const ::SC2APIProtocol::RectangleI&
StartRaw::_Internal::playable_area(const StartRaw* msg) {
  return *msg->playable_area_;
}
void StartRaw::clear_map_size() {
  if (map_size_ != nullptr) map_size_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void StartRaw::clear_pathing_grid() {
  if (pathing_grid_ != nullptr) pathing_grid_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void StartRaw::clear_terrain_height() {
  if (terrain_height_ != nullptr) terrain_height_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void StartRaw::clear_placement_grid() {
  if (placement_grid_ != nullptr) placement_grid_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void StartRaw::clear_playable_area() {
  if (playable_area_ != nullptr) playable_area_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void StartRaw::clear_start_locations() {
  start_locations_.Clear();
}
StartRaw::StartRaw()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.StartRaw)
}
StartRaw::StartRaw(const StartRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      start_locations_(from.start_locations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_map_size()) {
    map_size_ = new ::SC2APIProtocol::Size2DI(*from.map_size_);
  } else {
    map_size_ = nullptr;
  }
  if (from._internal_has_pathing_grid()) {
    pathing_grid_ = new ::SC2APIProtocol::ImageData(*from.pathing_grid_);
  } else {
    pathing_grid_ = nullptr;
  }
  if (from._internal_has_terrain_height()) {
    terrain_height_ = new ::SC2APIProtocol::ImageData(*from.terrain_height_);
  } else {
    terrain_height_ = nullptr;
  }
  if (from._internal_has_placement_grid()) {
    placement_grid_ = new ::SC2APIProtocol::ImageData(*from.placement_grid_);
  } else {
    placement_grid_ = nullptr;
  }
  if (from._internal_has_playable_area()) {
    playable_area_ = new ::SC2APIProtocol::RectangleI(*from.playable_area_);
  } else {
    playable_area_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.StartRaw)
}

void StartRaw::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StartRaw_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&map_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&playable_area_) -
      reinterpret_cast<char*>(&map_size_)) + sizeof(playable_area_));
}

StartRaw::~StartRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.StartRaw)
  SharedDtor();
}

void StartRaw::SharedDtor() {
  if (this != internal_default_instance()) delete map_size_;
  if (this != internal_default_instance()) delete pathing_grid_;
  if (this != internal_default_instance()) delete terrain_height_;
  if (this != internal_default_instance()) delete placement_grid_;
  if (this != internal_default_instance()) delete playable_area_;
}

void StartRaw::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StartRaw& StartRaw::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StartRaw_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void StartRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.StartRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  start_locations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(map_size_ != nullptr);
      map_size_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pathing_grid_ != nullptr);
      pathing_grid_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(terrain_height_ != nullptr);
      terrain_height_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(placement_grid_ != nullptr);
      placement_grid_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(playable_area_ != nullptr);
      playable_area_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* StartRaw::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Size2DI map_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_size(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData pathing_grid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathing_grid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData terrain_height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_terrain_height(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData placement_grid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_placement_grid(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.RectangleI playable_area = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_playable_area(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Point2D start_locations = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_start_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StartRaw::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.StartRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Size2DI map_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::map_size(this), target, stream);
  }

  // optional .SC2APIProtocol.ImageData pathing_grid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::pathing_grid(this), target, stream);
  }

  // optional .SC2APIProtocol.ImageData terrain_height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::terrain_height(this), target, stream);
  }

  // optional .SC2APIProtocol.ImageData placement_grid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::placement_grid(this), target, stream);
  }

  // optional .SC2APIProtocol.RectangleI playable_area = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::playable_area(this), target, stream);
  }

  // repeated .SC2APIProtocol.Point2D start_locations = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_start_locations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_start_locations(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.StartRaw)
  return target;
}

size_t StartRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.StartRaw)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Point2D start_locations = 6;
  total_size += 1UL * this->_internal_start_locations_size();
  for (const auto& msg : this->start_locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .SC2APIProtocol.Size2DI map_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *map_size_);
    }

    // optional .SC2APIProtocol.ImageData pathing_grid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pathing_grid_);
    }

    // optional .SC2APIProtocol.ImageData terrain_height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *terrain_height_);
    }

    // optional .SC2APIProtocol.ImageData placement_grid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *placement_grid_);
    }

    // optional .SC2APIProtocol.RectangleI playable_area = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *playable_area_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StartRaw::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.StartRaw)
  GOOGLE_DCHECK_NE(&from, this);
  const StartRaw* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StartRaw>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.StartRaw)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.StartRaw)
    MergeFrom(*source);
  }
}

void StartRaw::MergeFrom(const StartRaw& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.StartRaw)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  start_locations_.MergeFrom(from.start_locations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_map_size()->::SC2APIProtocol::Size2DI::MergeFrom(from._internal_map_size());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_pathing_grid()->::SC2APIProtocol::ImageData::MergeFrom(from._internal_pathing_grid());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_terrain_height()->::SC2APIProtocol::ImageData::MergeFrom(from._internal_terrain_height());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_placement_grid()->::SC2APIProtocol::ImageData::MergeFrom(from._internal_placement_grid());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_playable_area()->::SC2APIProtocol::RectangleI::MergeFrom(from._internal_playable_area());
    }
  }
}

void StartRaw::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.StartRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StartRaw::CopyFrom(const StartRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.StartRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartRaw::IsInitialized() const {
  return true;
}

void StartRaw::InternalSwap(StartRaw* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  start_locations_.InternalSwap(&other->start_locations_);
  swap(map_size_, other->map_size_);
  swap(pathing_grid_, other->pathing_grid_);
  swap(terrain_height_, other->terrain_height_);
  swap(placement_grid_, other->placement_grid_);
  swap(playable_area_, other->playable_area_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StartRaw::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ObservationRaw::InitAsDefaultInstance() {
  ::SC2APIProtocol::_ObservationRaw_default_instance_._instance.get_mutable()->player_ = const_cast< ::SC2APIProtocol::PlayerRaw*>(
      ::SC2APIProtocol::PlayerRaw::internal_default_instance());
  ::SC2APIProtocol::_ObservationRaw_default_instance_._instance.get_mutable()->map_state_ = const_cast< ::SC2APIProtocol::MapState*>(
      ::SC2APIProtocol::MapState::internal_default_instance());
  ::SC2APIProtocol::_ObservationRaw_default_instance_._instance.get_mutable()->event_ = const_cast< ::SC2APIProtocol::Event*>(
      ::SC2APIProtocol::Event::internal_default_instance());
}
class ObservationRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<ObservationRaw>()._has_bits_);
  static const ::SC2APIProtocol::PlayerRaw& player(const ObservationRaw* msg);
  static void set_has_player(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::MapState& map_state(const ObservationRaw* msg);
  static void set_has_map_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::SC2APIProtocol::Event& event(const ObservationRaw* msg);
  static void set_has_event(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::SC2APIProtocol::PlayerRaw&
ObservationRaw::_Internal::player(const ObservationRaw* msg) {
  return *msg->player_;
}
const ::SC2APIProtocol::MapState&
ObservationRaw::_Internal::map_state(const ObservationRaw* msg) {
  return *msg->map_state_;
}
const ::SC2APIProtocol::Event&
ObservationRaw::_Internal::event(const ObservationRaw* msg) {
  return *msg->event_;
}
ObservationRaw::ObservationRaw()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.ObservationRaw)
}
ObservationRaw::ObservationRaw(const ObservationRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      units_(from.units_),
      effects_(from.effects_),
      radar_(from.radar_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_player()) {
    player_ = new ::SC2APIProtocol::PlayerRaw(*from.player_);
  } else {
    player_ = nullptr;
  }
  if (from._internal_has_map_state()) {
    map_state_ = new ::SC2APIProtocol::MapState(*from.map_state_);
  } else {
    map_state_ = nullptr;
  }
  if (from._internal_has_event()) {
    event_ = new ::SC2APIProtocol::Event(*from.event_);
  } else {
    event_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ObservationRaw)
}

void ObservationRaw::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ObservationRaw_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&player_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&event_) -
      reinterpret_cast<char*>(&player_)) + sizeof(event_));
}

ObservationRaw::~ObservationRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ObservationRaw)
  SharedDtor();
}

void ObservationRaw::SharedDtor() {
  if (this != internal_default_instance()) delete player_;
  if (this != internal_default_instance()) delete map_state_;
  if (this != internal_default_instance()) delete event_;
}

void ObservationRaw::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObservationRaw& ObservationRaw::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ObservationRaw_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void ObservationRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ObservationRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  units_.Clear();
  effects_.Clear();
  radar_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(player_ != nullptr);
      player_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(map_state_ != nullptr);
      map_state_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(event_ != nullptr);
      event_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ObservationRaw::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.PlayerRaw player = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Unit units = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_units(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.MapState map_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_map_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Event event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_event(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Effect effects = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_effects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.RadarRing radar = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_radar(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ObservationRaw::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ObservationRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.PlayerRaw player = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::player(this), target, stream);
  }

  // repeated .SC2APIProtocol.Unit units = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_units_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_units(i), target, stream);
  }

  // optional .SC2APIProtocol.MapState map_state = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::map_state(this), target, stream);
  }

  // optional .SC2APIProtocol.Event event = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::event(this), target, stream);
  }

  // repeated .SC2APIProtocol.Effect effects = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_effects_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_effects(i), target, stream);
  }

  // repeated .SC2APIProtocol.RadarRing radar = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_radar_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_radar(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ObservationRaw)
  return target;
}

size_t ObservationRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ObservationRaw)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Unit units = 2;
  total_size += 1UL * this->_internal_units_size();
  for (const auto& msg : this->units_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SC2APIProtocol.Effect effects = 5;
  total_size += 1UL * this->_internal_effects_size();
  for (const auto& msg : this->effects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SC2APIProtocol.RadarRing radar = 6;
  total_size += 1UL * this->_internal_radar_size();
  for (const auto& msg : this->radar_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SC2APIProtocol.PlayerRaw player = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *player_);
    }

    // optional .SC2APIProtocol.MapState map_state = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *map_state_);
    }

    // optional .SC2APIProtocol.Event event = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *event_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObservationRaw::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.ObservationRaw)
  GOOGLE_DCHECK_NE(&from, this);
  const ObservationRaw* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ObservationRaw>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.ObservationRaw)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.ObservationRaw)
    MergeFrom(*source);
  }
}

void ObservationRaw::MergeFrom(const ObservationRaw& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ObservationRaw)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  units_.MergeFrom(from.units_);
  effects_.MergeFrom(from.effects_);
  radar_.MergeFrom(from.radar_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_player()->::SC2APIProtocol::PlayerRaw::MergeFrom(from._internal_player());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_map_state()->::SC2APIProtocol::MapState::MergeFrom(from._internal_map_state());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_event()->::SC2APIProtocol::Event::MergeFrom(from._internal_event());
    }
  }
}

void ObservationRaw::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.ObservationRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObservationRaw::CopyFrom(const ObservationRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ObservationRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObservationRaw::IsInitialized() const {
  return true;
}

void ObservationRaw::InternalSwap(ObservationRaw* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  units_.InternalSwap(&other->units_);
  effects_.InternalSwap(&other->effects_);
  radar_.InternalSwap(&other->radar_);
  swap(player_, other->player_);
  swap(map_state_, other->map_state_);
  swap(event_, other->event_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObservationRaw::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RadarRing::InitAsDefaultInstance() {
  ::SC2APIProtocol::_RadarRing_default_instance_._instance.get_mutable()->pos_ = const_cast< ::SC2APIProtocol::Point*>(
      ::SC2APIProtocol::Point::internal_default_instance());
}
class RadarRing::_Internal {
 public:
  using HasBits = decltype(std::declval<RadarRing>()._has_bits_);
  static const ::SC2APIProtocol::Point& pos(const RadarRing* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
RadarRing::_Internal::pos(const RadarRing* msg) {
  return *msg->pos_;
}
void RadarRing::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
RadarRing::RadarRing()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.RadarRing)
}
RadarRing::RadarRing(const RadarRing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::SC2APIProtocol::Point(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  radius_ = from.radius_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.RadarRing)
}

void RadarRing::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RadarRing_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&radius_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(radius_));
}

RadarRing::~RadarRing() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.RadarRing)
  SharedDtor();
}

void RadarRing::SharedDtor() {
  if (this != internal_default_instance()) delete pos_;
}

void RadarRing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RadarRing& RadarRing::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RadarRing_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void RadarRing::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.RadarRing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(pos_ != nullptr);
    pos_->Clear();
  }
  radius_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RadarRing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RadarRing::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.RadarRing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Point pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pos(this), target, stream);
  }

  // optional float radius = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.RadarRing)
  return target;
}

size_t RadarRing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.RadarRing)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SC2APIProtocol.Point pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional float radius = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RadarRing::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.RadarRing)
  GOOGLE_DCHECK_NE(&from, this);
  const RadarRing* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RadarRing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.RadarRing)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.RadarRing)
    MergeFrom(*source);
  }
}

void RadarRing::MergeFrom(const RadarRing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.RadarRing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::SC2APIProtocol::Point::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      radius_ = from.radius_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RadarRing::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.RadarRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RadarRing::CopyFrom(const RadarRing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.RadarRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarRing::IsInitialized() const {
  return true;
}

void RadarRing::InternalSwap(RadarRing* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pos_, other->pos_);
  swap(radius_, other->radius_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RadarRing::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PowerSource::InitAsDefaultInstance() {
  ::SC2APIProtocol::_PowerSource_default_instance_._instance.get_mutable()->pos_ = const_cast< ::SC2APIProtocol::Point*>(
      ::SC2APIProtocol::Point::internal_default_instance());
}
class PowerSource::_Internal {
 public:
  using HasBits = decltype(std::declval<PowerSource>()._has_bits_);
  static const ::SC2APIProtocol::Point& pos(const PowerSource* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
PowerSource::_Internal::pos(const PowerSource* msg) {
  return *msg->pos_;
}
void PowerSource::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
PowerSource::PowerSource()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.PowerSource)
}
PowerSource::PowerSource(const PowerSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::SC2APIProtocol::Point(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  ::memcpy(&tag_, &from.tag_,
    static_cast<size_t>(reinterpret_cast<char*>(&radius_) -
    reinterpret_cast<char*>(&tag_)) + sizeof(radius_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.PowerSource)
}

void PowerSource::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PowerSource_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&radius_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(radius_));
}

PowerSource::~PowerSource() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.PowerSource)
  SharedDtor();
}

void PowerSource::SharedDtor() {
  if (this != internal_default_instance()) delete pos_;
}

void PowerSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PowerSource& PowerSource::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PowerSource_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void PowerSource::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.PowerSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(pos_ != nullptr);
    pos_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&tag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&radius_) -
        reinterpret_cast<char*>(&tag_)) + sizeof(radius_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PowerSource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint64 tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_tag(&has_bits);
          tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PowerSource::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.PowerSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Point pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pos(this), target, stream);
  }

  // optional float radius = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_radius(), target);
  }

  // optional uint64 tag = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.PowerSource)
  return target;
}

size_t PowerSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.PowerSource)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SC2APIProtocol.Point pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional uint64 tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_tag());
    }

    // optional float radius = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PowerSource::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.PowerSource)
  GOOGLE_DCHECK_NE(&from, this);
  const PowerSource* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PowerSource>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.PowerSource)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.PowerSource)
    MergeFrom(*source);
  }
}

void PowerSource::MergeFrom(const PowerSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.PowerSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::SC2APIProtocol::Point::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      tag_ = from.tag_;
    }
    if (cached_has_bits & 0x00000004u) {
      radius_ = from.radius_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PowerSource::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.PowerSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PowerSource::CopyFrom(const PowerSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.PowerSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PowerSource::IsInitialized() const {
  return true;
}

void PowerSource::InternalSwap(PowerSource* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pos_, other->pos_);
  swap(tag_, other->tag_);
  swap(radius_, other->radius_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PowerSource::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PlayerRaw::InitAsDefaultInstance() {
  ::SC2APIProtocol::_PlayerRaw_default_instance_._instance.get_mutable()->camera_ = const_cast< ::SC2APIProtocol::Point*>(
      ::SC2APIProtocol::Point::internal_default_instance());
}
class PlayerRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerRaw>()._has_bits_);
  static const ::SC2APIProtocol::Point& camera(const PlayerRaw* msg);
  static void set_has_camera(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SC2APIProtocol::Point&
PlayerRaw::_Internal::camera(const PlayerRaw* msg) {
  return *msg->camera_;
}
void PlayerRaw::clear_camera() {
  if (camera_ != nullptr) camera_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
PlayerRaw::PlayerRaw()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.PlayerRaw)
}
PlayerRaw::PlayerRaw(const PlayerRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      power_sources_(from.power_sources_),
      upgrade_ids_(from.upgrade_ids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_camera()) {
    camera_ = new ::SC2APIProtocol::Point(*from.camera_);
  } else {
    camera_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.PlayerRaw)
}

void PlayerRaw::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto.base);
  camera_ = nullptr;
}

PlayerRaw::~PlayerRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.PlayerRaw)
  SharedDtor();
}

void PlayerRaw::SharedDtor() {
  if (this != internal_default_instance()) delete camera_;
}

void PlayerRaw::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PlayerRaw& PlayerRaw::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PlayerRaw_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void PlayerRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.PlayerRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  power_sources_.Clear();
  upgrade_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(camera_ != nullptr);
    camera_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PlayerRaw::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .SC2APIProtocol.PowerSource power_sources = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_power_sources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Point camera = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 upgrade_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_upgrade_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_upgrade_ids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PlayerRaw::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.PlayerRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.PowerSource power_sources = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_power_sources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_power_sources(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Point camera = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::camera(this), target, stream);
  }

  // repeated uint32 upgrade_ids = 3;
  for (int i = 0, n = this->_internal_upgrade_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_upgrade_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.PlayerRaw)
  return target;
}

size_t PlayerRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.PlayerRaw)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.PowerSource power_sources = 1;
  total_size += 1UL * this->_internal_power_sources_size();
  for (const auto& msg : this->power_sources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 upgrade_ids = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->upgrade_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_upgrade_ids_size());
    total_size += data_size;
  }

  // optional .SC2APIProtocol.Point camera = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *camera_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlayerRaw::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.PlayerRaw)
  GOOGLE_DCHECK_NE(&from, this);
  const PlayerRaw* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PlayerRaw>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.PlayerRaw)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.PlayerRaw)
    MergeFrom(*source);
  }
}

void PlayerRaw::MergeFrom(const PlayerRaw& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.PlayerRaw)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  power_sources_.MergeFrom(from.power_sources_);
  upgrade_ids_.MergeFrom(from.upgrade_ids_);
  if (from._internal_has_camera()) {
    _internal_mutable_camera()->::SC2APIProtocol::Point::MergeFrom(from._internal_camera());
  }
}

void PlayerRaw::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.PlayerRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerRaw::CopyFrom(const PlayerRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.PlayerRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerRaw::IsInitialized() const {
  return true;
}

void PlayerRaw::InternalSwap(PlayerRaw* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  power_sources_.InternalSwap(&other->power_sources_);
  upgrade_ids_.InternalSwap(&other->upgrade_ids_);
  swap(camera_, other->camera_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerRaw::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UnitOrder::InitAsDefaultInstance() {
  ::SC2APIProtocol::_UnitOrder_default_instance_.target_world_space_pos_ = const_cast< ::SC2APIProtocol::Point*>(
      ::SC2APIProtocol::Point::internal_default_instance());
  ::SC2APIProtocol::_UnitOrder_default_instance_.target_unit_tag_ = PROTOBUF_ULONGLONG(0);
}
class UnitOrder::_Internal {
 public:
  using HasBits = decltype(std::declval<UnitOrder>()._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::Point& target_world_space_pos(const UnitOrder* msg);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
UnitOrder::_Internal::target_world_space_pos(const UnitOrder* msg) {
  return *msg->target_.target_world_space_pos_;
}
void UnitOrder::set_allocated_target_world_space_pos(::SC2APIProtocol::Point* target_world_space_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_target();
  if (target_world_space_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      target_world_space_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_world_space_pos, submessage_arena);
    }
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.UnitOrder.target_world_space_pos)
}
void UnitOrder::clear_target_world_space_pos() {
  if (_internal_has_target_world_space_pos()) {
    delete target_.target_world_space_pos_;
    clear_has_target();
  }
}
UnitOrder::UnitOrder()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.UnitOrder)
}
UnitOrder::UnitOrder(const UnitOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&ability_id_, &from.ability_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&progress_) -
    reinterpret_cast<char*>(&ability_id_)) + sizeof(progress_));
  clear_has_target();
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point::MergeFrom(from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.UnitOrder)
}

void UnitOrder::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UnitOrder_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&ability_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&progress_) -
      reinterpret_cast<char*>(&ability_id_)) + sizeof(progress_));
  clear_has_target();
}

UnitOrder::~UnitOrder() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.UnitOrder)
  SharedDtor();
}

void UnitOrder::SharedDtor() {
  if (has_target()) {
    clear_target();
  }
}

void UnitOrder::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UnitOrder& UnitOrder::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UnitOrder_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void UnitOrder::clear_target() {
// @@protoc_insertion_point(one_of_clear_start:SC2APIProtocol.UnitOrder)
  switch (target_case()) {
    case kTargetWorldSpacePos: {
      delete target_.target_world_space_pos_;
      break;
    }
    case kTargetUnitTag: {
      // No need to clear
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TARGET_NOT_SET;
}


void UnitOrder::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.UnitOrder)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&progress_) -
        reinterpret_cast<char*>(&ability_id_)) + sizeof(progress_));
  }
  clear_target();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* UnitOrder::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Point target_world_space_pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_world_space_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 target_unit_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_target_unit_tag(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float progress = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_progress(&has_bits);
          progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UnitOrder::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.UnitOrder)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 ability_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ability_id(), target);
  }

  switch (target_case()) {
    case kTargetWorldSpacePos: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          2, _Internal::target_world_space_pos(this), target, stream);
      break;
    }
    case kTargetUnitTag: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_target_unit_tag(), target);
      break;
    }
    default: ;
  }
  // optional float progress = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.UnitOrder)
  return target;
}

size_t UnitOrder::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.UnitOrder)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ability_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ability_id());
    }

    // optional float progress = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  switch (target_case()) {
    // optional .SC2APIProtocol.Point target_world_space_pos = 2;
    case kTargetWorldSpacePos: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *target_.target_world_space_pos_);
      break;
    }
    // optional uint64 target_unit_tag = 3;
    case kTargetUnitTag: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnitOrder::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.UnitOrder)
  GOOGLE_DCHECK_NE(&from, this);
  const UnitOrder* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UnitOrder>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.UnitOrder)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.UnitOrder)
    MergeFrom(*source);
  }
}

void UnitOrder::MergeFrom(const UnitOrder& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.UnitOrder)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ability_id_ = from.ability_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      progress_ = from.progress_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point::MergeFrom(from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
}

void UnitOrder::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.UnitOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnitOrder::CopyFrom(const UnitOrder& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.UnitOrder)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnitOrder::IsInitialized() const {
  return true;
}

void UnitOrder::InternalSwap(UnitOrder* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(ability_id_, other->ability_id_);
  swap(progress_, other->progress_);
  swap(target_, other->target_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata UnitOrder::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PassengerUnit::InitAsDefaultInstance() {
}
class PassengerUnit::_Internal {
 public:
  using HasBits = decltype(std::declval<PassengerUnit>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_health(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_health_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_shield(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shield_max(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_energy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_energy_max(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_unit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

PassengerUnit::PassengerUnit()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.PassengerUnit)
}
PassengerUnit::PassengerUnit(const PassengerUnit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&tag_, &from.tag_,
    static_cast<size_t>(reinterpret_cast<char*>(&energy_max_) -
    reinterpret_cast<char*>(&tag_)) + sizeof(energy_max_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.PassengerUnit)
}

void PassengerUnit::SharedCtor() {
  ::memset(&tag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&energy_max_) -
      reinterpret_cast<char*>(&tag_)) + sizeof(energy_max_));
}

PassengerUnit::~PassengerUnit() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.PassengerUnit)
  SharedDtor();
}

void PassengerUnit::SharedDtor() {
}

void PassengerUnit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PassengerUnit& PassengerUnit::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PassengerUnit_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void PassengerUnit::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.PassengerUnit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&tag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&energy_max_) -
        reinterpret_cast<char*>(&tag_)) + sizeof(energy_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PassengerUnit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tag(&has_bits);
          tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float health = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_health(&has_bits);
          health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float health_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_health_max(&has_bits);
          health_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float shield = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_shield(&has_bits);
          shield_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float energy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_energy(&has_bits);
          energy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 unit_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_unit_type(&has_bits);
          unit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float shield_max = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_shield_max(&has_bits);
          shield_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float energy_max = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_energy_max(&has_bits);
          energy_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PassengerUnit::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.PassengerUnit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 tag = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tag(), target);
  }

  // optional float health = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_health(), target);
  }

  // optional float health_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_health_max(), target);
  }

  // optional float shield = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_shield(), target);
  }

  // optional float energy = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_energy(), target);
  }

  // optional uint32 unit_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_unit_type(), target);
  }

  // optional float shield_max = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_shield_max(), target);
  }

  // optional float energy_max = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_energy_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.PassengerUnit)
  return target;
}

size_t PassengerUnit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.PassengerUnit)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_tag());
    }

    // optional float health = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float health_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float shield = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float energy = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional uint32 unit_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_unit_type());
    }

    // optional float shield_max = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float energy_max = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PassengerUnit::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.PassengerUnit)
  GOOGLE_DCHECK_NE(&from, this);
  const PassengerUnit* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PassengerUnit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.PassengerUnit)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.PassengerUnit)
    MergeFrom(*source);
  }
}

void PassengerUnit::MergeFrom(const PassengerUnit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.PassengerUnit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      tag_ = from.tag_;
    }
    if (cached_has_bits & 0x00000002u) {
      health_ = from.health_;
    }
    if (cached_has_bits & 0x00000004u) {
      health_max_ = from.health_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      shield_ = from.shield_;
    }
    if (cached_has_bits & 0x00000010u) {
      energy_ = from.energy_;
    }
    if (cached_has_bits & 0x00000020u) {
      unit_type_ = from.unit_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      shield_max_ = from.shield_max_;
    }
    if (cached_has_bits & 0x00000080u) {
      energy_max_ = from.energy_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PassengerUnit::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.PassengerUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PassengerUnit::CopyFrom(const PassengerUnit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.PassengerUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassengerUnit::IsInitialized() const {
  return true;
}

void PassengerUnit::InternalSwap(PassengerUnit* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(tag_, other->tag_);
  swap(health_, other->health_);
  swap(health_max_, other->health_max_);
  swap(shield_, other->shield_);
  swap(energy_, other->energy_);
  swap(unit_type_, other->unit_type_);
  swap(shield_max_, other->shield_max_);
  swap(energy_max_, other->energy_max_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PassengerUnit::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RallyTarget::InitAsDefaultInstance() {
  ::SC2APIProtocol::_RallyTarget_default_instance_._instance.get_mutable()->point_ = const_cast< ::SC2APIProtocol::Point*>(
      ::SC2APIProtocol::Point::internal_default_instance());
}
class RallyTarget::_Internal {
 public:
  using HasBits = decltype(std::declval<RallyTarget>()._has_bits_);
  static const ::SC2APIProtocol::Point& point(const RallyTarget* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point&
RallyTarget::_Internal::point(const RallyTarget* msg) {
  return *msg->point_;
}
void RallyTarget::clear_point() {
  if (point_ != nullptr) point_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
RallyTarget::RallyTarget()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.RallyTarget)
}
RallyTarget::RallyTarget(const RallyTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_point()) {
    point_ = new ::SC2APIProtocol::Point(*from.point_);
  } else {
    point_ = nullptr;
  }
  tag_ = from.tag_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.RallyTarget)
}

void RallyTarget::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RallyTarget_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tag_) -
      reinterpret_cast<char*>(&point_)) + sizeof(tag_));
}

RallyTarget::~RallyTarget() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.RallyTarget)
  SharedDtor();
}

void RallyTarget::SharedDtor() {
  if (this != internal_default_instance()) delete point_;
}

void RallyTarget::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RallyTarget& RallyTarget::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RallyTarget_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void RallyTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.RallyTarget)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(point_ != nullptr);
    point_->Clear();
  }
  tag_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RallyTarget::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 tag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_tag(&has_bits);
          tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RallyTarget::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.RallyTarget)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Point point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::point(this), target, stream);
  }

  // optional uint64 tag = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.RallyTarget)
  return target;
}

size_t RallyTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.RallyTarget)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SC2APIProtocol.Point point = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *point_);
    }

    // optional uint64 tag = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_tag());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RallyTarget::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.RallyTarget)
  GOOGLE_DCHECK_NE(&from, this);
  const RallyTarget* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RallyTarget>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.RallyTarget)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.RallyTarget)
    MergeFrom(*source);
  }
}

void RallyTarget::MergeFrom(const RallyTarget& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.RallyTarget)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_point()->::SC2APIProtocol::Point::MergeFrom(from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      tag_ = from.tag_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RallyTarget::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.RallyTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RallyTarget::CopyFrom(const RallyTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.RallyTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RallyTarget::IsInitialized() const {
  return true;
}

void RallyTarget::InternalSwap(RallyTarget* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(point_, other->point_);
  swap(tag_, other->tag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RallyTarget::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Unit::InitAsDefaultInstance() {
  ::SC2APIProtocol::_Unit_default_instance_._instance.get_mutable()->pos_ = const_cast< ::SC2APIProtocol::Point*>(
      ::SC2APIProtocol::Point::internal_default_instance());
}
class Unit::_Internal {
 public:
  using HasBits = decltype(std::declval<Unit>()._has_bits_);
  static void set_has_display_type(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_alliance(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_unit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::SC2APIProtocol::Point& pos(const Unit* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_facing(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_build_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_cloak(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_detect_range(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_radar_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_is_selected(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_on_screen(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_blip(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_powered(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_attack_upgrade_level(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_armor_upgrade_level(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_shield_upgrade_level(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_health(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_health_max(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_shield(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_shield_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_energy(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_energy_max(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_mineral_contents(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_vespene_contents(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_flying(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_is_burrowed(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_is_hallucination(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_add_on_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_cargo_space_taken(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_cargo_space_max(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_assigned_harvesters(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_ideal_harvesters(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_weapon_cooldown(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_engaged_target_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_buff_duration_remain(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_buff_duration_max(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
};

const ::SC2APIProtocol::Point&
Unit::_Internal::pos(const Unit* msg) {
  return *msg->pos_;
}
void Unit::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
Unit::Unit()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.Unit)
}
Unit::Unit(const Unit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      orders_(from.orders_),
      passengers_(from.passengers_),
      buff_ids_(from.buff_ids_),
      rally_targets_(from.rally_targets_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::SC2APIProtocol::Point(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  ::memcpy(&tag_, &from.tag_,
    static_cast<size_t>(reinterpret_cast<char*>(&alliance_) -
    reinterpret_cast<char*>(&tag_)) + sizeof(alliance_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Unit)
}

void Unit::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Unit_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&buff_duration_max_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(buff_duration_max_));
  display_type_ = 1;
  alliance_ = 1;
}

Unit::~Unit() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Unit)
  SharedDtor();
}

void Unit::SharedDtor() {
  if (this != internal_default_instance()) delete pos_;
}

void Unit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Unit& Unit::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Unit_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void Unit::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Unit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  orders_.Clear();
  passengers_.Clear();
  buff_ids_.Clear();
  rally_targets_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(pos_ != nullptr);
    pos_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&tag_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cloak_) -
        reinterpret_cast<char*>(&tag_)) + sizeof(cloak_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&health_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_powered_) -
        reinterpret_cast<char*>(&health_)) + sizeof(is_powered_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&mineral_contents_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_active_) -
        reinterpret_cast<char*>(&mineral_contents_)) + sizeof(is_active_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&is_flying_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&shield_max_) -
        reinterpret_cast<char*>(&is_flying_)) + sizeof(shield_max_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&energy_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&buff_duration_max_) -
        reinterpret_cast<char*>(&energy_max_)) + sizeof(buff_duration_max_));
    display_type_ = 1;
    alliance_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Unit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.DisplayType display_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::DisplayType_IsValid(val))) {
            _internal_set_display_type(static_cast<::SC2APIProtocol::DisplayType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Alliance alliance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Alliance_IsValid(val))) {
            _internal_set_alliance(static_cast<::SC2APIProtocol::Alliance>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_tag(&_has_bits_);
          tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 unit_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_unit_type(&_has_bits_);
          unit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 owner = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_owner(&_has_bits_);
          owner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Point pos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float facing = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_facing(&_has_bits_);
          facing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float radius = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_radius(&_has_bits_);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float build_progress = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_build_progress(&_has_bits_);
          build_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.CloakState cloak = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::CloakState_IsValid(val))) {
            _internal_set_cloak(static_cast<::SC2APIProtocol::CloakState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool is_selected = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_is_selected(&_has_bits_);
          is_selected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_on_screen = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_is_on_screen(&_has_bits_);
          is_on_screen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_blip = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_is_blip(&_has_bits_);
          is_blip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float health = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          _Internal::set_has_health(&_has_bits_);
          health_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float health_max = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_health_max(&_has_bits_);
          health_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float shield = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 133)) {
          _Internal::set_has_shield(&_has_bits_);
          shield_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float energy = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_energy(&_has_bits_);
          energy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 mineral_contents = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_mineral_contents(&_has_bits_);
          mineral_contents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 vespene_contents = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_vespene_contents(&_has_bits_);
          vespene_contents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_flying = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_is_flying(&_has_bits_);
          is_flying_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_burrowed = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_is_burrowed(&_has_bits_);
          is_burrowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.UnitOrder orders = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_orders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 add_on_tag = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_add_on_tag(&_has_bits_);
          add_on_tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_passengers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int32 cargo_space_taken = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_cargo_space_taken(&_has_bits_);
          cargo_space_taken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 cargo_space_max = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_cargo_space_max(&_has_bits_);
          cargo_space_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 buff_ids = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_buff_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<216>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_buff_ids(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 assigned_harvesters = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_assigned_harvesters(&_has_bits_);
          assigned_harvesters_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ideal_harvesters = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_ideal_harvesters(&_has_bits_);
          ideal_harvesters_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float weapon_cooldown = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 245)) {
          _Internal::set_has_weapon_cooldown(&_has_bits_);
          weapon_cooldown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float detect_range = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 253)) {
          _Internal::set_has_detect_range(&_has_bits_);
          detect_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float radar_range = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 5)) {
          _Internal::set_has_radar_range(&_has_bits_);
          radar_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint64 engaged_target_tag = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_engaged_target_tag(&_has_bits_);
          engaged_target_tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_powered = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_is_powered(&_has_bits_);
          is_powered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float shield_max = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_shield_max(&_has_bits_);
          shield_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float energy_max = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_energy_max(&_has_bits_);
          energy_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool is_hallucination = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_is_hallucination(&_has_bits_);
          is_hallucination_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_active = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_is_active(&_has_bits_);
          is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 attack_upgrade_level = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_attack_upgrade_level(&_has_bits_);
          attack_upgrade_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 armor_upgrade_level = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_armor_upgrade_level(&_has_bits_);
          armor_upgrade_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 shield_upgrade_level = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_shield_upgrade_level(&_has_bits_);
          shield_upgrade_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 buff_duration_remain = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_buff_duration_remain(&_has_bits_);
          buff_duration_remain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 buff_duration_max = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_buff_duration_max(&_has_bits_);
          buff_duration_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_rally_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<362>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Unit::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Unit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[1];
  // optional .SC2APIProtocol.DisplayType display_type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_display_type(), target);
  }

  // optional .SC2APIProtocol.Alliance alliance = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_alliance(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint64 tag = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_tag(), target);
  }

  // optional uint32 unit_type = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_unit_type(), target);
  }

  // optional int32 owner = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_owner(), target);
  }

  // optional .SC2APIProtocol.Point pos = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::pos(this), target, stream);
  }

  // optional float facing = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_facing(), target);
  }

  // optional float radius = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_radius(), target);
  }

  // optional float build_progress = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_build_progress(), target);
  }

  // optional .SC2APIProtocol.CloakState cloak = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_cloak(), target);
  }

  // optional bool is_selected = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_is_selected(), target);
  }

  // optional bool is_on_screen = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_on_screen(), target);
  }

  // optional bool is_blip = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_is_blip(), target);
  }

  // optional float health = 14;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_health(), target);
  }

  // optional float health_max = 15;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_health_max(), target);
  }

  // optional float shield = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(16, this->_internal_shield(), target);
  }

  // optional float energy = 17;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_energy(), target);
  }

  // optional int32 mineral_contents = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(18, this->_internal_mineral_contents(), target);
  }

  // optional int32 vespene_contents = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(19, this->_internal_vespene_contents(), target);
  }

  // optional bool is_flying = 20;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_is_flying(), target);
  }

  // optional bool is_burrowed = 21;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_is_burrowed(), target);
  }

  // repeated .SC2APIProtocol.UnitOrder orders = 22;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_orders_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, this->_internal_orders(i), target, stream);
  }

  // optional uint64 add_on_tag = 23;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(23, this->_internal_add_on_tag(), target);
  }

  // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_passengers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, this->_internal_passengers(i), target, stream);
  }

  // optional int32 cargo_space_taken = 25;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(25, this->_internal_cargo_space_taken(), target);
  }

  // optional int32 cargo_space_max = 26;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(26, this->_internal_cargo_space_max(), target);
  }

  // repeated uint32 buff_ids = 27;
  for (int i = 0, n = this->_internal_buff_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(27, this->_internal_buff_ids(i), target);
  }

  // optional int32 assigned_harvesters = 28;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(28, this->_internal_assigned_harvesters(), target);
  }

  // optional int32 ideal_harvesters = 29;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_ideal_harvesters(), target);
  }

  // optional float weapon_cooldown = 30;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(30, this->_internal_weapon_cooldown(), target);
  }

  // optional float detect_range = 31;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(31, this->_internal_detect_range(), target);
  }

  // optional float radar_range = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(32, this->_internal_radar_range(), target);
  }

  // optional uint64 engaged_target_tag = 34;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(34, this->_internal_engaged_target_tag(), target);
  }

  // optional bool is_powered = 35;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(35, this->_internal_is_powered(), target);
  }

  // optional float shield_max = 36;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(36, this->_internal_shield_max(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional float energy_max = 37;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(37, this->_internal_energy_max(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool is_hallucination = 38;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(38, this->_internal_is_hallucination(), target);
  }

  // optional bool is_active = 39;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(39, this->_internal_is_active(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 attack_upgrade_level = 40;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(40, this->_internal_attack_upgrade_level(), target);
  }

  // optional int32 armor_upgrade_level = 41;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(41, this->_internal_armor_upgrade_level(), target);
  }

  // optional int32 shield_upgrade_level = 42;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(42, this->_internal_shield_upgrade_level(), target);
  }

  // optional int32 buff_duration_remain = 43;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(43, this->_internal_buff_duration_remain(), target);
  }

  // optional int32 buff_duration_max = 44;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(44, this->_internal_buff_duration_max(), target);
  }

  // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_rally_targets_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(45, this->_internal_rally_targets(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Unit)
  return target;
}

size_t Unit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Unit)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.UnitOrder orders = 22;
  total_size += 2UL * this->_internal_orders_size();
  for (const auto& msg : this->orders_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SC2APIProtocol.PassengerUnit passengers = 24;
  total_size += 2UL * this->_internal_passengers_size();
  for (const auto& msg : this->passengers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 buff_ids = 27;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->buff_ids_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_buff_ids_size());
    total_size += data_size;
  }

  // repeated .SC2APIProtocol.RallyTarget rally_targets = 45;
  total_size += 2UL * this->_internal_rally_targets_size();
  for (const auto& msg : this->rally_targets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .SC2APIProtocol.Point pos = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional uint64 tag = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_tag());
    }

    // optional uint32 unit_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_unit_type());
    }

    // optional int32 owner = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_owner());
    }

    // optional float facing = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float radius = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float build_progress = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.CloakState cloak = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cloak());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float health = 14;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float health_max = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float shield = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 4;
    }

    // optional float energy = 17;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 4;
    }

    // optional bool is_selected = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_on_screen = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool is_blip = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool is_powered = 35;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 mineral_contents = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_mineral_contents());
    }

    // optional int32 vespene_contents = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_vespene_contents());
    }

    // optional int32 cargo_space_taken = 25;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_cargo_space_taken());
    }

    // optional uint64 add_on_tag = 23;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_add_on_tag());
    }

    // optional int32 cargo_space_max = 26;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_cargo_space_max());
    }

    // optional int32 assigned_harvesters = 28;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_assigned_harvesters());
    }

    // optional int32 ideal_harvesters = 29;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_ideal_harvesters());
    }

    // optional bool is_active = 39;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool is_flying = 20;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_burrowed = 21;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_hallucination = 38;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional float weapon_cooldown = 30;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 4;
    }

    // optional float detect_range = 31;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 4;
    }

    // optional uint64 engaged_target_tag = 34;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_engaged_target_tag());
    }

    // optional float radar_range = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 4;
    }

    // optional float shield_max = 36;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 4;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional float energy_max = 37;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 4;
    }

    // optional int32 attack_upgrade_level = 40;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_attack_upgrade_level());
    }

    // optional int32 armor_upgrade_level = 41;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_armor_upgrade_level());
    }

    // optional int32 shield_upgrade_level = 42;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_shield_upgrade_level());
    }

    // optional int32 buff_duration_remain = 43;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_buff_duration_remain());
    }

    // optional int32 buff_duration_max = 44;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_buff_duration_max());
    }

    // optional .SC2APIProtocol.DisplayType display_type = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_display_type());
    }

    // optional .SC2APIProtocol.Alliance alliance = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_alliance());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Unit::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.Unit)
  GOOGLE_DCHECK_NE(&from, this);
  const Unit* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Unit>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.Unit)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.Unit)
    MergeFrom(*source);
  }
}

void Unit::MergeFrom(const Unit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Unit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  orders_.MergeFrom(from.orders_);
  passengers_.MergeFrom(from.passengers_);
  buff_ids_.MergeFrom(from.buff_ids_);
  rally_targets_.MergeFrom(from.rally_targets_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::SC2APIProtocol::Point::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      tag_ = from.tag_;
    }
    if (cached_has_bits & 0x00000004u) {
      unit_type_ = from.unit_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      owner_ = from.owner_;
    }
    if (cached_has_bits & 0x00000010u) {
      facing_ = from.facing_;
    }
    if (cached_has_bits & 0x00000020u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000040u) {
      build_progress_ = from.build_progress_;
    }
    if (cached_has_bits & 0x00000080u) {
      cloak_ = from.cloak_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      health_ = from.health_;
    }
    if (cached_has_bits & 0x00000200u) {
      health_max_ = from.health_max_;
    }
    if (cached_has_bits & 0x00000400u) {
      shield_ = from.shield_;
    }
    if (cached_has_bits & 0x00000800u) {
      energy_ = from.energy_;
    }
    if (cached_has_bits & 0x00001000u) {
      is_selected_ = from.is_selected_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_on_screen_ = from.is_on_screen_;
    }
    if (cached_has_bits & 0x00004000u) {
      is_blip_ = from.is_blip_;
    }
    if (cached_has_bits & 0x00008000u) {
      is_powered_ = from.is_powered_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      mineral_contents_ = from.mineral_contents_;
    }
    if (cached_has_bits & 0x00020000u) {
      vespene_contents_ = from.vespene_contents_;
    }
    if (cached_has_bits & 0x00040000u) {
      cargo_space_taken_ = from.cargo_space_taken_;
    }
    if (cached_has_bits & 0x00080000u) {
      add_on_tag_ = from.add_on_tag_;
    }
    if (cached_has_bits & 0x00100000u) {
      cargo_space_max_ = from.cargo_space_max_;
    }
    if (cached_has_bits & 0x00200000u) {
      assigned_harvesters_ = from.assigned_harvesters_;
    }
    if (cached_has_bits & 0x00400000u) {
      ideal_harvesters_ = from.ideal_harvesters_;
    }
    if (cached_has_bits & 0x00800000u) {
      is_active_ = from.is_active_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      is_flying_ = from.is_flying_;
    }
    if (cached_has_bits & 0x02000000u) {
      is_burrowed_ = from.is_burrowed_;
    }
    if (cached_has_bits & 0x04000000u) {
      is_hallucination_ = from.is_hallucination_;
    }
    if (cached_has_bits & 0x08000000u) {
      weapon_cooldown_ = from.weapon_cooldown_;
    }
    if (cached_has_bits & 0x10000000u) {
      detect_range_ = from.detect_range_;
    }
    if (cached_has_bits & 0x20000000u) {
      engaged_target_tag_ = from.engaged_target_tag_;
    }
    if (cached_has_bits & 0x40000000u) {
      radar_range_ = from.radar_range_;
    }
    if (cached_has_bits & 0x80000000u) {
      shield_max_ = from.shield_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      energy_max_ = from.energy_max_;
    }
    if (cached_has_bits & 0x00000002u) {
      attack_upgrade_level_ = from.attack_upgrade_level_;
    }
    if (cached_has_bits & 0x00000004u) {
      armor_upgrade_level_ = from.armor_upgrade_level_;
    }
    if (cached_has_bits & 0x00000008u) {
      shield_upgrade_level_ = from.shield_upgrade_level_;
    }
    if (cached_has_bits & 0x00000010u) {
      buff_duration_remain_ = from.buff_duration_remain_;
    }
    if (cached_has_bits & 0x00000020u) {
      buff_duration_max_ = from.buff_duration_max_;
    }
    if (cached_has_bits & 0x00000040u) {
      display_type_ = from.display_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      alliance_ = from.alliance_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
}

void Unit::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.Unit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Unit::CopyFrom(const Unit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Unit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unit::IsInitialized() const {
  return true;
}

void Unit::InternalSwap(Unit* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  orders_.InternalSwap(&other->orders_);
  passengers_.InternalSwap(&other->passengers_);
  buff_ids_.InternalSwap(&other->buff_ids_);
  rally_targets_.InternalSwap(&other->rally_targets_);
  swap(pos_, other->pos_);
  swap(tag_, other->tag_);
  swap(unit_type_, other->unit_type_);
  swap(owner_, other->owner_);
  swap(facing_, other->facing_);
  swap(radius_, other->radius_);
  swap(build_progress_, other->build_progress_);
  swap(cloak_, other->cloak_);
  swap(health_, other->health_);
  swap(health_max_, other->health_max_);
  swap(shield_, other->shield_);
  swap(energy_, other->energy_);
  swap(is_selected_, other->is_selected_);
  swap(is_on_screen_, other->is_on_screen_);
  swap(is_blip_, other->is_blip_);
  swap(is_powered_, other->is_powered_);
  swap(mineral_contents_, other->mineral_contents_);
  swap(vespene_contents_, other->vespene_contents_);
  swap(cargo_space_taken_, other->cargo_space_taken_);
  swap(add_on_tag_, other->add_on_tag_);
  swap(cargo_space_max_, other->cargo_space_max_);
  swap(assigned_harvesters_, other->assigned_harvesters_);
  swap(ideal_harvesters_, other->ideal_harvesters_);
  swap(is_active_, other->is_active_);
  swap(is_flying_, other->is_flying_);
  swap(is_burrowed_, other->is_burrowed_);
  swap(is_hallucination_, other->is_hallucination_);
  swap(weapon_cooldown_, other->weapon_cooldown_);
  swap(detect_range_, other->detect_range_);
  swap(engaged_target_tag_, other->engaged_target_tag_);
  swap(radar_range_, other->radar_range_);
  swap(shield_max_, other->shield_max_);
  swap(energy_max_, other->energy_max_);
  swap(attack_upgrade_level_, other->attack_upgrade_level_);
  swap(armor_upgrade_level_, other->armor_upgrade_level_);
  swap(shield_upgrade_level_, other->shield_upgrade_level_);
  swap(buff_duration_remain_, other->buff_duration_remain_);
  swap(buff_duration_max_, other->buff_duration_max_);
  swap(display_type_, other->display_type_);
  swap(alliance_, other->alliance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Unit::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MapState::InitAsDefaultInstance() {
  ::SC2APIProtocol::_MapState_default_instance_._instance.get_mutable()->visibility_ = const_cast< ::SC2APIProtocol::ImageData*>(
      ::SC2APIProtocol::ImageData::internal_default_instance());
  ::SC2APIProtocol::_MapState_default_instance_._instance.get_mutable()->creep_ = const_cast< ::SC2APIProtocol::ImageData*>(
      ::SC2APIProtocol::ImageData::internal_default_instance());
}
class MapState::_Internal {
 public:
  using HasBits = decltype(std::declval<MapState>()._has_bits_);
  static const ::SC2APIProtocol::ImageData& visibility(const MapState* msg);
  static void set_has_visibility(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::ImageData& creep(const MapState* msg);
  static void set_has_creep(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::ImageData&
MapState::_Internal::visibility(const MapState* msg) {
  return *msg->visibility_;
}
const ::SC2APIProtocol::ImageData&
MapState::_Internal::creep(const MapState* msg) {
  return *msg->creep_;
}
void MapState::clear_visibility() {
  if (visibility_ != nullptr) visibility_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void MapState::clear_creep() {
  if (creep_ != nullptr) creep_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
MapState::MapState()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.MapState)
}
MapState::MapState(const MapState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_visibility()) {
    visibility_ = new ::SC2APIProtocol::ImageData(*from.visibility_);
  } else {
    visibility_ = nullptr;
  }
  if (from._internal_has_creep()) {
    creep_ = new ::SC2APIProtocol::ImageData(*from.creep_);
  } else {
    creep_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.MapState)
}

void MapState::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MapState_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&visibility_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&creep_) -
      reinterpret_cast<char*>(&visibility_)) + sizeof(creep_));
}

MapState::~MapState() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.MapState)
  SharedDtor();
}

void MapState::SharedDtor() {
  if (this != internal_default_instance()) delete visibility_;
  if (this != internal_default_instance()) delete creep_;
}

void MapState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MapState& MapState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MapState_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void MapState::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.MapState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(visibility_ != nullptr);
      visibility_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(creep_ != nullptr);
      creep_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* MapState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.ImageData visibility = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_visibility(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ImageData creep = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_creep(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MapState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.MapState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.ImageData visibility = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::visibility(this), target, stream);
  }

  // optional .SC2APIProtocol.ImageData creep = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::creep(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.MapState)
  return target;
}

size_t MapState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.MapState)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SC2APIProtocol.ImageData visibility = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *visibility_);
    }

    // optional .SC2APIProtocol.ImageData creep = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *creep_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.MapState)
  GOOGLE_DCHECK_NE(&from, this);
  const MapState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MapState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.MapState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.MapState)
    MergeFrom(*source);
  }
}

void MapState::MergeFrom(const MapState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.MapState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_visibility()->::SC2APIProtocol::ImageData::MergeFrom(from._internal_visibility());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_creep()->::SC2APIProtocol::ImageData::MergeFrom(from._internal_creep());
    }
  }
}

void MapState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.MapState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapState::CopyFrom(const MapState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.MapState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapState::IsInitialized() const {
  return true;
}

void MapState::InternalSwap(MapState* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(visibility_, other->visibility_);
  swap(creep_, other->creep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MapState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Event::InitAsDefaultInstance() {
}
class Event::_Internal {
 public:
  using HasBits = decltype(std::declval<Event>()._has_bits_);
};

Event::Event()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.Event)
}
Event::Event(const Event& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      dead_units_(from.dead_units_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Event)
}

void Event::SharedCtor() {
}

Event::~Event() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Event)
  SharedDtor();
}

void Event::SharedDtor() {
}

void Event::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Event& Event::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Event_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Event)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dead_units_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Event::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated uint64 dead_units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dead_units(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_dead_units(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Event::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Event)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 dead_units = 1;
  for (int i = 0, n = this->_internal_dead_units_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dead_units(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Event)
  return target;
}

size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Event)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 dead_units = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->dead_units_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_dead_units_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Event::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.Event)
  GOOGLE_DCHECK_NE(&from, this);
  const Event* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Event>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.Event)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.Event)
    MergeFrom(*source);
  }
}

void Event::MergeFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Event)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dead_units_.MergeFrom(from.dead_units_);
}

void Event::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  return true;
}

void Event::InternalSwap(Event* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dead_units_.InternalSwap(&other->dead_units_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Event::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Effect::InitAsDefaultInstance() {
}
class Effect::_Internal {
 public:
  using HasBits = decltype(std::declval<Effect>()._has_bits_);
  static void set_has_effect_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alliance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

void Effect::clear_pos() {
  pos_.Clear();
}
Effect::Effect()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.Effect)
}
Effect::Effect(const Effect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      pos_(from.pos_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&effect_id_, &from.effect_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&alliance_) -
    reinterpret_cast<char*>(&effect_id_)) + sizeof(alliance_));
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.Effect)
}

void Effect::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Effect_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&effect_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&radius_) -
      reinterpret_cast<char*>(&effect_id_)) + sizeof(radius_));
  alliance_ = 1;
}

Effect::~Effect() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.Effect)
  SharedDtor();
}

void Effect::SharedDtor() {
}

void Effect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Effect& Effect::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Effect_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void Effect::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.Effect)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&effect_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&radius_) -
        reinterpret_cast<char*>(&effect_id_)) + sizeof(radius_));
    alliance_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Effect::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 effect_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_effect_id(&has_bits);
          effect_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SC2APIProtocol.Point2D pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Alliance alliance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SC2APIProtocol::Alliance_IsValid(val))) {
            _internal_set_alliance(static_cast<::SC2APIProtocol::Alliance>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 owner = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_owner(&has_bits);
          owner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Effect::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.Effect)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 effect_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_effect_id(), target);
  }

  // repeated .SC2APIProtocol.Point2D pos = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_pos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_pos(i), target, stream);
  }

  // optional .SC2APIProtocol.Alliance alliance = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_alliance(), target);
  }

  // optional int32 owner = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_owner(), target);
  }

  // optional float radius = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.Effect)
  return target;
}

size_t Effect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.Effect)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SC2APIProtocol.Point2D pos = 2;
  total_size += 1UL * this->_internal_pos_size();
  for (const auto& msg : this->pos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 effect_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_effect_id());
    }

    // optional int32 owner = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_owner());
    }

    // optional float radius = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional .SC2APIProtocol.Alliance alliance = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_alliance());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Effect::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.Effect)
  GOOGLE_DCHECK_NE(&from, this);
  const Effect* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Effect>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.Effect)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.Effect)
    MergeFrom(*source);
  }
}

void Effect::MergeFrom(const Effect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.Effect)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  pos_.MergeFrom(from.pos_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      effect_id_ = from.effect_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      owner_ = from.owner_;
    }
    if (cached_has_bits & 0x00000004u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000008u) {
      alliance_ = from.alliance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Effect::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.Effect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Effect::CopyFrom(const Effect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.Effect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Effect::IsInitialized() const {
  return true;
}

void Effect::InternalSwap(Effect* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  pos_.InternalSwap(&other->pos_);
  swap(effect_id_, other->effect_id_);
  swap(owner_, other->owner_);
  swap(radius_, other->radius_);
  swap(alliance_, other->alliance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Effect::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ActionRaw::InitAsDefaultInstance() {
  ::SC2APIProtocol::_ActionRaw_default_instance_.unit_command_ = const_cast< ::SC2APIProtocol::ActionRawUnitCommand*>(
      ::SC2APIProtocol::ActionRawUnitCommand::internal_default_instance());
  ::SC2APIProtocol::_ActionRaw_default_instance_.camera_move_ = const_cast< ::SC2APIProtocol::ActionRawCameraMove*>(
      ::SC2APIProtocol::ActionRawCameraMove::internal_default_instance());
  ::SC2APIProtocol::_ActionRaw_default_instance_.toggle_autocast_ = const_cast< ::SC2APIProtocol::ActionRawToggleAutocast*>(
      ::SC2APIProtocol::ActionRawToggleAutocast::internal_default_instance());
}
class ActionRaw::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionRaw>()._has_bits_);
  static const ::SC2APIProtocol::ActionRawUnitCommand& unit_command(const ActionRaw* msg);
  static const ::SC2APIProtocol::ActionRawCameraMove& camera_move(const ActionRaw* msg);
  static const ::SC2APIProtocol::ActionRawToggleAutocast& toggle_autocast(const ActionRaw* msg);
};

const ::SC2APIProtocol::ActionRawUnitCommand&
ActionRaw::_Internal::unit_command(const ActionRaw* msg) {
  return *msg->action_.unit_command_;
}
const ::SC2APIProtocol::ActionRawCameraMove&
ActionRaw::_Internal::camera_move(const ActionRaw* msg) {
  return *msg->action_.camera_move_;
}
const ::SC2APIProtocol::ActionRawToggleAutocast&
ActionRaw::_Internal::toggle_autocast(const ActionRaw* msg) {
  return *msg->action_.toggle_autocast_;
}
void ActionRaw::set_allocated_unit_command(::SC2APIProtocol::ActionRawUnitCommand* unit_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (unit_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unit_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unit_command, submessage_arena);
    }
    set_has_unit_command();
    action_.unit_command_ = unit_command;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.unit_command)
}
void ActionRaw::set_allocated_camera_move(::SC2APIProtocol::ActionRawCameraMove* camera_move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (camera_move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      camera_move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_move, submessage_arena);
    }
    set_has_camera_move();
    action_.camera_move_ = camera_move;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.camera_move)
}
void ActionRaw::set_allocated_toggle_autocast(::SC2APIProtocol::ActionRawToggleAutocast* toggle_autocast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_action();
  if (toggle_autocast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      toggle_autocast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, toggle_autocast, submessage_arena);
    }
    set_has_toggle_autocast();
    action_.toggle_autocast_ = toggle_autocast;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRaw.toggle_autocast)
}
ActionRaw::ActionRaw()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.ActionRaw)
}
ActionRaw::ActionRaw(const ActionRaw& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_action();
  switch (from.action_case()) {
    case kUnitCommand: {
      _internal_mutable_unit_command()->::SC2APIProtocol::ActionRawUnitCommand::MergeFrom(from._internal_unit_command());
      break;
    }
    case kCameraMove: {
      _internal_mutable_camera_move()->::SC2APIProtocol::ActionRawCameraMove::MergeFrom(from._internal_camera_move());
      break;
    }
    case kToggleAutocast: {
      _internal_mutable_toggle_autocast()->::SC2APIProtocol::ActionRawToggleAutocast::MergeFrom(from._internal_toggle_autocast());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRaw)
}

void ActionRaw::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ActionRaw_s2clientprotocol_2fraw_2eproto.base);
  clear_has_action();
}

ActionRaw::~ActionRaw() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRaw)
  SharedDtor();
}

void ActionRaw::SharedDtor() {
  if (has_action()) {
    clear_action();
  }
}

void ActionRaw::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ActionRaw& ActionRaw::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ActionRaw_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void ActionRaw::clear_action() {
// @@protoc_insertion_point(one_of_clear_start:SC2APIProtocol.ActionRaw)
  switch (action_case()) {
    case kUnitCommand: {
      delete action_.unit_command_;
      break;
    }
    case kCameraMove: {
      delete action_.camera_move_;
      break;
    }
    case kToggleAutocast: {
      delete action_.toggle_autocast_;
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ACTION_NOT_SET;
}


void ActionRaw::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_action();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ActionRaw::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_unit_command(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera_move(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_toggle_autocast(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ActionRaw::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRaw)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (action_case()) {
    case kUnitCommand: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          1, _Internal::unit_command(this), target, stream);
      break;
    }
    case kCameraMove: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          2, _Internal::camera_move(this), target, stream);
      break;
    }
    case kToggleAutocast: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::toggle_autocast(this), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRaw)
  return target;
}

size_t ActionRaw::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRaw)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (action_case()) {
    // optional .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;
    case kUnitCommand: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_.unit_command_);
      break;
    }
    // optional .SC2APIProtocol.ActionRawCameraMove camera_move = 2;
    case kCameraMove: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_.camera_move_);
      break;
    }
    // optional .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;
    case kToggleAutocast: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_.toggle_autocast_);
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionRaw::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.ActionRaw)
  GOOGLE_DCHECK_NE(&from, this);
  const ActionRaw* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ActionRaw>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.ActionRaw)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.ActionRaw)
    MergeFrom(*source);
  }
}

void ActionRaw::MergeFrom(const ActionRaw& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRaw)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.action_case()) {
    case kUnitCommand: {
      _internal_mutable_unit_command()->::SC2APIProtocol::ActionRawUnitCommand::MergeFrom(from._internal_unit_command());
      break;
    }
    case kCameraMove: {
      _internal_mutable_camera_move()->::SC2APIProtocol::ActionRawCameraMove::MergeFrom(from._internal_camera_move());
      break;
    }
    case kToggleAutocast: {
      _internal_mutable_toggle_autocast()->::SC2APIProtocol::ActionRawToggleAutocast::MergeFrom(from._internal_toggle_autocast());
      break;
    }
    case ACTION_NOT_SET: {
      break;
    }
  }
}

void ActionRaw::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.ActionRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ActionRaw::CopyFrom(const ActionRaw& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRaw)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRaw::IsInitialized() const {
  return true;
}

void ActionRaw::InternalSwap(ActionRaw* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(action_, other->action_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRaw::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ActionRawUnitCommand::InitAsDefaultInstance() {
  ::SC2APIProtocol::_ActionRawUnitCommand_default_instance_.target_world_space_pos_ = const_cast< ::SC2APIProtocol::Point2D*>(
      ::SC2APIProtocol::Point2D::internal_default_instance());
  ::SC2APIProtocol::_ActionRawUnitCommand_default_instance_.target_unit_tag_ = PROTOBUF_ULONGLONG(0);
}
class ActionRawUnitCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionRawUnitCommand>()._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::SC2APIProtocol::Point2D& target_world_space_pos(const ActionRawUnitCommand* msg);
  static void set_has_queue_command(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SC2APIProtocol::Point2D&
ActionRawUnitCommand::_Internal::target_world_space_pos(const ActionRawUnitCommand* msg) {
  return *msg->target_.target_world_space_pos_;
}
void ActionRawUnitCommand::set_allocated_target_world_space_pos(::SC2APIProtocol::Point2D* target_world_space_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_target();
  if (target_world_space_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      target_world_space_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_world_space_pos, submessage_arena);
    }
    set_has_target_world_space_pos();
    target_.target_world_space_pos_ = target_world_space_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
}
void ActionRawUnitCommand::clear_target_world_space_pos() {
  if (_internal_has_target_world_space_pos()) {
    delete target_.target_world_space_pos_;
    clear_has_target();
  }
}
ActionRawUnitCommand::ActionRawUnitCommand()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.ActionRawUnitCommand)
}
ActionRawUnitCommand::ActionRawUnitCommand(const ActionRawUnitCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      unit_tags_(from.unit_tags_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&ability_id_, &from.ability_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&queue_command_) -
    reinterpret_cast<char*>(&ability_id_)) + sizeof(queue_command_));
  clear_has_target();
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point2D::MergeFrom(from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRawUnitCommand)
}

void ActionRawUnitCommand::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto.base);
  ::memset(&ability_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&queue_command_) -
      reinterpret_cast<char*>(&ability_id_)) + sizeof(queue_command_));
  clear_has_target();
}

ActionRawUnitCommand::~ActionRawUnitCommand() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRawUnitCommand)
  SharedDtor();
}

void ActionRawUnitCommand::SharedDtor() {
  if (has_target()) {
    clear_target();
  }
}

void ActionRawUnitCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ActionRawUnitCommand& ActionRawUnitCommand::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ActionRawUnitCommand_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void ActionRawUnitCommand::clear_target() {
// @@protoc_insertion_point(one_of_clear_start:SC2APIProtocol.ActionRawUnitCommand)
  switch (target_case()) {
    case kTargetWorldSpacePos: {
      delete target_.target_world_space_pos_;
      break;
    }
    case kTargetUnitTag: {
      // No need to clear
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TARGET_NOT_SET;
}


void ActionRawUnitCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRawUnitCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  unit_tags_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ability_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&queue_command_) -
        reinterpret_cast<char*>(&ability_id_)) + sizeof(queue_command_));
  }
  clear_target();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ActionRawUnitCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SC2APIProtocol.Point2D target_world_space_pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_world_space_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 target_unit_tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _internal_set_target_unit_tag(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 unit_tags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_unit_tags(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_unit_tags(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool queue_command = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_queue_command(&has_bits);
          queue_command_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ActionRawUnitCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRawUnitCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 ability_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_ability_id(), target);
  }

  switch (target_case()) {
    case kTargetWorldSpacePos: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          2, _Internal::target_world_space_pos(this), target, stream);
      break;
    }
    case kTargetUnitTag: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_target_unit_tag(), target);
      break;
    }
    default: ;
  }
  // repeated uint64 unit_tags = 4;
  for (int i = 0, n = this->_internal_unit_tags_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_unit_tags(i), target);
  }

  // optional bool queue_command = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_queue_command(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRawUnitCommand)
  return target;
}

size_t ActionRawUnitCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRawUnitCommand)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 unit_tags = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->unit_tags_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_unit_tags_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 ability_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_ability_id());
    }

    // optional bool queue_command = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  switch (target_case()) {
    // optional .SC2APIProtocol.Point2D target_world_space_pos = 2;
    case kTargetWorldSpacePos: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *target_.target_world_space_pos_);
      break;
    }
    // optional uint64 target_unit_tag = 3;
    case kTargetUnitTag: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionRawUnitCommand::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.ActionRawUnitCommand)
  GOOGLE_DCHECK_NE(&from, this);
  const ActionRawUnitCommand* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ActionRawUnitCommand>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.ActionRawUnitCommand)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.ActionRawUnitCommand)
    MergeFrom(*source);
  }
}

void ActionRawUnitCommand::MergeFrom(const ActionRawUnitCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRawUnitCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  unit_tags_.MergeFrom(from.unit_tags_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ability_id_ = from.ability_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      queue_command_ = from.queue_command_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.target_case()) {
    case kTargetWorldSpacePos: {
      _internal_mutable_target_world_space_pos()->::SC2APIProtocol::Point2D::MergeFrom(from._internal_target_world_space_pos());
      break;
    }
    case kTargetUnitTag: {
      _internal_set_target_unit_tag(from._internal_target_unit_tag());
      break;
    }
    case TARGET_NOT_SET: {
      break;
    }
  }
}

void ActionRawUnitCommand::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.ActionRawUnitCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ActionRawUnitCommand::CopyFrom(const ActionRawUnitCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRawUnitCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRawUnitCommand::IsInitialized() const {
  return true;
}

void ActionRawUnitCommand::InternalSwap(ActionRawUnitCommand* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  unit_tags_.InternalSwap(&other->unit_tags_);
  swap(ability_id_, other->ability_id_);
  swap(queue_command_, other->queue_command_);
  swap(target_, other->target_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRawUnitCommand::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ActionRawCameraMove::InitAsDefaultInstance() {
  ::SC2APIProtocol::_ActionRawCameraMove_default_instance_._instance.get_mutable()->center_world_space_ = const_cast< ::SC2APIProtocol::Point*>(
      ::SC2APIProtocol::Point::internal_default_instance());
}
class ActionRawCameraMove::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionRawCameraMove>()._has_bits_);
  static const ::SC2APIProtocol::Point& center_world_space(const ActionRawCameraMove* msg);
  static void set_has_center_world_space(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SC2APIProtocol::Point&
ActionRawCameraMove::_Internal::center_world_space(const ActionRawCameraMove* msg) {
  return *msg->center_world_space_;
}
void ActionRawCameraMove::clear_center_world_space() {
  if (center_world_space_ != nullptr) center_world_space_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ActionRawCameraMove::ActionRawCameraMove()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.ActionRawCameraMove)
}
ActionRawCameraMove::ActionRawCameraMove(const ActionRawCameraMove& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_center_world_space()) {
    center_world_space_ = new ::SC2APIProtocol::Point(*from.center_world_space_);
  } else {
    center_world_space_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRawCameraMove)
}

void ActionRawCameraMove::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto.base);
  center_world_space_ = nullptr;
}

ActionRawCameraMove::~ActionRawCameraMove() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRawCameraMove)
  SharedDtor();
}

void ActionRawCameraMove::SharedDtor() {
  if (this != internal_default_instance()) delete center_world_space_;
}

void ActionRawCameraMove::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ActionRawCameraMove& ActionRawCameraMove::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ActionRawCameraMove_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void ActionRawCameraMove::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRawCameraMove)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(center_world_space_ != nullptr);
    center_world_space_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ActionRawCameraMove::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SC2APIProtocol.Point center_world_space = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_center_world_space(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ActionRawCameraMove::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRawCameraMove)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SC2APIProtocol.Point center_world_space = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::center_world_space(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRawCameraMove)
  return target;
}

size_t ActionRawCameraMove::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRawCameraMove)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .SC2APIProtocol.Point center_world_space = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *center_world_space_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionRawCameraMove::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.ActionRawCameraMove)
  GOOGLE_DCHECK_NE(&from, this);
  const ActionRawCameraMove* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ActionRawCameraMove>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.ActionRawCameraMove)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.ActionRawCameraMove)
    MergeFrom(*source);
  }
}

void ActionRawCameraMove::MergeFrom(const ActionRawCameraMove& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRawCameraMove)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_center_world_space()) {
    _internal_mutable_center_world_space()->::SC2APIProtocol::Point::MergeFrom(from._internal_center_world_space());
  }
}

void ActionRawCameraMove::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.ActionRawCameraMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ActionRawCameraMove::CopyFrom(const ActionRawCameraMove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRawCameraMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRawCameraMove::IsInitialized() const {
  return true;
}

void ActionRawCameraMove::InternalSwap(ActionRawCameraMove* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(center_world_space_, other->center_world_space_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRawCameraMove::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ActionRawToggleAutocast::InitAsDefaultInstance() {
}
class ActionRawToggleAutocast::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionRawToggleAutocast>()._has_bits_);
  static void set_has_ability_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ActionRawToggleAutocast::ActionRawToggleAutocast()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SC2APIProtocol.ActionRawToggleAutocast)
}
ActionRawToggleAutocast::ActionRawToggleAutocast(const ActionRawToggleAutocast& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      unit_tags_(from.unit_tags_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ability_id_ = from.ability_id_;
  // @@protoc_insertion_point(copy_constructor:SC2APIProtocol.ActionRawToggleAutocast)
}

void ActionRawToggleAutocast::SharedCtor() {
  ability_id_ = 0;
}

ActionRawToggleAutocast::~ActionRawToggleAutocast() {
  // @@protoc_insertion_point(destructor:SC2APIProtocol.ActionRawToggleAutocast)
  SharedDtor();
}

void ActionRawToggleAutocast::SharedDtor() {
}

void ActionRawToggleAutocast::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ActionRawToggleAutocast& ActionRawToggleAutocast::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ActionRawToggleAutocast_s2clientprotocol_2fraw_2eproto.base);
  return *internal_default_instance();
}


void ActionRawToggleAutocast::Clear() {
// @@protoc_insertion_point(message_clear_start:SC2APIProtocol.ActionRawToggleAutocast)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  unit_tags_.Clear();
  ability_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ActionRawToggleAutocast::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 ability_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ability_id(&has_bits);
          ability_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint64 unit_tags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_unit_tags(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_unit_tags(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ActionRawToggleAutocast::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC2APIProtocol.ActionRawToggleAutocast)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 ability_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_ability_id(), target);
  }

  // repeated uint64 unit_tags = 2;
  for (int i = 0, n = this->_internal_unit_tags_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_unit_tags(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC2APIProtocol.ActionRawToggleAutocast)
  return target;
}

size_t ActionRawToggleAutocast::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC2APIProtocol.ActionRawToggleAutocast)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 unit_tags = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->unit_tags_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_unit_tags_size());
    total_size += data_size;
  }

  // optional int32 ability_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_ability_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionRawToggleAutocast::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SC2APIProtocol.ActionRawToggleAutocast)
  GOOGLE_DCHECK_NE(&from, this);
  const ActionRawToggleAutocast* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ActionRawToggleAutocast>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SC2APIProtocol.ActionRawToggleAutocast)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SC2APIProtocol.ActionRawToggleAutocast)
    MergeFrom(*source);
  }
}

void ActionRawToggleAutocast::MergeFrom(const ActionRawToggleAutocast& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SC2APIProtocol.ActionRawToggleAutocast)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  unit_tags_.MergeFrom(from.unit_tags_);
  if (from._internal_has_ability_id()) {
    _internal_set_ability_id(from._internal_ability_id());
  }
}

void ActionRawToggleAutocast::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SC2APIProtocol.ActionRawToggleAutocast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ActionRawToggleAutocast::CopyFrom(const ActionRawToggleAutocast& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC2APIProtocol.ActionRawToggleAutocast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionRawToggleAutocast::IsInitialized() const {
  return true;
}

void ActionRawToggleAutocast::InternalSwap(ActionRawToggleAutocast* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  unit_tags_.InternalSwap(&other->unit_tags_);
  swap(ability_id_, other->ability_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActionRawToggleAutocast::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace SC2APIProtocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::StartRaw* Arena::CreateMaybeMessage< ::SC2APIProtocol::StartRaw >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::StartRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ObservationRaw* Arena::CreateMaybeMessage< ::SC2APIProtocol::ObservationRaw >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::ObservationRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::RadarRing* Arena::CreateMaybeMessage< ::SC2APIProtocol::RadarRing >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::RadarRing >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::PowerSource* Arena::CreateMaybeMessage< ::SC2APIProtocol::PowerSource >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::PowerSource >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::PlayerRaw* Arena::CreateMaybeMessage< ::SC2APIProtocol::PlayerRaw >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::PlayerRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::UnitOrder* Arena::CreateMaybeMessage< ::SC2APIProtocol::UnitOrder >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::UnitOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::PassengerUnit* Arena::CreateMaybeMessage< ::SC2APIProtocol::PassengerUnit >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::PassengerUnit >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::RallyTarget* Arena::CreateMaybeMessage< ::SC2APIProtocol::RallyTarget >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::RallyTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Unit* Arena::CreateMaybeMessage< ::SC2APIProtocol::Unit >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::Unit >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::MapState* Arena::CreateMaybeMessage< ::SC2APIProtocol::MapState >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::MapState >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Event* Arena::CreateMaybeMessage< ::SC2APIProtocol::Event >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::Event >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::Effect* Arena::CreateMaybeMessage< ::SC2APIProtocol::Effect >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::Effect >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRaw* Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRaw >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::ActionRaw >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRawUnitCommand* Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRawUnitCommand >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::ActionRawUnitCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRawCameraMove* Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRawCameraMove >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::ActionRawCameraMove >(arena);
}
template<> PROTOBUF_NOINLINE ::SC2APIProtocol::ActionRawToggleAutocast* Arena::CreateMaybeMessage< ::SC2APIProtocol::ActionRawToggleAutocast >(Arena* arena) {
  return Arena::CreateInternal< ::SC2APIProtocol::ActionRawToggleAutocast >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
